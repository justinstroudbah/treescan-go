// Code generated from ApexParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // ApexParser

import (
	"fmt"
	"strconv"
  	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}


type ApexParser struct {
	*antlr.BaseParser
}

var ApexParserParserStaticData struct {
  once                   sync.Once
  serializedATN          []int32
  LiteralNames           []string
  SymbolicNames          []string
  RuleNames              []string
  PredictionContextCache *antlr.PredictionContextCache
  atn                    *antlr.ATN
  decisionToDFA          []*antlr.DFA
}

func apexparserParserInit() {
  staticData := &ApexParserParserStaticData
  staticData.LiteralNames = []string{
    "", "'abstract'", "'after'", "'before'", "'break'", "'catch'", "'class'", 
    "'continue'", "'delete'", "'do'", "'else'", "'enum'", "'extends'", "'final'", 
    "'finally'", "'for'", "'get'", "'global'", "'if'", "'implements'", "'inherited'", 
    "'insert'", "'instanceof'", "'interface'", "'merge'", "'new'", "'null'", 
    "'on'", "'override'", "'private'", "'protected'", "'public'", "'return'", 
    "'system.runas'", "'set'", "'sharing'", "'static'", "'super'", "'switch'", 
    "'testmethod'", "'this'", "'throw'", "'transient'", "'trigger'", "'try'", 
    "'undelete'", "'update'", "'upsert'", "'virtual'", "'void'", "'webservice'", 
    "'when'", "'while'", "'with'", "'without'", "'list'", "'map'", "'system'", 
    "'user'", "'select'", "'count'", "'from'", "'as'", "'using'", "'scope'", 
    "'where'", "'order'", "'by'", "'limit'", "'and'", "'or'", "'not'", "'avg'", 
    "'count_distinct'", "'min'", "'max'", "'sum'", "'typeof'", "'end'", 
    "'then'", "'like'", "'in'", "'includes'", "'excludes'", "'asc'", "'desc'", 
    "'nulls'", "'first'", "'last'", "'group'", "'all'", "'rows'", "'view'", 
    "'having'", "'rollup'", "'tolabel'", "'offset'", "'data'", "'category'", 
    "'at'", "'above'", "'below'", "'above_or_below'", "'security_enforced'", 
    "'system_mode'", "'user_mode'", "'reference'", "'cube'", "'format'", 
    "'tracking'", "'viewstat'", "'custom'", "'standard'", "'distance'", 
    "'geolocation'", "'grouping'", "'convertcurrency'", "'calendar_month'", 
    "'calendar_quarter'", "'calendar_year'", "'day_in_month'", "'day_in_week'", 
    "'day_in_year'", "'day_only'", "'fiscal_month'", "'fiscal_quarter'", 
    "'fiscal_year'", "'hour_in_day'", "'week_in_month'", "'week_in_year'", 
    "'converttimezone'", "'yesterday'", "'today'", "'tomorrow'", "'last_week'", 
    "'this_week'", "'next_week'", "'last_month'", "'this_month'", "'next_month'", 
    "'last_90_days'", "'next_90_days'", "'last_n_days'", "'next_n_days'", 
    "'n_days_ago'", "'next_n_weeks'", "'last_n_weeks'", "'n_weeks_ago'", 
    "'next_n_months'", "'last_n_months'", "'n_months_ago'", "'this_quarter'", 
    "'last_quarter'", "'next_quarter'", "'next_n_quarters'", "'last_n_quarters'", 
    "'n_quarters_ago'", "'this_year'", "'last_year'", "'next_year'", "'next_n_years'", 
    "'last_n_years'", "'n_years_ago'", "'this_fiscal_quarter'", "'last_fiscal_quarter'", 
    "'next_fiscal_quarter'", "'next_n_fiscal_quarters'", "'last_n_fiscal_quarters'", 
    "'n_fiscal_quarters_ago'", "'this_fiscal_year'", "'last_fiscal_year'", 
    "'next_fiscal_year'", "'next_n_fiscal_years'", "'last_n_fiscal_years'", 
    "'n_fiscal_years_ago'", "", "", "", "'find'", "'email'", "'name'", "'phone'", 
    "'sidebar'", "'fields'", "'metadata'", "'pricebookid'", "'network'", 
    "'snippet'", "'target_length'", "'division'", "'returning'", "'listview'", 
    "", "", "", "", "", "", "", "", "'('", "')'", "'{'", "'}'", "'['", "']'", 
    "';'", "','", "'.'", "'='", "'>'", "'<'", "'!'", "'~'", "'?.'", "'?'", 
    "':'", "'=='", "'==='", "'!='", "'<>'", "'!=='", "'&&'", "'||'", "'??'", 
    "'++'", "'--'", "'+'", "'-'", "'*'", "'/'", "'&'", "'|'", "'^'", "'=>'", 
    "'+='", "'-='", "'*='", "'/='", "'&='", "'|='", "'^='", "'<<='", "'>>='", 
    "'>>>='", "'@'",
  }
  staticData.SymbolicNames = []string{
    "", "ABSTRACT", "AFTER", "BEFORE", "BREAK", "CATCH", "CLASS", "CONTINUE", 
    "DELETE", "DO", "ELSE", "ENUM", "EXTENDS", "FINAL", "FINALLY", "FOR", 
    "GET", "GLOBAL", "IF", "IMPLEMENTS", "INHERITED", "INSERT", "INSTANCEOF", 
    "INTERFACE", "MERGE", "NEW", "NULL", "ON", "OVERRIDE", "PRIVATE", "PROTECTED", 
    "PUBLIC", "RETURN", "SYSTEMRUNAS", "SET", "SHARING", "STATIC", "SUPER", 
    "SWITCH", "TESTMETHOD", "THIS", "THROW", "TRANSIENT", "TRIGGER", "TRY", 
    "UNDELETE", "UPDATE", "UPSERT", "VIRTUAL", "VOID", "WEBSERVICE", "WHEN", 
    "WHILE", "WITH", "WITHOUT", "LIST", "MAP", "SYSTEM", "USER", "SELECT", 
    "COUNT", "FROM", "AS", "USING", "SCOPE", "WHERE", "ORDER", "BY", "LIMIT", 
    "SOQLAND", "SOQLOR", "NOT", "AVG", "COUNT_DISTINCT", "MIN", "MAX", "SUM", 
    "TYPEOF", "END", "THEN", "LIKE", "IN", "INCLUDES", "EXCLUDES", "ASC", 
    "DESC", "NULLS", "FIRST", "LAST", "GROUP", "ALL", "ROWS", "VIEW", "HAVING", 
    "ROLLUP", "TOLABEL", "OFFSET", "DATA", "CATEGORY", "AT", "ABOVE", "BELOW", 
    "ABOVE_OR_BELOW", "SECURITY_ENFORCED", "SYSTEM_MODE", "USER_MODE", "REFERENCE", 
    "CUBE", "FORMAT", "TRACKING", "VIEWSTAT", "CUSTOM", "STANDARD", "DISTANCE", 
    "GEOLOCATION", "GROUPING", "CONVERT_CURRENCY", "CALENDAR_MONTH", "CALENDAR_QUARTER", 
    "CALENDAR_YEAR", "DAY_IN_MONTH", "DAY_IN_WEEK", "DAY_IN_YEAR", "DAY_ONLY", 
    "FISCAL_MONTH", "FISCAL_QUARTER", "FISCAL_YEAR", "HOUR_IN_DAY", "WEEK_IN_MONTH", 
    "WEEK_IN_YEAR", "CONVERT_TIMEZONE", "YESTERDAY", "TODAY", "TOMORROW", 
    "LAST_WEEK", "THIS_WEEK", "NEXT_WEEK", "LAST_MONTH", "THIS_MONTH", "NEXT_MONTH", 
    "LAST_90_DAYS", "NEXT_90_DAYS", "LAST_N_DAYS_N", "NEXT_N_DAYS_N", "N_DAYS_AGO_N", 
    "NEXT_N_WEEKS_N", "LAST_N_WEEKS_N", "N_WEEKS_AGO_N", "NEXT_N_MONTHS_N", 
    "LAST_N_MONTHS_N", "N_MONTHS_AGO_N", "THIS_QUARTER", "LAST_QUARTER", 
    "NEXT_QUARTER", "NEXT_N_QUARTERS_N", "LAST_N_QUARTERS_N", "N_QUARTERS_AGO_N", 
    "THIS_YEAR", "LAST_YEAR", "NEXT_YEAR", "NEXT_N_YEARS_N", "LAST_N_YEARS_N", 
    "N_YEARS_AGO_N", "THIS_FISCAL_QUARTER", "LAST_FISCAL_QUARTER", "NEXT_FISCAL_QUARTER", 
    "NEXT_N_FISCAL_QUARTERS_N", "LAST_N_FISCAL_QUARTERS_N", "N_FISCAL_QUARTERS_AGO_N", 
    "THIS_FISCAL_YEAR", "LAST_FISCAL_YEAR", "NEXT_FISCAL_YEAR", "NEXT_N_FISCAL_YEARS_N", 
    "LAST_N_FISCAL_YEARS_N", "N_FISCAL_YEARS_AGO_N", "DateLiteral", "DateTimeLiteral", 
    "IntegralCurrencyLiteral", "FIND", "EMAIL", "NAME", "PHONE", "SIDEBAR", 
    "FIELDS", "METADATA", "PRICEBOOKID", "NETWORK", "SNIPPET", "TARGET_LENGTH", 
    "DIVISION", "RETURNING", "LISTVIEW", "FindLiteral", "FindLiteralAlt", 
    "IntegerLiteral", "LongLiteral", "NumberLiteral", "BooleanLiteral", 
    "StringLiteral", "NullLiteral", "LPAREN", "RPAREN", "LBRACE", "RBRACE", 
    "LBRACK", "RBRACK", "SEMI", "COMMA", "DOT", "ASSIGN", "GT", "LT", "BANG", 
    "TILDE", "QUESTIONDOT", "QUESTION", "COLON", "EQUAL", "TRIPLEEQUAL", 
    "NOTEQUAL", "LESSANDGREATER", "TRIPLENOTEQUAL", "AND", "OR", "COAL", 
    "INC", "DEC", "ADD", "SUB", "MUL", "DIV", "BITAND", "BITOR", "CARET", 
    "MAPTO", "ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", "AND_ASSIGN", 
    "OR_ASSIGN", "XOR_ASSIGN", "LSHIFT_ASSIGN", "RSHIFT_ASSIGN", "URSHIFT_ASSIGN", 
    "ATSIGN", "Identifier", "WS", "DOC_COMMENT", "COMMENT", "LINE_COMMENT",
  }
  staticData.RuleNames = []string{
    "triggerUnit", "triggerCase", "triggerBlock", "triggerBlockMember", 
    "compilationUnit", "typeDeclaration", "classDeclaration", "enumDeclaration", 
    "enumConstants", "interfaceDeclaration", "typeList", "classBody", "interfaceBody", 
    "classBodyDeclaration", "modifier", "memberDeclaration", "triggerMemberDeclaration", 
    "methodDeclaration", "constructorDeclaration", "fieldDeclaration", "propertyDeclaration", 
    "interfaceMethodDeclaration", "variableDeclarators", "variableDeclarator", 
    "arrayInitializer", "typeRef", "arraySubscripts", "typeName", "typeArguments", 
    "formalParameters", "formalParameterList", "formalParameter", "qualifiedName", 
    "literal", "annotation", "elementValuePairs", "elementValuePair", "elementValue", 
    "elementValueArrayInitializer", "block", "localVariableDeclarationStatement", 
    "localVariableDeclaration", "statement", "ifStatement", "switchStatement", 
    "whenControl", "whenValue", "whenLiteral", "forStatement", "whileStatement", 
    "doWhileStatement", "tryStatement", "returnStatement", "throwStatement", 
    "breakStatement", "continueStatement", "accessLevel", "insertStatement", 
    "updateStatement", "deleteStatement", "undeleteStatement", "upsertStatement", 
    "mergeStatement", "runAsStatement", "expressionStatement", "propertyBlock", 
    "getter", "setter", "catchClause", "finallyBlock", "forControl", "forInit", 
    "enhancedForControl", "forUpdate", "parExpression", "expressionList", 
    "expression", "primary", "methodCall", "dotMethodCall", "creator", "createdName", 
    "idCreatedNamePair", "noRest", "classCreatorRest", "arrayCreatorRest", 
    "mapCreatorRest", "mapCreatorRestPair", "setCreatorRest", "arguments", 
    "soqlLiteral", "query", "subQuery", "selectList", "selectEntry", "fieldName", 
    "fromNameList", "subFieldList", "subFieldEntry", "soqlFieldsParameter", 
    "soqlFunction", "dateFieldName", "locationValue", "coordinateValue", 
    "typeOf", "whenClause", "elseClause", "fieldNameList", "usingScope", 
    "whereClause", "logicalExpression", "conditionalExpression", "fieldExpression", 
    "comparisonOperator", "value", "valueList", "signedNumber", "withClause", 
    "filteringExpression", "dataCategorySelection", "dataCategoryName", 
    "filteringSelector", "groupByClause", "orderByClause", "fieldOrderList", 
    "fieldOrder", "limitClause", "offsetClause", "allRowsClause", "forClauses", 
    "boundExpression", "dateFormula", "signedInteger", "soqlId", "soslLiteral", 
    "soslLiteralAlt", "soslClauses", "soslWithClause", "searchGroup", "fieldSpecList", 
    "fieldSpec", "fieldList", "updateList", "updateType", "networkList", 
    "soslId", "id", "anyId",
  }
  staticData.PredictionContextCache = antlr.NewPredictionContextCache()
  staticData.serializedATN = []int32{
	4, 1, 250, 1978, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 
	7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 
	7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 
	15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 
	2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 
	26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 
	7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 
	36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 
	2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 
	47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 
	7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 
	57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 
	2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 
	68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 
	7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 
	78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 
	2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 
	89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 
	7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 
	99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2, 
	104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 
	108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2, 
	113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7, 
	117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2, 
	122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7, 
	126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2, 
	131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7, 
	135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2, 
	140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7, 
	144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 1, 0, 1, 0, 1, 0, 
	1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 5, 0, 305, 8, 0, 10, 0, 12, 0, 308, 9, 0, 
	1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 5, 2, 319, 8, 2, 
	10, 2, 12, 2, 322, 9, 2, 1, 2, 1, 2, 1, 3, 5, 3, 327, 8, 3, 10, 3, 12, 
	3, 330, 9, 3, 1, 3, 1, 3, 3, 3, 334, 8, 3, 1, 4, 1, 4, 1, 4, 1, 5, 5, 5, 
	340, 8, 5, 10, 5, 12, 5, 343, 9, 5, 1, 5, 1, 5, 5, 5, 347, 8, 5, 10, 5, 
	12, 5, 350, 9, 5, 1, 5, 1, 5, 5, 5, 354, 8, 5, 10, 5, 12, 5, 357, 9, 5, 
	1, 5, 3, 5, 360, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 366, 8, 6, 1, 6, 1, 
	6, 3, 6, 370, 8, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 378, 8, 7, 
	1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 5, 8, 385, 8, 8, 10, 8, 12, 8, 388, 9, 8, 
	1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 394, 8, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 
	5, 10, 401, 8, 10, 10, 10, 12, 10, 404, 9, 10, 1, 11, 1, 11, 5, 11, 408, 
	8, 11, 10, 11, 12, 11, 411, 9, 11, 1, 11, 1, 11, 1, 12, 1, 12, 5, 12, 417, 
	8, 12, 10, 12, 12, 12, 420, 9, 12, 1, 12, 1, 12, 1, 13, 1, 13, 3, 13, 426, 
	8, 13, 1, 13, 1, 13, 5, 13, 430, 8, 13, 10, 13, 12, 13, 433, 9, 13, 1, 
	13, 3, 13, 436, 8, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 
	1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 
	14, 1, 14, 3, 14, 457, 8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 
	1, 15, 3, 15, 466, 8, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 
	16, 474, 8, 16, 1, 17, 1, 17, 3, 17, 478, 8, 17, 1, 17, 1, 17, 1, 17, 1, 
	17, 3, 17, 484, 8, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 
	1, 19, 1, 20, 1, 20, 1, 20, 1, 20, 5, 20, 498, 8, 20, 10, 20, 12, 20, 501, 
	9, 20, 1, 20, 1, 20, 1, 21, 5, 21, 506, 8, 21, 10, 21, 12, 21, 509, 9, 
	21, 1, 21, 1, 21, 3, 21, 513, 8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 22, 
	1, 22, 1, 22, 5, 22, 522, 8, 22, 10, 22, 12, 22, 525, 9, 22, 1, 23, 1, 
	23, 1, 23, 3, 23, 530, 8, 23, 1, 24, 1, 24, 1, 24, 1, 24, 5, 24, 536, 8, 
	24, 10, 24, 12, 24, 539, 9, 24, 1, 24, 3, 24, 542, 8, 24, 3, 24, 544, 8, 
	24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 5, 25, 551, 8, 25, 10, 25, 12, 25, 
	554, 9, 25, 1, 25, 1, 25, 1, 26, 1, 26, 5, 26, 560, 8, 26, 10, 26, 12, 
	26, 563, 9, 26, 1, 27, 1, 27, 3, 27, 567, 8, 27, 1, 27, 1, 27, 3, 27, 571, 
	8, 27, 1, 27, 1, 27, 3, 27, 575, 8, 27, 1, 27, 1, 27, 3, 27, 579, 8, 27, 
	3, 27, 581, 8, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29, 3, 29, 589, 
	8, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 5, 30, 596, 8, 30, 10, 30, 12, 
	30, 599, 9, 30, 1, 31, 5, 31, 602, 8, 31, 10, 31, 12, 31, 605, 9, 31, 1, 
	31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 5, 32, 613, 8, 32, 10, 32, 12, 32, 
	616, 9, 32, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 625, 
	8, 34, 1, 34, 3, 34, 628, 8, 34, 1, 35, 1, 35, 3, 35, 632, 8, 35, 1, 35, 
	5, 35, 635, 8, 35, 10, 35, 12, 35, 638, 9, 35, 1, 36, 1, 36, 1, 36, 1, 
	36, 1, 37, 1, 37, 1, 37, 3, 37, 647, 8, 37, 1, 38, 1, 38, 1, 38, 1, 38, 
	5, 38, 653, 8, 38, 10, 38, 12, 38, 656, 9, 38, 3, 38, 658, 8, 38, 1, 38, 
	3, 38, 661, 8, 38, 1, 38, 1, 38, 1, 39, 1, 39, 5, 39, 667, 8, 39, 10, 39, 
	12, 39, 670, 9, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 41, 5, 41, 678, 
	8, 41, 10, 41, 12, 41, 681, 9, 41, 1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 
	42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 
	1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 706, 8, 42, 1, 
	43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 713, 8, 43, 1, 44, 1, 44, 1, 44, 
	1, 44, 1, 44, 4, 44, 720, 8, 44, 11, 44, 12, 44, 721, 1, 44, 1, 44, 1, 
	45, 1, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 5, 46, 734, 8, 46, 
	10, 46, 12, 46, 737, 9, 46, 1, 46, 1, 46, 1, 46, 3, 46, 742, 8, 46, 1, 
	47, 5, 47, 745, 8, 47, 10, 47, 12, 47, 748, 9, 47, 1, 47, 1, 47, 5, 47, 
	752, 8, 47, 10, 47, 12, 47, 755, 9, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 
	47, 1, 47, 1, 47, 1, 47, 3, 47, 765, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 
	1, 48, 1, 48, 3, 48, 773, 8, 48, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 779, 
	8, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 4, 
	51, 790, 8, 51, 11, 51, 12, 51, 791, 1, 51, 3, 51, 795, 8, 51, 1, 51, 3, 
	51, 798, 8, 51, 1, 52, 1, 52, 3, 52, 802, 8, 52, 1, 52, 1, 52, 1, 53, 1, 
	53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 
	1, 56, 1, 57, 1, 57, 3, 57, 821, 8, 57, 1, 57, 1, 57, 1, 57, 1, 58, 1, 
	58, 3, 58, 828, 8, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59, 3, 59, 835, 8, 
	59, 1, 59, 1, 59, 1, 59, 1, 60, 1, 60, 3, 60, 842, 8, 60, 1, 60, 1, 60, 
	1, 60, 1, 61, 1, 61, 3, 61, 849, 8, 61, 1, 61, 1, 61, 3, 61, 853, 8, 61, 
	1, 61, 1, 61, 1, 62, 1, 62, 3, 62, 859, 8, 62, 1, 62, 1, 62, 1, 62, 1, 
	62, 1, 63, 1, 63, 1, 63, 3, 63, 868, 8, 63, 1, 63, 1, 63, 1, 63, 1, 64, 
	1, 64, 1, 64, 1, 65, 5, 65, 877, 8, 65, 10, 65, 12, 65, 880, 9, 65, 1, 
	65, 1, 65, 3, 65, 884, 8, 65, 1, 66, 1, 66, 1, 66, 3, 66, 889, 8, 66, 1, 
	67, 1, 67, 1, 67, 3, 67, 894, 8, 67, 1, 68, 1, 68, 1, 68, 5, 68, 899, 8, 
	68, 10, 68, 12, 68, 902, 9, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 69, 
	1, 69, 1, 69, 1, 70, 1, 70, 3, 70, 914, 8, 70, 1, 70, 1, 70, 3, 70, 918, 
	8, 70, 1, 70, 1, 70, 3, 70, 922, 8, 70, 3, 70, 924, 8, 70, 1, 71, 1, 71, 
	3, 71, 928, 8, 71, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 
	74, 1, 74, 1, 74, 1, 74, 1, 75, 1, 75, 1, 75, 5, 75, 944, 8, 75, 10, 75, 
	12, 75, 947, 9, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 
	76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 
	3, 76, 967, 8, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 
	76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 983, 8, 76, 1, 76, 
	1, 76, 1, 76, 1, 76, 3, 76, 989, 8, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 
	76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 
	1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 
	76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 
	1026, 8, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 
	76, 1, 76, 5, 76, 1038, 8, 76, 10, 76, 12, 76, 1041, 9, 76, 1, 77, 1, 77, 
	1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 
	77, 3, 77, 1056, 8, 77, 1, 78, 1, 78, 1, 78, 3, 78, 1061, 8, 78, 1, 78, 
	1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1068, 8, 78, 1, 78, 1, 78, 1, 78, 1, 
	78, 3, 78, 1074, 8, 78, 1, 78, 3, 78, 1077, 8, 78, 1, 79, 1, 79, 1, 79, 
	3, 79, 1082, 8, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 
	80, 3, 80, 1092, 8, 80, 1, 81, 1, 81, 1, 81, 5, 81, 1097, 8, 81, 10, 81, 
	12, 81, 1100, 9, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1107, 8, 
	82, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 
	1, 85, 1, 85, 3, 85, 1121, 8, 85, 3, 85, 1123, 8, 85, 1, 86, 1, 86, 1, 
	86, 1, 86, 5, 86, 1129, 8, 86, 10, 86, 12, 86, 1132, 9, 86, 1, 86, 1, 86, 
	1, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88, 5, 88, 1144, 8, 
	88, 10, 88, 12, 88, 1147, 9, 88, 1, 88, 1, 88, 1, 89, 1, 89, 3, 89, 1153, 
	8, 89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 
	91, 1, 91, 3, 91, 1166, 8, 91, 1, 91, 3, 91, 1169, 8, 91, 1, 91, 3, 91, 
	1172, 8, 91, 1, 91, 3, 91, 1175, 8, 91, 1, 91, 3, 91, 1178, 8, 91, 1, 91, 
	3, 91, 1181, 8, 91, 1, 91, 3, 91, 1184, 8, 91, 1, 91, 3, 91, 1187, 8, 91, 
	1, 91, 1, 91, 1, 91, 3, 91, 1192, 8, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 
	92, 3, 92, 1199, 8, 92, 1, 92, 3, 92, 1202, 8, 92, 1, 92, 3, 92, 1205, 
	8, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1210, 8, 92, 1, 93, 1, 93, 1, 93, 5, 
	93, 1215, 8, 93, 10, 93, 12, 93, 1218, 9, 93, 1, 94, 1, 94, 3, 94, 1222, 
	8, 94, 1, 94, 1, 94, 3, 94, 1226, 8, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3, 
	94, 1232, 8, 94, 1, 94, 3, 94, 1235, 8, 94, 1, 95, 1, 95, 1, 95, 5, 95, 
	1240, 8, 95, 10, 95, 12, 95, 1243, 9, 95, 1, 96, 1, 96, 3, 96, 1247, 8, 
	96, 1, 96, 1, 96, 1, 96, 3, 96, 1252, 8, 96, 5, 96, 1254, 8, 96, 10, 96, 
	12, 96, 1257, 9, 96, 1, 97, 1, 97, 1, 97, 5, 97, 1262, 8, 97, 10, 97, 12, 
	97, 1265, 9, 97, 1, 98, 1, 98, 3, 98, 1269, 8, 98, 1, 98, 1, 98, 3, 98, 
	1273, 8, 98, 1, 98, 1, 98, 1, 98, 1, 98, 3, 98, 1279, 8, 98, 1, 98, 3, 
	98, 1282, 8, 98, 1, 99, 1, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 
	1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 
	1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 
	1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 
	1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 
	1, 100, 3, 100, 1328, 8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 
	100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 
	100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 
	100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 
	100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 
	100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 
	100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 
	100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 
	100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 
	100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 
	100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 1421, 8, 100, 1, 101, 1, 101, 
	1, 101, 1, 101, 1, 101, 1, 101, 3, 101, 1429, 8, 101, 1, 102, 1, 102, 1, 
	102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 3, 102, 1440, 8, 102, 
	1, 103, 1, 103, 3, 103, 1444, 8, 103, 1, 104, 1, 104, 1, 104, 4, 104, 1449, 
	8, 104, 11, 104, 12, 104, 1450, 1, 104, 3, 104, 1454, 8, 104, 1, 104, 1, 
	104, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 106, 1, 106, 1, 106, 1, 
	107, 1, 107, 1, 107, 5, 107, 1469, 8, 107, 10, 107, 12, 107, 1472, 9, 107, 
	1, 108, 1, 108, 1, 108, 1, 108, 1, 109, 1, 109, 1, 109, 1, 110, 1, 110, 
	1, 110, 5, 110, 1484, 8, 110, 10, 110, 12, 110, 1487, 9, 110, 1, 110, 1, 
	110, 1, 110, 5, 110, 1492, 8, 110, 10, 110, 12, 110, 1495, 9, 110, 1, 110, 
	1, 110, 3, 110, 1499, 8, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 3, 
	111, 1506, 8, 111, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 
	1, 112, 3, 112, 1516, 8, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 
	113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 
	113, 3, 113, 1533, 8, 113, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 
	1, 114, 1, 114, 1, 114, 1, 114, 3, 114, 1545, 8, 114, 3, 114, 1547, 8, 
	114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 3, 114, 1555, 8, 114, 
	1, 115, 1, 115, 1, 115, 1, 115, 5, 115, 1561, 8, 115, 10, 115, 12, 115, 
	1564, 9, 115, 1, 115, 1, 115, 1, 116, 3, 116, 1569, 8, 116, 1, 116, 1, 
	116, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 
	117, 1, 117, 1, 117, 1, 117, 3, 117, 1585, 8, 117, 1, 118, 1, 118, 1, 118, 
	5, 118, 1590, 8, 118, 10, 118, 12, 118, 1593, 9, 118, 1, 119, 1, 119, 1, 
	119, 1, 119, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 5, 120, 1604, 8, 120, 
	10, 120, 12, 120, 1607, 9, 120, 1, 120, 1, 120, 3, 120, 1611, 8, 120, 1, 
	121, 1, 121, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 3, 122, 1620, 8, 122, 
	1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 5, 122, 1629, 8, 
	122, 10, 122, 12, 122, 1632, 9, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 
	122, 1, 122, 1, 122, 1, 122, 1, 122, 5, 122, 1643, 8, 122, 10, 122, 12, 
	122, 1646, 9, 122, 1, 122, 1, 122, 3, 122, 1650, 8, 122, 1, 123, 1, 123, 
	1, 123, 1, 123, 1, 124, 1, 124, 1, 124, 5, 124, 1659, 8, 124, 10, 124, 
	12, 124, 1662, 9, 124, 1, 125, 1, 125, 3, 125, 1666, 8, 125, 1, 125, 1, 
	125, 3, 125, 1670, 8, 125, 1, 125, 1, 125, 3, 125, 1674, 8, 125, 1, 125, 
	1, 125, 3, 125, 1678, 8, 125, 3, 125, 1680, 8, 125, 1, 126, 1, 126, 1, 
	126, 1, 126, 3, 126, 1686, 8, 126, 1, 127, 1, 127, 1, 127, 1, 127, 3, 127, 
	1692, 8, 127, 1, 128, 1, 128, 1, 128, 1, 129, 1, 129, 5, 129, 1699, 8, 
	129, 10, 129, 12, 129, 1702, 9, 129, 1, 130, 1, 130, 1, 130, 1, 131, 1, 
	131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 
	131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 
	131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 
	131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 
	131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 
	131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 
	131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 
	131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 
	131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 
	131, 1, 131, 1, 131, 1, 131, 3, 131, 1793, 8, 131, 1, 132, 3, 132, 1796, 
	8, 132, 1, 132, 1, 132, 1, 133, 1, 133, 1, 134, 1, 134, 1, 134, 1, 134, 
	1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 3, 134, 1812, 8, 134, 1, 
	135, 1, 135, 1, 135, 1, 135, 1, 136, 1, 136, 3, 136, 1820, 8, 136, 1, 136, 
	1, 136, 3, 136, 1824, 8, 136, 1, 136, 5, 136, 1827, 8, 136, 10, 136, 12, 
	136, 1830, 9, 136, 1, 136, 3, 136, 1833, 8, 136, 1, 136, 1, 136, 3, 136, 
	1837, 8, 136, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 
	137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 3, 137, 1854, 
	8, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 
	1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 
	1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 3, 137, 1879, 8, 137, 1, 
	138, 1, 138, 1, 138, 1, 139, 1, 139, 1, 139, 5, 139, 1887, 8, 139, 10, 
	139, 12, 139, 1890, 9, 139, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 3, 
	140, 1897, 8, 140, 1, 140, 1, 140, 1, 140, 1, 140, 3, 140, 1903, 8, 140, 
	1, 140, 1, 140, 1, 140, 3, 140, 1908, 8, 140, 1, 140, 3, 140, 1911, 8, 
	140, 1, 140, 3, 140, 1914, 8, 140, 1, 140, 1, 140, 3, 140, 1918, 8, 140, 
	1, 141, 1, 141, 1, 141, 5, 141, 1923, 8, 141, 10, 141, 12, 141, 1926, 9, 
	141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 3, 141, 1933, 8, 141, 1, 141, 
	1, 141, 1, 141, 1, 141, 1, 141, 3, 141, 1940, 8, 141, 1, 141, 1, 141, 1, 
	141, 1, 141, 3, 141, 1946, 8, 141, 1, 141, 1, 141, 3, 141, 1950, 8, 141, 
	3, 141, 1952, 8, 141, 1, 142, 1, 142, 1, 142, 3, 142, 1957, 8, 142, 1, 
	143, 1, 143, 1, 144, 1, 144, 1, 144, 3, 144, 1964, 8, 144, 1, 145, 1, 145, 
	1, 145, 5, 145, 1969, 8, 145, 10, 145, 12, 145, 1972, 9, 145, 1, 146, 1, 
	146, 1, 147, 1, 147, 1, 147, 0, 1, 152, 148, 0, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 
	52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 
	88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 
	120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 
	150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 
	180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 
	210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 
	240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 
	270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 0, 23, 
	1, 0, 2, 3, 3, 0, 8, 8, 21, 21, 45, 46, 2, 0, 26, 26, 194, 198, 1, 0, 227, 
	228, 1, 0, 57, 58, 1, 0, 225, 228, 1, 0, 212, 213, 1, 0, 229, 230, 1, 0, 
	210, 211, 1, 0, 217, 221, 2, 0, 209, 209, 235, 244, 2, 0, 208, 208, 214, 
	214, 1, 0, 225, 226, 2, 0, 90, 90, 111, 112, 2, 0, 194, 194, 196, 196, 
	1, 0, 99, 102, 1, 0, 84, 85, 1, 0, 87, 88, 3, 0, 46, 46, 92, 92, 106, 106, 
	2, 0, 90, 90, 179, 182, 1, 0, 109, 110, 12, 0, 2, 3, 16, 16, 20, 20, 22, 
	22, 34, 35, 38, 38, 42, 43, 51, 51, 53, 54, 57, 174, 177, 191, 246, 246, 
	5, 0, 1, 32, 34, 48, 50, 174, 177, 191, 246, 246, 2211, 0, 296, 1, 0, 0, 
	0, 2, 313, 1, 0, 0, 0, 4, 316, 1, 0, 0, 0, 6, 333, 1, 0, 0, 0, 8, 335, 
	1, 0, 0, 0, 10, 359, 1, 0, 0, 0, 12, 361, 1, 0, 0, 0, 14, 373, 1, 0, 0, 
	0, 16, 381, 1, 0, 0, 0, 18, 389, 1, 0, 0, 0, 20, 397, 1, 0, 0, 0, 22, 405, 
	1, 0, 0, 0, 24, 414, 1, 0, 0, 0, 26, 435, 1, 0, 0, 0, 28, 456, 1, 0, 0, 
	0, 30, 465, 1, 0, 0, 0, 32, 473, 1, 0, 0, 0, 34, 477, 1, 0, 0, 0, 36, 485, 
	1, 0, 0, 0, 38, 489, 1, 0, 0, 0, 40, 493, 1, 0, 0, 0, 42, 507, 1, 0, 0, 
	0, 44, 518, 1, 0, 0, 0, 46, 526, 1, 0, 0, 0, 48, 531, 1, 0, 0, 0, 50, 547, 
	1, 0, 0, 0, 52, 561, 1, 0, 0, 0, 54, 580, 1, 0, 0, 0, 56, 582, 1, 0, 0, 
	0, 58, 586, 1, 0, 0, 0, 60, 592, 1, 0, 0, 0, 62, 603, 1, 0, 0, 0, 64, 609, 
	1, 0, 0, 0, 66, 617, 1, 0, 0, 0, 68, 619, 1, 0, 0, 0, 70, 629, 1, 0, 0, 
	0, 72, 639, 1, 0, 0, 0, 74, 646, 1, 0, 0, 0, 76, 648, 1, 0, 0, 0, 78, 664, 
	1, 0, 0, 0, 80, 673, 1, 0, 0, 0, 82, 679, 1, 0, 0, 0, 84, 705, 1, 0, 0, 
	0, 86, 707, 1, 0, 0, 0, 88, 714, 1, 0, 0, 0, 90, 725, 1, 0, 0, 0, 92, 741, 
	1, 0, 0, 0, 94, 764, 1, 0, 0, 0, 96, 766, 1, 0, 0, 0, 98, 774, 1, 0, 0, 
	0, 100, 780, 1, 0, 0, 0, 102, 786, 1, 0, 0, 0, 104, 799, 1, 0, 0, 0, 106, 
	805, 1, 0, 0, 0, 108, 809, 1, 0, 0, 0, 110, 812, 1, 0, 0, 0, 112, 815, 
	1, 0, 0, 0, 114, 818, 1, 0, 0, 0, 116, 825, 1, 0, 0, 0, 118, 832, 1, 0, 
	0, 0, 120, 839, 1, 0, 0, 0, 122, 846, 1, 0, 0, 0, 124, 856, 1, 0, 0, 0, 
	126, 864, 1, 0, 0, 0, 128, 872, 1, 0, 0, 0, 130, 878, 1, 0, 0, 0, 132, 
	885, 1, 0, 0, 0, 134, 890, 1, 0, 0, 0, 136, 895, 1, 0, 0, 0, 138, 908, 
	1, 0, 0, 0, 140, 923, 1, 0, 0, 0, 142, 927, 1, 0, 0, 0, 144, 929, 1, 0, 
	0, 0, 146, 934, 1, 0, 0, 0, 148, 936, 1, 0, 0, 0, 150, 940, 1, 0, 0, 0, 
	152, 966, 1, 0, 0, 0, 154, 1055, 1, 0, 0, 0, 156, 1076, 1, 0, 0, 0, 158, 
	1078, 1, 0, 0, 0, 160, 1085, 1, 0, 0, 0, 162, 1093, 1, 0, 0, 0, 164, 1101, 
	1, 0, 0, 0, 166, 1108, 1, 0, 0, 0, 168, 1111, 1, 0, 0, 0, 170, 1122, 1, 
	0, 0, 0, 172, 1124, 1, 0, 0, 0, 174, 1135, 1, 0, 0, 0, 176, 1139, 1, 0, 
	0, 0, 178, 1150, 1, 0, 0, 0, 180, 1156, 1, 0, 0, 0, 182, 1160, 1, 0, 0, 
	0, 184, 1193, 1, 0, 0, 0, 186, 1211, 1, 0, 0, 0, 188, 1234, 1, 0, 0, 0, 
	190, 1236, 1, 0, 0, 0, 192, 1244, 1, 0, 0, 0, 194, 1258, 1, 0, 0, 0, 196, 
	1281, 1, 0, 0, 0, 198, 1283, 1, 0, 0, 0, 200, 1420, 1, 0, 0, 0, 202, 1428, 
	1, 0, 0, 0, 204, 1439, 1, 0, 0, 0, 206, 1443, 1, 0, 0, 0, 208, 1445, 1, 
	0, 0, 0, 210, 1457, 1, 0, 0, 0, 212, 1462, 1, 0, 0, 0, 214, 1465, 1, 0, 
	0, 0, 216, 1473, 1, 0, 0, 0, 218, 1477, 1, 0, 0, 0, 220, 1498, 1, 0, 0, 
	0, 222, 1505, 1, 0, 0, 0, 224, 1515, 1, 0, 0, 0, 226, 1532, 1, 0, 0, 0, 
	228, 1554, 1, 0, 0, 0, 230, 1556, 1, 0, 0, 0, 232, 1568, 1, 0, 0, 0, 234, 
	1584, 1, 0, 0, 0, 236, 1586, 1, 0, 0, 0, 238, 1594, 1, 0, 0, 0, 240, 1610, 
	1, 0, 0, 0, 242, 1612, 1, 0, 0, 0, 244, 1649, 1, 0, 0, 0, 246, 1651, 1, 
	0, 0, 0, 248, 1655, 1, 0, 0, 0, 250, 1679, 1, 0, 0, 0, 252, 1685, 1, 0, 
	0, 0, 254, 1691, 1, 0, 0, 0, 256, 1693, 1, 0, 0, 0, 258, 1700, 1, 0, 0, 
	0, 260, 1703, 1, 0, 0, 0, 262, 1792, 1, 0, 0, 0, 264, 1795, 1, 0, 0, 0, 
	266, 1799, 1, 0, 0, 0, 268, 1811, 1, 0, 0, 0, 270, 1813, 1, 0, 0, 0, 272, 
	1819, 1, 0, 0, 0, 274, 1878, 1, 0, 0, 0, 276, 1880, 1, 0, 0, 0, 278, 1883, 
	1, 0, 0, 0, 280, 1891, 1, 0, 0, 0, 282, 1951, 1, 0, 0, 0, 284, 1953, 1, 
	0, 0, 0, 286, 1958, 1, 0, 0, 0, 288, 1960, 1, 0, 0, 0, 290, 1965, 1, 0, 
	0, 0, 292, 1973, 1, 0, 0, 0, 294, 1975, 1, 0, 0, 0, 296, 297, 5, 43, 0, 
	0, 297, 298, 3, 292, 146, 0, 298, 299, 5, 27, 0, 0, 299, 300, 3, 292, 146, 
	0, 300, 301, 5, 200, 0, 0, 301, 306, 3, 2, 1, 0, 302, 303, 5, 207, 0, 0, 
	303, 305, 3, 2, 1, 0, 304, 302, 1, 0, 0, 0, 305, 308, 1, 0, 0, 0, 306, 
	304, 1, 0, 0, 0, 306, 307, 1, 0, 0, 0, 307, 309, 1, 0, 0, 0, 308, 306, 
	1, 0, 0, 0, 309, 310, 5, 201, 0, 0, 310, 311, 3, 4, 2, 0, 311, 312, 5, 
	0, 0, 1, 312, 1, 1, 0, 0, 0, 313, 314, 7, 0, 0, 0, 314, 315, 7, 1, 0, 0, 
	315, 3, 1, 0, 0, 0, 316, 320, 5, 202, 0, 0, 317, 319, 3, 6, 3, 0, 318, 
	317, 1, 0, 0, 0, 319, 322, 1, 0, 0, 0, 320, 318, 1, 0, 0, 0, 320, 321, 
	1, 0, 0, 0, 321, 323, 1, 0, 0, 0, 322, 320, 1, 0, 0, 0, 323, 324, 5, 203, 
	0, 0, 324, 5, 1, 0, 0, 0, 325, 327, 3, 28, 14, 0, 326, 325, 1, 0, 0, 0, 
	327, 330, 1, 0, 0, 0, 328, 326, 1, 0, 0, 0, 328, 329, 1, 0, 0, 0, 329, 
	331, 1, 0, 0, 0, 330, 328, 1, 0, 0, 0, 331, 334, 3, 32, 16, 0, 332, 334, 
	3, 84, 42, 0, 333, 328, 1, 0, 0, 0, 333, 332, 1, 0, 0, 0, 334, 7, 1, 0, 
	0, 0, 335, 336, 3, 10, 5, 0, 336, 337, 5, 0, 0, 1, 337, 9, 1, 0, 0, 0, 
	338, 340, 3, 28, 14, 0, 339, 338, 1, 0, 0, 0, 340, 343, 1, 0, 0, 0, 341, 
	339, 1, 0, 0, 0, 341, 342, 1, 0, 0, 0, 342, 344, 1, 0, 0, 0, 343, 341, 
	1, 0, 0, 0, 344, 360, 3, 12, 6, 0, 345, 347, 3, 28, 14, 0, 346, 345, 1, 
	0, 0, 0, 347, 350, 1, 0, 0, 0, 348, 346, 1, 0, 0, 0, 348, 349, 1, 0, 0, 
	0, 349, 351, 1, 0, 0, 0, 350, 348, 1, 0, 0, 0, 351, 360, 3, 14, 7, 0, 352, 
	354, 3, 28, 14, 0, 353, 352, 1, 0, 0, 0, 354, 357, 1, 0, 0, 0, 355, 353, 
	1, 0, 0, 0, 355, 356, 1, 0, 0, 0, 356, 358, 1, 0, 0, 0, 357, 355, 1, 0, 
	0, 0, 358, 360, 3, 18, 9, 0, 359, 341, 1, 0, 0, 0, 359, 348, 1, 0, 0, 0, 
	359, 355, 1, 0, 0, 0, 360, 11, 1, 0, 0, 0, 361, 362, 5, 6, 0, 0, 362, 365, 
	3, 292, 146, 0, 363, 364, 5, 12, 0, 0, 364, 366, 3, 50, 25, 0, 365, 363, 
	1, 0, 0, 0, 365, 366, 1, 0, 0, 0, 366, 369, 1, 0, 0, 0, 367, 368, 5, 19, 
	0, 0, 368, 370, 3, 20, 10, 0, 369, 367, 1, 0, 0, 0, 369, 370, 1, 0, 0, 
	0, 370, 371, 1, 0, 0, 0, 371, 372, 3, 22, 11, 0, 372, 13, 1, 0, 0, 0, 373, 
	374, 5, 11, 0, 0, 374, 375, 3, 292, 146, 0, 375, 377, 5, 202, 0, 0, 376, 
	378, 3, 16, 8, 0, 377, 376, 1, 0, 0, 0, 377, 378, 1, 0, 0, 0, 378, 379, 
	1, 0, 0, 0, 379, 380, 5, 203, 0, 0, 380, 15, 1, 0, 0, 0, 381, 386, 3, 292, 
	146, 0, 382, 383, 5, 207, 0, 0, 383, 385, 3, 292, 146, 0, 384, 382, 1, 
	0, 0, 0, 385, 388, 1, 0, 0, 0, 386, 384, 1, 0, 0, 0, 386, 387, 1, 0, 0, 
	0, 387, 17, 1, 0, 0, 0, 388, 386, 1, 0, 0, 0, 389, 390, 5, 23, 0, 0, 390, 
	393, 3, 292, 146, 0, 391, 392, 5, 12, 0, 0, 392, 394, 3, 20, 10, 0, 393, 
	391, 1, 0, 0, 0, 393, 394, 1, 0, 0, 0, 394, 395, 1, 0, 0, 0, 395, 396, 
	3, 24, 12, 0, 396, 19, 1, 0, 0, 0, 397, 402, 3, 50, 25, 0, 398, 399, 5, 
	207, 0, 0, 399, 401, 3, 50, 25, 0, 400, 398, 1, 0, 0, 0, 401, 404, 1, 0, 
	0, 0, 402, 400, 1, 0, 0, 0, 402, 403, 1, 0, 0, 0, 403, 21, 1, 0, 0, 0, 
	404, 402, 1, 0, 0, 0, 405, 409, 5, 202, 0, 0, 406, 408, 3, 26, 13, 0, 407, 
	406, 1, 0, 0, 0, 408, 411, 1, 0, 0, 0, 409, 407, 1, 0, 0, 0, 409, 410, 
	1, 0, 0, 0, 410, 412, 1, 0, 0, 0, 411, 409, 1, 0, 0, 0, 412, 413, 5, 203, 
	0, 0, 413, 23, 1, 0, 0, 0, 414, 418, 5, 202, 0, 0, 415, 417, 3, 42, 21, 
	0, 416, 415, 1, 0, 0, 0, 417, 420, 1, 0, 0, 0, 418, 416, 1, 0, 0, 0, 418, 
	419, 1, 0, 0, 0, 419, 421, 1, 0, 0, 0, 420, 418, 1, 0, 0, 0, 421, 422, 
	5, 203, 0, 0, 422, 25, 1, 0, 0, 0, 423, 436, 5, 206, 0, 0, 424, 426, 5, 
	36, 0, 0, 425, 424, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426, 427, 1, 0, 0, 
	0, 427, 436, 3, 78, 39, 0, 428, 430, 3, 28, 14, 0, 429, 428, 1, 0, 0, 0, 
	430, 433, 1, 0, 0, 0, 431, 429, 1, 0, 0, 0, 431, 432, 1, 0, 0, 0, 432, 
	434, 1, 0, 0, 0, 433, 431, 1, 0, 0, 0, 434, 436, 3, 30, 15, 0, 435, 423, 
	1, 0, 0, 0, 435, 425, 1, 0, 0, 0, 435, 431, 1, 0, 0, 0, 436, 27, 1, 0, 
	0, 0, 437, 457, 3, 68, 34, 0, 438, 457, 5, 17, 0, 0, 439, 457, 5, 31, 0, 
	0, 440, 457, 5, 30, 0, 0, 441, 457, 5, 29, 0, 0, 442, 457, 5, 42, 0, 0, 
	443, 457, 5, 36, 0, 0, 444, 457, 5, 1, 0, 0, 445, 457, 5, 13, 0, 0, 446, 
	457, 5, 50, 0, 0, 447, 457, 5, 28, 0, 0, 448, 457, 5, 48, 0, 0, 449, 457, 
	5, 39, 0, 0, 450, 451, 5, 53, 0, 0, 451, 457, 5, 35, 0, 0, 452, 453, 5, 
	54, 0, 0, 453, 457, 5, 35, 0, 0, 454, 455, 5, 20, 0, 0, 455, 457, 5, 35, 
	0, 0, 456, 437, 1, 0, 0, 0, 456, 438, 1, 0, 0, 0, 456, 439, 1, 0, 0, 0, 
	456, 440, 1, 0, 0, 0, 456, 441, 1, 0, 0, 0, 456, 442, 1, 0, 0, 0, 456, 
	443, 1, 0, 0, 0, 456, 444, 1, 0, 0, 0, 456, 445, 1, 0, 0, 0, 456, 446, 
	1, 0, 0, 0, 456, 447, 1, 0, 0, 0, 456, 448, 1, 0, 0, 0, 456, 449, 1, 0, 
	0, 0, 456, 450, 1, 0, 0, 0, 456, 452, 1, 0, 0, 0, 456, 454, 1, 0, 0, 0, 
	457, 29, 1, 0, 0, 0, 458, 466, 3, 34, 17, 0, 459, 466, 3, 38, 19, 0, 460, 
	466, 3, 36, 18, 0, 461, 466, 3, 18, 9, 0, 462, 466, 3, 12, 6, 0, 463, 466, 
	3, 14, 7, 0, 464, 466, 3, 40, 20, 0, 465, 458, 1, 0, 0, 0, 465, 459, 1, 
	0, 0, 0, 465, 460, 1, 0, 0, 0, 465, 461, 1, 0, 0, 0, 465, 462, 1, 0, 0, 
	0, 465, 463, 1, 0, 0, 0, 465, 464, 1, 0, 0, 0, 466, 31, 1, 0, 0, 0, 467, 
	474, 3, 34, 17, 0, 468, 474, 3, 38, 19, 0, 469, 474, 3, 18, 9, 0, 470, 
	474, 3, 12, 6, 0, 471, 474, 3, 14, 7, 0, 472, 474, 3, 40, 20, 0, 473, 467, 
	1, 0, 0, 0, 473, 468, 1, 0, 0, 0, 473, 469, 1, 0, 0, 0, 473, 470, 1, 0, 
	0, 0, 473, 471, 1, 0, 0, 0, 473, 472, 1, 0, 0, 0, 474, 33, 1, 0, 0, 0, 
	475, 478, 3, 50, 25, 0, 476, 478, 5, 49, 0, 0, 477, 475, 1, 0, 0, 0, 477, 
	476, 1, 0, 0, 0, 478, 479, 1, 0, 0, 0, 479, 480, 3, 292, 146, 0, 480, 483, 
	3, 58, 29, 0, 481, 484, 3, 78, 39, 0, 482, 484, 5, 206, 0, 0, 483, 481, 
	1, 0, 0, 0, 483, 482, 1, 0, 0, 0, 484, 35, 1, 0, 0, 0, 485, 486, 3, 64, 
	32, 0, 486, 487, 3, 58, 29, 0, 487, 488, 3, 78, 39, 0, 488, 37, 1, 0, 0, 
	0, 489, 490, 3, 50, 25, 0, 490, 491, 3, 44, 22, 0, 491, 492, 5, 206, 0, 
	0, 492, 39, 1, 0, 0, 0, 493, 494, 3, 50, 25, 0, 494, 495, 3, 292, 146, 
	0, 495, 499, 5, 202, 0, 0, 496, 498, 3, 130, 65, 0, 497, 496, 1, 0, 0, 
	0, 498, 501, 1, 0, 0, 0, 499, 497, 1, 0, 0, 0, 499, 500, 1, 0, 0, 0, 500, 
	502, 1, 0, 0, 0, 501, 499, 1, 0, 0, 0, 502, 503, 5, 203, 0, 0, 503, 41, 
	1, 0, 0, 0, 504, 506, 3, 28, 14, 0, 505, 504, 1, 0, 0, 0, 506, 509, 1, 
	0, 0, 0, 507, 505, 1, 0, 0, 0, 507, 508, 1, 0, 0, 0, 508, 512, 1, 0, 0, 
	0, 509, 507, 1, 0, 0, 0, 510, 513, 3, 50, 25, 0, 511, 513, 5, 49, 0, 0, 
	512, 510, 1, 0, 0, 0, 512, 511, 1, 0, 0, 0, 513, 514, 1, 0, 0, 0, 514, 
	515, 3, 292, 146, 0, 515, 516, 3, 58, 29, 0, 516, 517, 5, 206, 0, 0, 517, 
	43, 1, 0, 0, 0, 518, 523, 3, 46, 23, 0, 519, 520, 5, 207, 0, 0, 520, 522, 
	3, 46, 23, 0, 521, 519, 1, 0, 0, 0, 522, 525, 1, 0, 0, 0, 523, 521, 1, 
	0, 0, 0, 523, 524, 1, 0, 0, 0, 524, 45, 1, 0, 0, 0, 525, 523, 1, 0, 0, 
	0, 526, 529, 3, 292, 146, 0, 527, 528, 5, 209, 0, 0, 528, 530, 3, 152, 
	76, 0, 529, 527, 1, 0, 0, 0, 529, 530, 1, 0, 0, 0, 530, 47, 1, 0, 0, 0, 
	531, 543, 5, 202, 0, 0, 532, 537, 3, 152, 76, 0, 533, 534, 5, 207, 0, 0, 
	534, 536, 3, 152, 76, 0, 535, 533, 1, 0, 0, 0, 536, 539, 1, 0, 0, 0, 537, 
	535, 1, 0, 0, 0, 537, 538, 1, 0, 0, 0, 538, 541, 1, 0, 0, 0, 539, 537, 
	1, 0, 0, 0, 540, 542, 5, 207, 0, 0, 541, 540, 1, 0, 0, 0, 541, 542, 1, 
	0, 0, 0, 542, 544, 1, 0, 0, 0, 543, 532, 1, 0, 0, 0, 543, 544, 1, 0, 0, 
	0, 544, 545, 1, 0, 0, 0, 545, 546, 5, 203, 0, 0, 546, 49, 1, 0, 0, 0, 547, 
	552, 3, 54, 27, 0, 548, 549, 5, 208, 0, 0, 549, 551, 3, 54, 27, 0, 550, 
	548, 1, 0, 0, 0, 551, 554, 1, 0, 0, 0, 552, 550, 1, 0, 0, 0, 552, 553, 
	1, 0, 0, 0, 553, 555, 1, 0, 0, 0, 554, 552, 1, 0, 0, 0, 555, 556, 3, 52, 
	26, 0, 556, 51, 1, 0, 0, 0, 557, 558, 5, 204, 0, 0, 558, 560, 5, 205, 0, 
	0, 559, 557, 1, 0, 0, 0, 560, 563, 1, 0, 0, 0, 561, 559, 1, 0, 0, 0, 561, 
	562, 1, 0, 0, 0, 562, 53, 1, 0, 0, 0, 563, 561, 1, 0, 0, 0, 564, 566, 5, 
	55, 0, 0, 565, 567, 3, 56, 28, 0, 566, 565, 1, 0, 0, 0, 566, 567, 1, 0, 
	0, 0, 567, 581, 1, 0, 0, 0, 568, 570, 5, 34, 0, 0, 569, 571, 3, 56, 28, 
	0, 570, 569, 1, 0, 0, 0, 570, 571, 1, 0, 0, 0, 571, 581, 1, 0, 0, 0, 572, 
	574, 5, 56, 0, 0, 573, 575, 3, 56, 28, 0, 574, 573, 1, 0, 0, 0, 574, 575, 
	1, 0, 0, 0, 575, 581, 1, 0, 0, 0, 576, 578, 3, 292, 146, 0, 577, 579, 3, 
	56, 28, 0, 578, 577, 1, 0, 0, 0, 578, 579, 1, 0, 0, 0, 579, 581, 1, 0, 
	0, 0, 580, 564, 1, 0, 0, 0, 580, 568, 1, 0, 0, 0, 580, 572, 1, 0, 0, 0, 
	580, 576, 1, 0, 0, 0, 581, 55, 1, 0, 0, 0, 582, 583, 5, 211, 0, 0, 583, 
	584, 3, 20, 10, 0, 584, 585, 5, 210, 0, 0, 585, 57, 1, 0, 0, 0, 586, 588, 
	5, 200, 0, 0, 587, 589, 3, 60, 30, 0, 588, 587, 1, 0, 0, 0, 588, 589, 1, 
	0, 0, 0, 589, 590, 1, 0, 0, 0, 590, 591, 5, 201, 0, 0, 591, 59, 1, 0, 0, 
	0, 592, 597, 3, 62, 31, 0, 593, 594, 5, 207, 0, 0, 594, 596, 3, 62, 31, 
	0, 595, 593, 1, 0, 0, 0, 596, 599, 1, 0, 0, 0, 597, 595, 1, 0, 0, 0, 597, 
	598, 1, 0, 0, 0, 598, 61, 1, 0, 0, 0, 599, 597, 1, 0, 0, 0, 600, 602, 3, 
	28, 14, 0, 601, 600, 1, 0, 0, 0, 602, 605, 1, 0, 0, 0, 603, 601, 1, 0, 
	0, 0, 603, 604, 1, 0, 0, 0, 604, 606, 1, 0, 0, 0, 605, 603, 1, 0, 0, 0, 
	606, 607, 3, 50, 25, 0, 607, 608, 3, 292, 146, 0, 608, 63, 1, 0, 0, 0, 
	609, 614, 3, 292, 146, 0, 610, 611, 5, 208, 0, 0, 611, 613, 3, 292, 146, 
	0, 612, 610, 1, 0, 0, 0, 613, 616, 1, 0, 0, 0, 614, 612, 1, 0, 0, 0, 614, 
	615, 1, 0, 0, 0, 615, 65, 1, 0, 0, 0, 616, 614, 1, 0, 0, 0, 617, 618, 7, 
	2, 0, 0, 618, 67, 1, 0, 0, 0, 619, 620, 5, 245, 0, 0, 620, 627, 3, 64, 
	32, 0, 621, 624, 5, 200, 0, 0, 622, 625, 3, 70, 35, 0, 623, 625, 3, 74, 
	37, 0, 624, 622, 1, 0, 0, 0, 624, 623, 1, 0, 0, 0, 624, 625, 1, 0, 0, 0, 
	625, 626, 1, 0, 0, 0, 626, 628, 5, 201, 0, 0, 627, 621, 1, 0, 0, 0, 627, 
	628, 1, 0, 0, 0, 628, 69, 1, 0, 0, 0, 629, 636, 3, 72, 36, 0, 630, 632, 
	5, 207, 0, 0, 631, 630, 1, 0, 0, 0, 631, 632, 1, 0, 0, 0, 632, 633, 1, 
	0, 0, 0, 633, 635, 3, 72, 36, 0, 634, 631, 1, 0, 0, 0, 635, 638, 1, 0, 
	0, 0, 636, 634, 1, 0, 0, 0, 636, 637, 1, 0, 0, 0, 637, 71, 1, 0, 0, 0, 
	638, 636, 1, 0, 0, 0, 639, 640, 3, 292, 146, 0, 640, 641, 5, 209, 0, 0, 
	641, 642, 3, 74, 37, 0, 642, 73, 1, 0, 0, 0, 643, 647, 3, 152, 76, 0, 644, 
	647, 3, 68, 34, 0, 645, 647, 3, 76, 38, 0, 646, 643, 1, 0, 0, 0, 646, 644, 
	1, 0, 0, 0, 646, 645, 1, 0, 0, 0, 647, 75, 1, 0, 0, 0, 648, 657, 5, 202, 
	0, 0, 649, 654, 3, 74, 37, 0, 650, 651, 5, 207, 0, 0, 651, 653, 3, 74, 
	37, 0, 652, 650, 1, 0, 0, 0, 653, 656, 1, 0, 0, 0, 654, 652, 1, 0, 0, 0, 
	654, 655, 1, 0, 0, 0, 655, 658, 1, 0, 0, 0, 656, 654, 1, 0, 0, 0, 657, 
	649, 1, 0, 0, 0, 657, 658, 1, 0, 0, 0, 658, 660, 1, 0, 0, 0, 659, 661, 
	5, 207, 0, 0, 660, 659, 1, 0, 0, 0, 660, 661, 1, 0, 0, 0, 661, 662, 1, 
	0, 0, 0, 662, 663, 5, 203, 0, 0, 663, 77, 1, 0, 0, 0, 664, 668, 5, 202, 
	0, 0, 665, 667, 3, 84, 42, 0, 666, 665, 1, 0, 0, 0, 667, 670, 1, 0, 0, 
	0, 668, 666, 1, 0, 0, 0, 668, 669, 1, 0, 0, 0, 669, 671, 1, 0, 0, 0, 670, 
	668, 1, 0, 0, 0, 671, 672, 5, 203, 0, 0, 672, 79, 1, 0, 0, 0, 673, 674, 
	3, 82, 41, 0, 674, 675, 5, 206, 0, 0, 675, 81, 1, 0, 0, 0, 676, 678, 3, 
	28, 14, 0, 677, 676, 1, 0, 0, 0, 678, 681, 1, 0, 0, 0, 679, 677, 1, 0, 
	0, 0, 679, 680, 1, 0, 0, 0, 680, 682, 1, 0, 0, 0, 681, 679, 1, 0, 0, 0, 
	682, 683, 3, 50, 25, 0, 683, 684, 3, 44, 22, 0, 684, 83, 1, 0, 0, 0, 685, 
	706, 3, 78, 39, 0, 686, 706, 3, 86, 43, 0, 687, 706, 3, 88, 44, 0, 688, 
	706, 3, 96, 48, 0, 689, 706, 3, 98, 49, 0, 690, 706, 3, 100, 50, 0, 691, 
	706, 3, 102, 51, 0, 692, 706, 3, 104, 52, 0, 693, 706, 3, 106, 53, 0, 694, 
	706, 3, 108, 54, 0, 695, 706, 3, 110, 55, 0, 696, 706, 3, 114, 57, 0, 697, 
	706, 3, 116, 58, 0, 698, 706, 3, 118, 59, 0, 699, 706, 3, 120, 60, 0, 700, 
	706, 3, 122, 61, 0, 701, 706, 3, 124, 62, 0, 702, 706, 3, 126, 63, 0, 703, 
	706, 3, 80, 40, 0, 704, 706, 3, 128, 64, 0, 705, 685, 1, 0, 0, 0, 705, 
	686, 1, 0, 0, 0, 705, 687, 1, 0, 0, 0, 705, 688, 1, 0, 0, 0, 705, 689, 
	1, 0, 0, 0, 705, 690, 1, 0, 0, 0, 705, 691, 1, 0, 0, 0, 705, 692, 1, 0, 
	0, 0, 705, 693, 1, 0, 0, 0, 705, 694, 1, 0, 0, 0, 705, 695, 1, 0, 0, 0, 
	705, 696, 1, 0, 0, 0, 705, 697, 1, 0, 0, 0, 705, 698, 1, 0, 0, 0, 705, 
	699, 1, 0, 0, 0, 705, 700, 1, 0, 0, 0, 705, 701, 1, 0, 0, 0, 705, 702, 
	1, 0, 0, 0, 705, 703, 1, 0, 0, 0, 705, 704, 1, 0, 0, 0, 706, 85, 1, 0, 
	0, 0, 707, 708, 5, 18, 0, 0, 708, 709, 3, 148, 74, 0, 709, 712, 3, 84, 
	42, 0, 710, 711, 5, 10, 0, 0, 711, 713, 3, 84, 42, 0, 712, 710, 1, 0, 0, 
	0, 712, 713, 1, 0, 0, 0, 713, 87, 1, 0, 0, 0, 714, 715, 5, 38, 0, 0, 715, 
	716, 5, 27, 0, 0, 716, 717, 3, 152, 76, 0, 717, 719, 5, 202, 0, 0, 718, 
	720, 3, 90, 45, 0, 719, 718, 1, 0, 0, 0, 720, 721, 1, 0, 0, 0, 721, 719, 
	1, 0, 0, 0, 721, 722, 1, 0, 0, 0, 722, 723, 1, 0, 0, 0, 723, 724, 5, 203, 
	0, 0, 724, 89, 1, 0, 0, 0, 725, 726, 5, 51, 0, 0, 726, 727, 3, 92, 46, 
	0, 727, 728, 3, 78, 39, 0, 728, 91, 1, 0, 0, 0, 729, 742, 5, 10, 0, 0, 
	730, 735, 3, 94, 47, 0, 731, 732, 5, 207, 0, 0, 732, 734, 3, 94, 47, 0, 
	733, 731, 1, 0, 0, 0, 734, 737, 1, 0, 0, 0, 735, 733, 1, 0, 0, 0, 735, 
	736, 1, 0, 0, 0, 736, 742, 1, 0, 0, 0, 737, 735, 1, 0, 0, 0, 738, 739, 
	3, 292, 146, 0, 739, 740, 3, 292, 146, 0, 740, 742, 1, 0, 0, 0, 741, 729, 
	1, 0, 0, 0, 741, 730, 1, 0, 0, 0, 741, 738, 1, 0, 0, 0, 742, 93, 1, 0, 
	0, 0, 743, 745, 7, 3, 0, 0, 744, 743, 1, 0, 0, 0, 745, 748, 1, 0, 0, 0, 
	746, 744, 1, 0, 0, 0, 746, 747, 1, 0, 0, 0, 747, 749, 1, 0, 0, 0, 748, 
	746, 1, 0, 0, 0, 749, 765, 5, 194, 0, 0, 750, 752, 7, 3, 0, 0, 751, 750, 
	1, 0, 0, 0, 752, 755, 1, 0, 0, 0, 753, 751, 1, 0, 0, 0, 753, 754, 1, 0, 
	0, 0, 754, 756, 1, 0, 0, 0, 755, 753, 1, 0, 0, 0, 756, 765, 5, 195, 0, 
	0, 757, 765, 5, 198, 0, 0, 758, 765, 5, 26, 0, 0, 759, 765, 3, 292, 146, 
	0, 760, 761, 5, 200, 0, 0, 761, 762, 3, 94, 47, 0, 762, 763, 5, 201, 0, 
	0, 763, 765, 1, 0, 0, 0, 764, 746, 1, 0, 0, 0, 764, 753, 1, 0, 0, 0, 764, 
	757, 1, 0, 0, 0, 764, 758, 1, 0, 0, 0, 764, 759, 1, 0, 0, 0, 764, 760, 
	1, 0, 0, 0, 765, 95, 1, 0, 0, 0, 766, 767, 5, 15, 0, 0, 767, 768, 5, 200, 
	0, 0, 768, 769, 3, 140, 70, 0, 769, 772, 5, 201, 0, 0, 770, 773, 3, 84, 
	42, 0, 771, 773, 5, 206, 0, 0, 772, 770, 1, 0, 0, 0, 772, 771, 1, 0, 0, 
	0, 773, 97, 1, 0, 0, 0, 774, 775, 5, 52, 0, 0, 775, 778, 3, 148, 74, 0, 
	776, 779, 3, 84, 42, 0, 777, 779, 5, 206, 0, 0, 778, 776, 1, 0, 0, 0, 778, 
	777, 1, 0, 0, 0, 779, 99, 1, 0, 0, 0, 780, 781, 5, 9, 0, 0, 781, 782, 3, 
	78, 39, 0, 782, 783, 5, 52, 0, 0, 783, 784, 3, 148, 74, 0, 784, 785, 5, 
	206, 0, 0, 785, 101, 1, 0, 0, 0, 786, 787, 5, 44, 0, 0, 787, 797, 3, 78, 
	39, 0, 788, 790, 3, 136, 68, 0, 789, 788, 1, 0, 0, 0, 790, 791, 1, 0, 0, 
	0, 791, 789, 1, 0, 0, 0, 791, 792, 1, 0, 0, 0, 792, 794, 1, 0, 0, 0, 793, 
	795, 3, 138, 69, 0, 794, 793, 1, 0, 0, 0, 794, 795, 1, 0, 0, 0, 795, 798, 
	1, 0, 0, 0, 796, 798, 3, 138, 69, 0, 797, 789, 1, 0, 0, 0, 797, 796, 1, 
	0, 0, 0, 798, 103, 1, 0, 0, 0, 799, 801, 5, 32, 0, 0, 800, 802, 3, 152, 
	76, 0, 801, 800, 1, 0, 0, 0, 801, 802, 1, 0, 0, 0, 802, 803, 1, 0, 0, 0, 
	803, 804, 5, 206, 0, 0, 804, 105, 1, 0, 0, 0, 805, 806, 5, 41, 0, 0, 806, 
	807, 3, 152, 76, 0, 807, 808, 5, 206, 0, 0, 808, 107, 1, 0, 0, 0, 809, 
	810, 5, 4, 0, 0, 810, 811, 5, 206, 0, 0, 811, 109, 1, 0, 0, 0, 812, 813, 
	5, 7, 0, 0, 813, 814, 5, 206, 0, 0, 814, 111, 1, 0, 0, 0, 815, 816, 5, 
	62, 0, 0, 816, 817, 7, 4, 0, 0, 817, 113, 1, 0, 0, 0, 818, 820, 5, 21, 
	0, 0, 819, 821, 3, 112, 56, 0, 820, 819, 1, 0, 0, 0, 820, 821, 1, 0, 0, 
	0, 821, 822, 1, 0, 0, 0, 822, 823, 3, 152, 76, 0, 823, 824, 5, 206, 0, 
	0, 824, 115, 1, 0, 0, 0, 825, 827, 5, 46, 0, 0, 826, 828, 3, 112, 56, 0, 
	827, 826, 1, 0, 0, 0, 827, 828, 1, 0, 0, 0, 828, 829, 1, 0, 0, 0, 829, 
	830, 3, 152, 76, 0, 830, 831, 5, 206, 0, 0, 831, 117, 1, 0, 0, 0, 832, 
	834, 5, 8, 0, 0, 833, 835, 3, 112, 56, 0, 834, 833, 1, 0, 0, 0, 834, 835, 
	1, 0, 0, 0, 835, 836, 1, 0, 0, 0, 836, 837, 3, 152, 76, 0, 837, 838, 5, 
	206, 0, 0, 838, 119, 1, 0, 0, 0, 839, 841, 5, 45, 0, 0, 840, 842, 3, 112, 
	56, 0, 841, 840, 1, 0, 0, 0, 841, 842, 1, 0, 0, 0, 842, 843, 1, 0, 0, 0, 
	843, 844, 3, 152, 76, 0, 844, 845, 5, 206, 0, 0, 845, 121, 1, 0, 0, 0, 
	846, 848, 5, 47, 0, 0, 847, 849, 3, 112, 56, 0, 848, 847, 1, 0, 0, 0, 848, 
	849, 1, 0, 0, 0, 849, 850, 1, 0, 0, 0, 850, 852, 3, 152, 76, 0, 851, 853, 
	3, 64, 32, 0, 852, 851, 1, 0, 0, 0, 852, 853, 1, 0, 0, 0, 853, 854, 1, 
	0, 0, 0, 854, 855, 5, 206, 0, 0, 855, 123, 1, 0, 0, 0, 856, 858, 5, 24, 
	0, 0, 857, 859, 3, 112, 56, 0, 858, 857, 1, 0, 0, 0, 858, 859, 1, 0, 0, 
	0, 859, 860, 1, 0, 0, 0, 860, 861, 3, 152, 76, 0, 861, 862, 3, 152, 76, 
	0, 862, 863, 5, 206, 0, 0, 863, 125, 1, 0, 0, 0, 864, 865, 5, 33, 0, 0, 
	865, 867, 5, 200, 0, 0, 866, 868, 3, 150, 75, 0, 867, 866, 1, 0, 0, 0, 
	867, 868, 1, 0, 0, 0, 868, 869, 1, 0, 0, 0, 869, 870, 5, 201, 0, 0, 870, 
	871, 3, 78, 39, 0, 871, 127, 1, 0, 0, 0, 872, 873, 3, 152, 76, 0, 873, 
	874, 5, 206, 0, 0, 874, 129, 1, 0, 0, 0, 875, 877, 3, 28, 14, 0, 876, 875, 
	1, 0, 0, 0, 877, 880, 1, 0, 0, 0, 878, 876, 1, 0, 0, 0, 878, 879, 1, 0, 
	0, 0, 879, 883, 1, 0, 0, 0, 880, 878, 1, 0, 0, 0, 881, 884, 3, 132, 66, 
	0, 882, 884, 3, 134, 67, 0, 883, 881, 1, 0, 0, 0, 883, 882, 1, 0, 0, 0, 
	884, 131, 1, 0, 0, 0, 885, 888, 5, 16, 0, 0, 886, 889, 5, 206, 0, 0, 887, 
	889, 3, 78, 39, 0, 888, 886, 1, 0, 0, 0, 888, 887, 1, 0, 0, 0, 889, 133, 
	1, 0, 0, 0, 890, 893, 5, 34, 0, 0, 891, 894, 5, 206, 0, 0, 892, 894, 3, 
	78, 39, 0, 893, 891, 1, 0, 0, 0, 893, 892, 1, 0, 0, 0, 894, 135, 1, 0, 
	0, 0, 895, 896, 5, 5, 0, 0, 896, 900, 5, 200, 0, 0, 897, 899, 3, 28, 14, 
	0, 898, 897, 1, 0, 0, 0, 899, 902, 1, 0, 0, 0, 900, 898, 1, 0, 0, 0, 900, 
	901, 1, 0, 0, 0, 901, 903, 1, 0, 0, 0, 902, 900, 1, 0, 0, 0, 903, 904, 
	3, 64, 32, 0, 904, 905, 3, 292, 146, 0, 905, 906, 5, 201, 0, 0, 906, 907, 
	3, 78, 39, 0, 907, 137, 1, 0, 0, 0, 908, 909, 5, 14, 0, 0, 909, 910, 3, 
	78, 39, 0, 910, 139, 1, 0, 0, 0, 911, 924, 3, 144, 72, 0, 912, 914, 3, 
	142, 71, 0, 913, 912, 1, 0, 0, 0, 913, 914, 1, 0, 0, 0, 914, 915, 1, 0, 
	0, 0, 915, 917, 5, 206, 0, 0, 916, 918, 3, 152, 76, 0, 917, 916, 1, 0, 
	0, 0, 917, 918, 1, 0, 0, 0, 918, 919, 1, 0, 0, 0, 919, 921, 5, 206, 0, 
	0, 920, 922, 3, 146, 73, 0, 921, 920, 1, 0, 0, 0, 921, 922, 1, 0, 0, 0, 
	922, 924, 1, 0, 0, 0, 923, 911, 1, 0, 0, 0, 923, 913, 1, 0, 0, 0, 924, 
	141, 1, 0, 0, 0, 925, 928, 3, 82, 41, 0, 926, 928, 3, 150, 75, 0, 927, 
	925, 1, 0, 0, 0, 927, 926, 1, 0, 0, 0, 928, 143, 1, 0, 0, 0, 929, 930, 
	3, 50, 25, 0, 930, 931, 3, 292, 146, 0, 931, 932, 5, 216, 0, 0, 932, 933, 
	3, 152, 76, 0, 933, 145, 1, 0, 0, 0, 934, 935, 3, 150, 75, 0, 935, 147, 
	1, 0, 0, 0, 936, 937, 5, 200, 0, 0, 937, 938, 3, 152, 76, 0, 938, 939, 
	5, 201, 0, 0, 939, 149, 1, 0, 0, 0, 940, 945, 3, 152, 76, 0, 941, 942, 
	5, 207, 0, 0, 942, 944, 3, 152, 76, 0, 943, 941, 1, 0, 0, 0, 944, 947, 
	1, 0, 0, 0, 945, 943, 1, 0, 0, 0, 945, 946, 1, 0, 0, 0, 946, 151, 1, 0, 
	0, 0, 947, 945, 1, 0, 0, 0, 948, 949, 6, 76, -1, 0, 949, 967, 3, 154, 77, 
	0, 950, 967, 3, 156, 78, 0, 951, 952, 5, 25, 0, 0, 952, 967, 3, 160, 80, 
	0, 953, 954, 5, 200, 0, 0, 954, 955, 3, 50, 25, 0, 955, 956, 5, 201, 0, 
	0, 956, 957, 3, 152, 76, 19, 957, 967, 1, 0, 0, 0, 958, 959, 5, 200, 0, 
	0, 959, 960, 3, 152, 76, 0, 960, 961, 5, 201, 0, 0, 961, 967, 1, 0, 0, 
	0, 962, 963, 7, 5, 0, 0, 963, 967, 3, 152, 76, 16, 964, 965, 7, 6, 0, 0, 
	965, 967, 3, 152, 76, 15, 966, 948, 1, 0, 0, 0, 966, 950, 1, 0, 0, 0, 966, 
	951, 1, 0, 0, 0, 966, 953, 1, 0, 0, 0, 966, 958, 1, 0, 0, 0, 966, 962, 
	1, 0, 0, 0, 966, 964, 1, 0, 0, 0, 967, 1039, 1, 0, 0, 0, 968, 969, 10, 
	14, 0, 0, 969, 970, 7, 7, 0, 0, 970, 1038, 3, 152, 76, 15, 971, 972, 10, 
	13, 0, 0, 972, 973, 7, 3, 0, 0, 973, 1038, 3, 152, 76, 14, 974, 982, 10, 
	12, 0, 0, 975, 976, 5, 211, 0, 0, 976, 983, 5, 211, 0, 0, 977, 978, 5, 
	210, 0, 0, 978, 979, 5, 210, 0, 0, 979, 983, 5, 210, 0, 0, 980, 981, 5, 
	210, 0, 0, 981, 983, 5, 210, 0, 0, 982, 975, 1, 0, 0, 0, 982, 977, 1, 0, 
	0, 0, 982, 980, 1, 0, 0, 0, 983, 984, 1, 0, 0, 0, 984, 1038, 3, 152, 76, 
	13, 985, 986, 10, 11, 0, 0, 986, 988, 7, 8, 0, 0, 987, 989, 5, 209, 0, 
	0, 988, 987, 1, 0, 0, 0, 988, 989, 1, 0, 0, 0, 989, 990, 1, 0, 0, 0, 990, 
	1038, 3, 152, 76, 12, 991, 992, 10, 9, 0, 0, 992, 993, 7, 9, 0, 0, 993, 
	1038, 3, 152, 76, 10, 994, 995, 10, 8, 0, 0, 995, 996, 5, 231, 0, 0, 996, 
	1038, 3, 152, 76, 9, 997, 998, 10, 7, 0, 0, 998, 999, 5, 233, 0, 0, 999, 
	1038, 3, 152, 76, 8, 1000, 1001, 10, 6, 0, 0, 1001, 1002, 5, 232, 0, 0, 
	1002, 1038, 3, 152, 76, 7, 1003, 1004, 10, 5, 0, 0, 1004, 1005, 5, 222, 
	0, 0, 1005, 1038, 3, 152, 76, 6, 1006, 1007, 10, 4, 0, 0, 1007, 1008, 5, 
	223, 0, 0, 1008, 1038, 3, 152, 76, 5, 1009, 1010, 10, 3, 0, 0, 1010, 1011, 
	5, 224, 0, 0, 1011, 1038, 3, 152, 76, 4, 1012, 1013, 10, 2, 0, 0, 1013, 
	1014, 5, 215, 0, 0, 1014, 1015, 3, 152, 76, 0, 1015, 1016, 5, 216, 0, 0, 
	1016, 1017, 3, 152, 76, 2, 1017, 1038, 1, 0, 0, 0, 1018, 1019, 10, 1, 0, 
	0, 1019, 1020, 7, 10, 0, 0, 1020, 1038, 3, 152, 76, 1, 1021, 1022, 10, 
	23, 0, 0, 1022, 1025, 7, 11, 0, 0, 1023, 1026, 3, 158, 79, 0, 1024, 1026, 
	3, 294, 147, 0, 1025, 1023, 1, 0, 0, 0, 1025, 1024, 1, 0, 0, 0, 1026, 1038, 
	1, 0, 0, 0, 1027, 1028, 10, 22, 0, 0, 1028, 1029, 5, 204, 0, 0, 1029, 1030, 
	3, 152, 76, 0, 1030, 1031, 5, 205, 0, 0, 1031, 1038, 1, 0, 0, 0, 1032, 
	1033, 10, 17, 0, 0, 1033, 1038, 7, 12, 0, 0, 1034, 1035, 10, 10, 0, 0, 
	1035, 1036, 5, 22, 0, 0, 1036, 1038, 3, 50, 25, 0, 1037, 968, 1, 0, 0, 
	0, 1037, 971, 1, 0, 0, 0, 1037, 974, 1, 0, 0, 0, 1037, 985, 1, 0, 0, 0, 
	1037, 991, 1, 0, 0, 0, 1037, 994, 1, 0, 0, 0, 1037, 997, 1, 0, 0, 0, 1037, 
	1000, 1, 0, 0, 0, 1037, 1003, 1, 0, 0, 0, 1037, 1006, 1, 0, 0, 0, 1037, 
	1009, 1, 0, 0, 0, 1037, 1012, 1, 0, 0, 0, 1037, 1018, 1, 0, 0, 0, 1037, 
	1021, 1, 0, 0, 0, 1037, 1027, 1, 0, 0, 0, 1037, 1032, 1, 0, 0, 0, 1037, 
	1034, 1, 0, 0, 0, 1038, 1041, 1, 0, 0, 0, 1039, 1037, 1, 0, 0, 0, 1039, 
	1040, 1, 0, 0, 0, 1040, 153, 1, 0, 0, 0, 1041, 1039, 1, 0, 0, 0, 1042, 
	1056, 5, 40, 0, 0, 1043, 1056, 5, 37, 0, 0, 1044, 1056, 3, 66, 33, 0, 1045, 
	1046, 3, 50, 25, 0, 1046, 1047, 5, 208, 0, 0, 1047, 1048, 5, 6, 0, 0, 1048, 
	1056, 1, 0, 0, 0, 1049, 1050, 5, 49, 0, 0, 1050, 1051, 5, 208, 0, 0, 1051, 
	1056, 5, 6, 0, 0, 1052, 1056, 3, 292, 146, 0, 1053, 1056, 3, 180, 90, 0, 
	1054, 1056, 3, 268, 134, 0, 1055, 1042, 1, 0, 0, 0, 1055, 1043, 1, 0, 0, 
	0, 1055, 1044, 1, 0, 0, 0, 1055, 1045, 1, 0, 0, 0, 1055, 1049, 1, 0, 0, 
	0, 1055, 1052, 1, 0, 0, 0, 1055, 1053, 1, 0, 0, 0, 1055, 1054, 1, 0, 0, 
	0, 1056, 155, 1, 0, 0, 0, 1057, 1058, 3, 292, 146, 0, 1058, 1060, 5, 200, 
	0, 0, 1059, 1061, 3, 150, 75, 0, 1060, 1059, 1, 0, 0, 0, 1060, 1061, 1, 
	0, 0, 0, 1061, 1062, 1, 0, 0, 0, 1062, 1063, 5, 201, 0, 0, 1063, 1077, 
	1, 0, 0, 0, 1064, 1065, 5, 40, 0, 0, 1065, 1067, 5, 200, 0, 0, 1066, 1068, 
	3, 150, 75, 0, 1067, 1066, 1, 0, 0, 0, 1067, 1068, 1, 0, 0, 0, 1068, 1069, 
	1, 0, 0, 0, 1069, 1077, 5, 201, 0, 0, 1070, 1071, 5, 37, 0, 0, 1071, 1073, 
	5, 200, 0, 0, 1072, 1074, 3, 150, 75, 0, 1073, 1072, 1, 0, 0, 0, 1073, 
	1074, 1, 0, 0, 0, 1074, 1075, 1, 0, 0, 0, 1075, 1077, 5, 201, 0, 0, 1076, 
	1057, 1, 0, 0, 0, 1076, 1064, 1, 0, 0, 0, 1076, 1070, 1, 0, 0, 0, 1077, 
	157, 1, 0, 0, 0, 1078, 1079, 3, 294, 147, 0, 1079, 1081, 5, 200, 0, 0, 
	1080, 1082, 3, 150, 75, 0, 1081, 1080, 1, 0, 0, 0, 1081, 1082, 1, 0, 0, 
	0, 1082, 1083, 1, 0, 0, 0, 1083, 1084, 5, 201, 0, 0, 1084, 159, 1, 0, 0, 
	0, 1085, 1091, 3, 162, 81, 0, 1086, 1092, 3, 166, 83, 0, 1087, 1092, 3, 
	168, 84, 0, 1088, 1092, 3, 170, 85, 0, 1089, 1092, 3, 172, 86, 0, 1090, 
	1092, 3, 176, 88, 0, 1091, 1086, 1, 0, 0, 0, 1091, 1087, 1, 0, 0, 0, 1091, 
	1088, 1, 0, 0, 0, 1091, 1089, 1, 0, 0, 0, 1091, 1090, 1, 0, 0, 0, 1092, 
	161, 1, 0, 0, 0, 1093, 1098, 3, 164, 82, 0, 1094, 1095, 5, 208, 0, 0, 1095, 
	1097, 3, 164, 82, 0, 1096, 1094, 1, 0, 0, 0, 1097, 1100, 1, 0, 0, 0, 1098, 
	1096, 1, 0, 0, 0, 1098, 1099, 1, 0, 0, 0, 1099, 163, 1, 0, 0, 0, 1100, 
	1098, 1, 0, 0, 0, 1101, 1106, 3, 294, 147, 0, 1102, 1103, 5, 211, 0, 0, 
	1103, 1104, 3, 20, 10, 0, 1104, 1105, 5, 210, 0, 0, 1105, 1107, 1, 0, 0, 
	0, 1106, 1102, 1, 0, 0, 0, 1106, 1107, 1, 0, 0, 0, 1107, 165, 1, 0, 0, 
	0, 1108, 1109, 5, 202, 0, 0, 1109, 1110, 5, 203, 0, 0, 1110, 167, 1, 0, 
	0, 0, 1111, 1112, 3, 178, 89, 0, 1112, 169, 1, 0, 0, 0, 1113, 1114, 5, 
	204, 0, 0, 1114, 1115, 3, 152, 76, 0, 1115, 1116, 5, 205, 0, 0, 1116, 1123, 
	1, 0, 0, 0, 1117, 1118, 5, 204, 0, 0, 1118, 1120, 5, 205, 0, 0, 1119, 1121, 
	3, 48, 24, 0, 1120, 1119, 1, 0, 0, 0, 1120, 1121, 1, 0, 0, 0, 1121, 1123, 
	1, 0, 0, 0, 1122, 1113, 1, 0, 0, 0, 1122, 1117, 1, 0, 0, 0, 1123, 171, 
	1, 0, 0, 0, 1124, 1125, 5, 202, 0, 0, 1125, 1130, 3, 174, 87, 0, 1126, 
	1127, 5, 207, 0, 0, 1127, 1129, 3, 174, 87, 0, 1128, 1126, 1, 0, 0, 0, 
	1129, 1132, 1, 0, 0, 0, 1130, 1128, 1, 0, 0, 0, 1130, 1131, 1, 0, 0, 0, 
	1131, 1133, 1, 0, 0, 0, 1132, 1130, 1, 0, 0, 0, 1133, 1134, 5, 203, 0, 
	0, 1134, 173, 1, 0, 0, 0, 1135, 1136, 3, 152, 76, 0, 1136, 1137, 5, 234, 
	0, 0, 1137, 1138, 3, 152, 76, 0, 1138, 175, 1, 0, 0, 0, 1139, 1140, 5, 
	202, 0, 0, 1140, 1145, 3, 152, 76, 0, 1141, 1142, 5, 207, 0, 0, 1142, 1144, 
	3, 152, 76, 0, 1143, 1141, 1, 0, 0, 0, 1144, 1147, 1, 0, 0, 0, 1145, 1143, 
	1, 0, 0, 0, 1145, 1146, 1, 0, 0, 0, 1146, 1148, 1, 0, 0, 0, 1147, 1145, 
	1, 0, 0, 0, 1148, 1149, 5, 203, 0, 0, 1149, 177, 1, 0, 0, 0, 1150, 1152, 
	5, 200, 0, 0, 1151, 1153, 3, 150, 75, 0, 1152, 1151, 1, 0, 0, 0, 1152, 
	1153, 1, 0, 0, 0, 1153, 1154, 1, 0, 0, 0, 1154, 1155, 5, 201, 0, 0, 1155, 
	179, 1, 0, 0, 0, 1156, 1157, 5, 204, 0, 0, 1157, 1158, 3, 182, 91, 0, 1158, 
	1159, 5, 205, 0, 0, 1159, 181, 1, 0, 0, 0, 1160, 1161, 5, 59, 0, 0, 1161, 
	1162, 3, 186, 93, 0, 1162, 1163, 5, 61, 0, 0, 1163, 1165, 3, 192, 96, 0, 
	1164, 1166, 3, 216, 108, 0, 1165, 1164, 1, 0, 0, 0, 1165, 1166, 1, 0, 0, 
	0, 1166, 1168, 1, 0, 0, 0, 1167, 1169, 3, 218, 109, 0, 1168, 1167, 1, 0, 
	0, 0, 1168, 1169, 1, 0, 0, 0, 1169, 1171, 1, 0, 0, 0, 1170, 1172, 3, 234, 
	117, 0, 1171, 1170, 1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0, 1172, 1174, 1, 
	0, 0, 0, 1173, 1175, 3, 244, 122, 0, 1174, 1173, 1, 0, 0, 0, 1174, 1175, 
	1, 0, 0, 0, 1175, 1177, 1, 0, 0, 0, 1176, 1178, 3, 246, 123, 0, 1177, 1176, 
	1, 0, 0, 0, 1177, 1178, 1, 0, 0, 0, 1178, 1180, 1, 0, 0, 0, 1179, 1181, 
	3, 252, 126, 0, 1180, 1179, 1, 0, 0, 0, 1180, 1181, 1, 0, 0, 0, 1181, 1183, 
	1, 0, 0, 0, 1182, 1184, 3, 254, 127, 0, 1183, 1182, 1, 0, 0, 0, 1183, 1184, 
	1, 0, 0, 0, 1184, 1186, 1, 0, 0, 0, 1185, 1187, 3, 256, 128, 0, 1186, 1185, 
	1, 0, 0, 0, 1186, 1187, 1, 0, 0, 0, 1187, 1188, 1, 0, 0, 0, 1188, 1191, 
	3, 258, 129, 0, 1189, 1190, 5, 46, 0, 0, 1190, 1192, 3, 284, 142, 0, 1191, 
	1189, 1, 0, 0, 0, 1191, 1192, 1, 0, 0, 0, 1192, 183, 1, 0, 0, 0, 1193, 
	1194, 5, 59, 0, 0, 1194, 1195, 3, 194, 97, 0, 1195, 1196, 5, 61, 0, 0, 
	1196, 1198, 3, 192, 96, 0, 1197, 1199, 3, 218, 109, 0, 1198, 1197, 1, 0, 
	0, 0, 1198, 1199, 1, 0, 0, 0, 1199, 1201, 1, 0, 0, 0, 1200, 1202, 3, 246, 
	123, 0, 1201, 1200, 1, 0, 0, 0, 1201, 1202, 1, 0, 0, 0, 1202, 1204, 1, 
	0, 0, 0, 1203, 1205, 3, 252, 126, 0, 1204, 1203, 1, 0, 0, 0, 1204, 1205, 
	1, 0, 0, 0, 1205, 1206, 1, 0, 0, 0, 1206, 1209, 3, 258, 129, 0, 1207, 1208, 
	5, 46, 0, 0, 1208, 1210, 3, 284, 142, 0, 1209, 1207, 1, 0, 0, 0, 1209, 
	1210, 1, 0, 0, 0, 1210, 185, 1, 0, 0, 0, 1211, 1216, 3, 188, 94, 0, 1212, 
	1213, 5, 207, 0, 0, 1213, 1215, 3, 188, 94, 0, 1214, 1212, 1, 0, 0, 0, 
	1215, 1218, 1, 0, 0, 0, 1216, 1214, 1, 0, 0, 0, 1216, 1217, 1, 0, 0, 0, 
	1217, 187, 1, 0, 0, 0, 1218, 1216, 1, 0, 0, 0, 1219, 1221, 3, 190, 95, 
	0, 1220, 1222, 3, 266, 133, 0, 1221, 1220, 1, 0, 0, 0, 1221, 1222, 1, 0, 
	0, 0, 1222, 1235, 1, 0, 0, 0, 1223, 1225, 3, 200, 100, 0, 1224, 1226, 3, 
	266, 133, 0, 1225, 1224, 1, 0, 0, 0, 1225, 1226, 1, 0, 0, 0, 1226, 1235, 
	1, 0, 0, 0, 1227, 1228, 5, 200, 0, 0, 1228, 1229, 3, 184, 92, 0, 1229, 
	1231, 5, 201, 0, 0, 1230, 1232, 3, 266, 133, 0, 1231, 1230, 1, 0, 0, 0, 
	1231, 1232, 1, 0, 0, 0, 1232, 1235, 1, 0, 0, 0, 1233, 1235, 3, 208, 104, 
	0, 1234, 1219, 1, 0, 0, 0, 1234, 1223, 1, 0, 0, 0, 1234, 1227, 1, 0, 0, 
	0, 1234, 1233, 1, 0, 0, 0, 1235, 189, 1, 0, 0, 0, 1236, 1241, 3, 266, 133, 
	0, 1237, 1238, 5, 208, 0, 0, 1238, 1240, 3, 266, 133, 0, 1239, 1237, 1, 
	0, 0, 0, 1240, 1243, 1, 0, 0, 0, 1241, 1239, 1, 0, 0, 0, 1241, 1242, 1, 
	0, 0, 0, 1242, 191, 1, 0, 0, 0, 1243, 1241, 1, 0, 0, 0, 1244, 1246, 3, 
	190, 95, 0, 1245, 1247, 3, 266, 133, 0, 1246, 1245, 1, 0, 0, 0, 1246, 1247, 
	1, 0, 0, 0, 1247, 1255, 1, 0, 0, 0, 1248, 1249, 5, 207, 0, 0, 1249, 1251, 
	3, 190, 95, 0, 1250, 1252, 3, 266, 133, 0, 1251, 1250, 1, 0, 0, 0, 1251, 
	1252, 1, 0, 0, 0, 1252, 1254, 1, 0, 0, 0, 1253, 1248, 1, 0, 0, 0, 1254, 
	1257, 1, 0, 0, 0, 1255, 1253, 1, 0, 0, 0, 1255, 1256, 1, 0, 0, 0, 1256, 
	193, 1, 0, 0, 0, 1257, 1255, 1, 0, 0, 0, 1258, 1263, 3, 196, 98, 0, 1259, 
	1260, 5, 207, 0, 0, 1260, 1262, 3, 196, 98, 0, 1261, 1259, 1, 0, 0, 0, 
	1262, 1265, 1, 0, 0, 0, 1263, 1261, 1, 0, 0, 0, 1263, 1264, 1, 0, 0, 0, 
	1264, 195, 1, 0, 0, 0, 1265, 1263, 1, 0, 0, 0, 1266, 1268, 3, 190, 95, 
	0, 1267, 1269, 3, 266, 133, 0, 1268, 1267, 1, 0, 0, 0, 1268, 1269, 1, 0, 
	0, 0, 1269, 1282, 1, 0, 0, 0, 1270, 1272, 3, 200, 100, 0, 1271, 1273, 3, 
	266, 133, 0, 1272, 1271, 1, 0, 0, 0, 1272, 1273, 1, 0, 0, 0, 1273, 1282, 
	1, 0, 0, 0, 1274, 1275, 5, 200, 0, 0, 1275, 1276, 3, 184, 92, 0, 1276, 
	1278, 5, 201, 0, 0, 1277, 1279, 3, 266, 133, 0, 1278, 1277, 1, 0, 0, 0, 
	1278, 1279, 1, 0, 0, 0, 1279, 1282, 1, 0, 0, 0, 1280, 1282, 3, 208, 104, 
	0, 1281, 1266, 1, 0, 0, 0, 1281, 1270, 1, 0, 0, 0, 1281, 1274, 1, 0, 0, 
	0, 1281, 1280, 1, 0, 0, 0, 1282, 197, 1, 0, 0, 0, 1283, 1284, 7, 13, 0, 
	0, 1284, 199, 1, 0, 0, 0, 1285, 1286, 5, 72, 0, 0, 1286, 1287, 5, 200, 
	0, 0, 1287, 1288, 3, 190, 95, 0, 1288, 1289, 5, 201, 0, 0, 1289, 1421, 
	1, 0, 0, 0, 1290, 1291, 5, 60, 0, 0, 1291, 1292, 5, 200, 0, 0, 1292, 1421, 
	5, 201, 0, 0, 1293, 1294, 5, 60, 0, 0, 1294, 1295, 5, 200, 0, 0, 1295, 
	1296, 3, 190, 95, 0, 1296, 1297, 5, 201, 0, 0, 1297, 1421, 1, 0, 0, 0, 
	1298, 1299, 5, 73, 0, 0, 1299, 1300, 5, 200, 0, 0, 1300, 1301, 3, 190, 
	95, 0, 1301, 1302, 5, 201, 0, 0, 1302, 1421, 1, 0, 0, 0, 1303, 1304, 5, 
	74, 0, 0, 1304, 1305, 5, 200, 0, 0, 1305, 1306, 3, 190, 95, 0, 1306, 1307, 
	5, 201, 0, 0, 1307, 1421, 1, 0, 0, 0, 1308, 1309, 5, 75, 0, 0, 1309, 1310, 
	5, 200, 0, 0, 1310, 1311, 3, 190, 95, 0, 1311, 1312, 5, 201, 0, 0, 1312, 
	1421, 1, 0, 0, 0, 1313, 1314, 5, 76, 0, 0, 1314, 1315, 5, 200, 0, 0, 1315, 
	1316, 3, 190, 95, 0, 1316, 1317, 5, 201, 0, 0, 1317, 1421, 1, 0, 0, 0, 
	1318, 1319, 5, 95, 0, 0, 1319, 1320, 5, 200, 0, 0, 1320, 1321, 3, 190, 
	95, 0, 1321, 1322, 5, 201, 0, 0, 1322, 1421, 1, 0, 0, 0, 1323, 1324, 5, 
	108, 0, 0, 1324, 1327, 5, 200, 0, 0, 1325, 1328, 3, 190, 95, 0, 1326, 1328, 
	3, 200, 100, 0, 1327, 1325, 1, 0, 0, 0, 1327, 1326, 1, 0, 0, 0, 1328, 1329, 
	1, 0, 0, 0, 1329, 1330, 5, 201, 0, 0, 1330, 1421, 1, 0, 0, 0, 1331, 1332, 
	5, 117, 0, 0, 1332, 1333, 5, 200, 0, 0, 1333, 1334, 3, 202, 101, 0, 1334, 
	1335, 5, 201, 0, 0, 1335, 1421, 1, 0, 0, 0, 1336, 1337, 5, 118, 0, 0, 1337, 
	1338, 5, 200, 0, 0, 1338, 1339, 3, 202, 101, 0, 1339, 1340, 5, 201, 0, 
	0, 1340, 1421, 1, 0, 0, 0, 1341, 1342, 5, 119, 0, 0, 1342, 1343, 5, 200, 
	0, 0, 1343, 1344, 3, 202, 101, 0, 1344, 1345, 5, 201, 0, 0, 1345, 1421, 
	1, 0, 0, 0, 1346, 1347, 5, 120, 0, 0, 1347, 1348, 5, 200, 0, 0, 1348, 1349, 
	3, 202, 101, 0, 1349, 1350, 5, 201, 0, 0, 1350, 1421, 1, 0, 0, 0, 1351, 
	1352, 5, 121, 0, 0, 1352, 1353, 5, 200, 0, 0, 1353, 1354, 3, 202, 101, 
	0, 1354, 1355, 5, 201, 0, 0, 1355, 1421, 1, 0, 0, 0, 1356, 1357, 5, 122, 
	0, 0, 1357, 1358, 5, 200, 0, 0, 1358, 1359, 3, 202, 101, 0, 1359, 1360, 
	5, 201, 0, 0, 1360, 1421, 1, 0, 0, 0, 1361, 1362, 5, 123, 0, 0, 1362, 1363, 
	5, 200, 0, 0, 1363, 1364, 3, 202, 101, 0, 1364, 1365, 5, 201, 0, 0, 1365, 
	1421, 1, 0, 0, 0, 1366, 1367, 5, 124, 0, 0, 1367, 1368, 5, 200, 0, 0, 1368, 
	1369, 3, 202, 101, 0, 1369, 1370, 5, 201, 0, 0, 1370, 1421, 1, 0, 0, 0, 
	1371, 1372, 5, 125, 0, 0, 1372, 1373, 5, 200, 0, 0, 1373, 1374, 3, 202, 
	101, 0, 1374, 1375, 5, 201, 0, 0, 1375, 1421, 1, 0, 0, 0, 1376, 1377, 5, 
	126, 0, 0, 1377, 1378, 5, 200, 0, 0, 1378, 1379, 3, 202, 101, 0, 1379, 
	1380, 5, 201, 0, 0, 1380, 1421, 1, 0, 0, 0, 1381, 1382, 5, 127, 0, 0, 1382, 
	1383, 5, 200, 0, 0, 1383, 1384, 3, 202, 101, 0, 1384, 1385, 5, 201, 0, 
	0, 1385, 1421, 1, 0, 0, 0, 1386, 1387, 5, 128, 0, 0, 1387, 1388, 5, 200, 
	0, 0, 1388, 1389, 3, 202, 101, 0, 1389, 1390, 5, 201, 0, 0, 1390, 1421, 
	1, 0, 0, 0, 1391, 1392, 5, 129, 0, 0, 1392, 1393, 5, 200, 0, 0, 1393, 1394, 
	3, 202, 101, 0, 1394, 1395, 5, 201, 0, 0, 1395, 1421, 1, 0, 0, 0, 1396, 
	1397, 5, 183, 0, 0, 1397, 1398, 5, 200, 0, 0, 1398, 1399, 3, 198, 99, 0, 
	1399, 1400, 5, 201, 0, 0, 1400, 1421, 1, 0, 0, 0, 1401, 1402, 5, 113, 0, 
	0, 1402, 1403, 5, 200, 0, 0, 1403, 1404, 3, 204, 102, 0, 1404, 1405, 5, 
	207, 0, 0, 1405, 1406, 3, 204, 102, 0, 1406, 1407, 5, 207, 0, 0, 1407, 
	1408, 5, 198, 0, 0, 1408, 1409, 5, 201, 0, 0, 1409, 1421, 1, 0, 0, 0, 1410, 
	1411, 5, 115, 0, 0, 1411, 1412, 5, 200, 0, 0, 1412, 1413, 3, 190, 95, 0, 
	1413, 1414, 5, 201, 0, 0, 1414, 1421, 1, 0, 0, 0, 1415, 1416, 5, 116, 0, 
	0, 1416, 1417, 5, 200, 0, 0, 1417, 1418, 3, 190, 95, 0, 1418, 1419, 5, 
	201, 0, 0, 1419, 1421, 1, 0, 0, 0, 1420, 1285, 1, 0, 0, 0, 1420, 1290, 
	1, 0, 0, 0, 1420, 1293, 1, 0, 0, 0, 1420, 1298, 1, 0, 0, 0, 1420, 1303, 
	1, 0, 0, 0, 1420, 1308, 1, 0, 0, 0, 1420, 1313, 1, 0, 0, 0, 1420, 1318, 
	1, 0, 0, 0, 1420, 1323, 1, 0, 0, 0, 1420, 1331, 1, 0, 0, 0, 1420, 1336, 
	1, 0, 0, 0, 1420, 1341, 1, 0, 0, 0, 1420, 1346, 1, 0, 0, 0, 1420, 1351, 
	1, 0, 0, 0, 1420, 1356, 1, 0, 0, 0, 1420, 1361, 1, 0, 0, 0, 1420, 1366, 
	1, 0, 0, 0, 1420, 1371, 1, 0, 0, 0, 1420, 1376, 1, 0, 0, 0, 1420, 1381, 
	1, 0, 0, 0, 1420, 1386, 1, 0, 0, 0, 1420, 1391, 1, 0, 0, 0, 1420, 1396, 
	1, 0, 0, 0, 1420, 1401, 1, 0, 0, 0, 1420, 1410, 1, 0, 0, 0, 1420, 1415, 
	1, 0, 0, 0, 1421, 201, 1, 0, 0, 0, 1422, 1423, 5, 130, 0, 0, 1423, 1424, 
	5, 200, 0, 0, 1424, 1425, 3, 190, 95, 0, 1425, 1426, 5, 201, 0, 0, 1426, 
	1429, 1, 0, 0, 0, 1427, 1429, 3, 190, 95, 0, 1428, 1422, 1, 0, 0, 0, 1428, 
	1427, 1, 0, 0, 0, 1429, 203, 1, 0, 0, 0, 1430, 1440, 3, 190, 95, 0, 1431, 
	1440, 3, 260, 130, 0, 1432, 1433, 5, 114, 0, 0, 1433, 1434, 5, 200, 0, 
	0, 1434, 1435, 3, 206, 103, 0, 1435, 1436, 5, 207, 0, 0, 1436, 1437, 3, 
	206, 103, 0, 1437, 1438, 5, 201, 0, 0, 1438, 1440, 1, 0, 0, 0, 1439, 1430, 
	1, 0, 0, 0, 1439, 1431, 1, 0, 0, 0, 1439, 1432, 1, 0, 0, 0, 1440, 205, 
	1, 0, 0, 0, 1441, 1444, 3, 232, 116, 0, 1442, 1444, 3, 260, 130, 0, 1443, 
	1441, 1, 0, 0, 0, 1443, 1442, 1, 0, 0, 0, 1444, 207, 1, 0, 0, 0, 1445, 
	1446, 5, 77, 0, 0, 1446, 1448, 3, 190, 95, 0, 1447, 1449, 3, 210, 105, 
	0, 1448, 1447, 1, 0, 0, 0, 1449, 1450, 1, 0, 0, 0, 1450, 1448, 1, 0, 0, 
	0, 1450, 1451, 1, 0, 0, 0, 1451, 1453, 1, 0, 0, 0, 1452, 1454, 3, 212, 
	106, 0, 1453, 1452, 1, 0, 0, 0, 1453, 1454, 1, 0, 0, 0, 1454, 1455, 1, 
	0, 0, 0, 1455, 1456, 5, 78, 0, 0, 1456, 209, 1, 0, 0, 0, 1457, 1458, 5, 
	51, 0, 0, 1458, 1459, 3, 190, 95, 0, 1459, 1460, 5, 79, 0, 0, 1460, 1461, 
	3, 214, 107, 0, 1461, 211, 1, 0, 0, 0, 1462, 1463, 5, 10, 0, 0, 1463, 1464, 
	3, 214, 107, 0, 1464, 213, 1, 0, 0, 0, 1465, 1470, 3, 190, 95, 0, 1466, 
	1467, 5, 207, 0, 0, 1467, 1469, 3, 190, 95, 0, 1468, 1466, 1, 0, 0, 0, 
	1469, 1472, 1, 0, 0, 0, 1470, 1468, 1, 0, 0, 0, 1470, 1471, 1, 0, 0, 0, 
	1471, 215, 1, 0, 0, 0, 1472, 1470, 1, 0, 0, 0, 1473, 1474, 5, 63, 0, 0, 
	1474, 1475, 5, 64, 0, 0, 1475, 1476, 3, 266, 133, 0, 1476, 217, 1, 0, 0, 
	0, 1477, 1478, 5, 65, 0, 0, 1478, 1479, 3, 220, 110, 0, 1479, 219, 1, 0, 
	0, 0, 1480, 1485, 3, 222, 111, 0, 1481, 1482, 5, 69, 0, 0, 1482, 1484, 
	3, 222, 111, 0, 1483, 1481, 1, 0, 0, 0, 1484, 1487, 1, 0, 0, 0, 1485, 1483, 
	1, 0, 0, 0, 1485, 1486, 1, 0, 0, 0, 1486, 1499, 1, 0, 0, 0, 1487, 1485, 
	1, 0, 0, 0, 1488, 1493, 3, 222, 111, 0, 1489, 1490, 5, 70, 0, 0, 1490, 
	1492, 3, 222, 111, 0, 1491, 1489, 1, 0, 0, 0, 1492, 1495, 1, 0, 0, 0, 1493, 
	1491, 1, 0, 0, 0, 1493, 1494, 1, 0, 0, 0, 1494, 1499, 1, 0, 0, 0, 1495, 
	1493, 1, 0, 0, 0, 1496, 1497, 5, 71, 0, 0, 1497, 1499, 3, 222, 111, 0, 
	1498, 1480, 1, 0, 0, 0, 1498, 1488, 1, 0, 0, 0, 1498, 1496, 1, 0, 0, 0, 
	1499, 221, 1, 0, 0, 0, 1500, 1501, 5, 200, 0, 0, 1501, 1502, 3, 220, 110, 
	0, 1502, 1503, 5, 201, 0, 0, 1503, 1506, 1, 0, 0, 0, 1504, 1506, 3, 224, 
	112, 0, 1505, 1500, 1, 0, 0, 0, 1505, 1504, 1, 0, 0, 0, 1506, 223, 1, 0, 
	0, 0, 1507, 1508, 3, 190, 95, 0, 1508, 1509, 3, 226, 113, 0, 1509, 1510, 
	3, 228, 114, 0, 1510, 1516, 1, 0, 0, 0, 1511, 1512, 3, 200, 100, 0, 1512, 
	1513, 3, 226, 113, 0, 1513, 1514, 3, 228, 114, 0, 1514, 1516, 1, 0, 0, 
	0, 1515, 1507, 1, 0, 0, 0, 1515, 1511, 1, 0, 0, 0, 1516, 225, 1, 0, 0, 
	0, 1517, 1533, 5, 209, 0, 0, 1518, 1533, 5, 219, 0, 0, 1519, 1533, 5, 211, 
	0, 0, 1520, 1533, 5, 210, 0, 0, 1521, 1522, 5, 211, 0, 0, 1522, 1533, 5, 
	209, 0, 0, 1523, 1524, 5, 210, 0, 0, 1524, 1533, 5, 209, 0, 0, 1525, 1533, 
	5, 220, 0, 0, 1526, 1533, 5, 80, 0, 0, 1527, 1533, 5, 81, 0, 0, 1528, 1529, 
	5, 71, 0, 0, 1529, 1533, 5, 81, 0, 0, 1530, 1533, 5, 82, 0, 0, 1531, 1533, 
	5, 83, 0, 0, 1532, 1517, 1, 0, 0, 0, 1532, 1518, 1, 0, 0, 0, 1532, 1519, 
	1, 0, 0, 0, 1532, 1520, 1, 0, 0, 0, 1532, 1521, 1, 0, 0, 0, 1532, 1523, 
	1, 0, 0, 0, 1532, 1525, 1, 0, 0, 0, 1532, 1526, 1, 0, 0, 0, 1532, 1527, 
	1, 0, 0, 0, 1532, 1528, 1, 0, 0, 0, 1532, 1530, 1, 0, 0, 0, 1532, 1531, 
	1, 0, 0, 0, 1533, 227, 1, 0, 0, 0, 1534, 1555, 5, 26, 0, 0, 1535, 1555, 
	5, 197, 0, 0, 1536, 1555, 3, 232, 116, 0, 1537, 1555, 5, 198, 0, 0, 1538, 
	1555, 5, 175, 0, 0, 1539, 1555, 5, 176, 0, 0, 1540, 1555, 3, 262, 131, 
	0, 1541, 1546, 5, 177, 0, 0, 1542, 1544, 5, 208, 0, 0, 1543, 1545, 5, 194, 
	0, 0, 1544, 1543, 1, 0, 0, 0, 1544, 1545, 1, 0, 0, 0, 1545, 1547, 1, 0, 
	0, 0, 1546, 1542, 1, 0, 0, 0, 1546, 1547, 1, 0, 0, 0, 1547, 1555, 1, 0, 
	0, 0, 1548, 1549, 5, 200, 0, 0, 1549, 1550, 3, 184, 92, 0, 1550, 1551, 
	5, 201, 0, 0, 1551, 1555, 1, 0, 0, 0, 1552, 1555, 3, 230, 115, 0, 1553, 
	1555, 3, 260, 130, 0, 1554, 1534, 1, 0, 0, 0, 1554, 1535, 1, 0, 0, 0, 1554, 
	1536, 1, 0, 0, 0, 1554, 1537, 1, 0, 0, 0, 1554, 1538, 1, 0, 0, 0, 1554, 
	1539, 1, 0, 0, 0, 1554, 1540, 1, 0, 0, 0, 1554, 1541, 1, 0, 0, 0, 1554, 
	1548, 1, 0, 0, 0, 1554, 1552, 1, 0, 0, 0, 1554, 1553, 1, 0, 0, 0, 1555, 
	229, 1, 0, 0, 0, 1556, 1557, 5, 200, 0, 0, 1557, 1562, 3, 228, 114, 0, 
	1558, 1559, 5, 207, 0, 0, 1559, 1561, 3, 228, 114, 0, 1560, 1558, 1, 0, 
	0, 0, 1561, 1564, 1, 0, 0, 0, 1562, 1560, 1, 0, 0, 0, 1562, 1563, 1, 0, 
	0, 0, 1563, 1565, 1, 0, 0, 0, 1564, 1562, 1, 0, 0, 0, 1565, 1566, 5, 201, 
	0, 0, 1566, 231, 1, 0, 0, 0, 1567, 1569, 7, 3, 0, 0, 1568, 1567, 1, 0, 
	0, 0, 1568, 1569, 1, 0, 0, 0, 1569, 1570, 1, 0, 0, 0, 1570, 1571, 7, 14, 
	0, 0, 1571, 233, 1, 0, 0, 0, 1572, 1573, 5, 53, 0, 0, 1573, 1574, 5, 97, 
	0, 0, 1574, 1575, 5, 98, 0, 0, 1575, 1585, 3, 236, 118, 0, 1576, 1577, 
	5, 53, 0, 0, 1577, 1585, 5, 103, 0, 0, 1578, 1579, 5, 53, 0, 0, 1579, 1585, 
	5, 104, 0, 0, 1580, 1581, 5, 53, 0, 0, 1581, 1585, 5, 105, 0, 0, 1582, 
	1583, 5, 53, 0, 0, 1583, 1585, 3, 220, 110, 0, 1584, 1572, 1, 0, 0, 0, 
	1584, 1576, 1, 0, 0, 0, 1584, 1578, 1, 0, 0, 0, 1584, 1580, 1, 0, 0, 0, 
	1584, 1582, 1, 0, 0, 0, 1585, 235, 1, 0, 0, 0, 1586, 1591, 3, 238, 119, 
	0, 1587, 1588, 5, 222, 0, 0, 1588, 1590, 3, 238, 119, 0, 1589, 1587, 1, 
	0, 0, 0, 1590, 1593, 1, 0, 0, 0, 1591, 1589, 1, 0, 0, 0, 1591, 1592, 1, 
	0, 0, 0, 1592, 237, 1, 0, 0, 0, 1593, 1591, 1, 0, 0, 0, 1594, 1595, 3, 
	266, 133, 0, 1595, 1596, 3, 242, 121, 0, 1596, 1597, 3, 240, 120, 0, 1597, 
	239, 1, 0, 0, 0, 1598, 1611, 3, 266, 133, 0, 1599, 1600, 5, 200, 0, 0, 
	1600, 1605, 3, 266, 133, 0, 1601, 1602, 5, 207, 0, 0, 1602, 1604, 3, 266, 
	133, 0, 1603, 1601, 1, 0, 0, 0, 1604, 1607, 1, 0, 0, 0, 1605, 1603, 1, 
	0, 0, 0, 1605, 1606, 1, 0, 0, 0, 1606, 1608, 1, 0, 0, 0, 1607, 1605, 1, 
	0, 0, 0, 1608, 1609, 5, 200, 0, 0, 1609, 1611, 1, 0, 0, 0, 1610, 1598, 
	1, 0, 0, 0, 1610, 1599, 1, 0, 0, 0, 1611, 241, 1, 0, 0, 0, 1612, 1613, 
	7, 15, 0, 0, 1613, 243, 1, 0, 0, 0, 1614, 1615, 5, 89, 0, 0, 1615, 1616, 
	5, 67, 0, 0, 1616, 1619, 3, 186, 93, 0, 1617, 1618, 5, 93, 0, 0, 1618, 
	1620, 3, 220, 110, 0, 1619, 1617, 1, 0, 0, 0, 1619, 1620, 1, 0, 0, 0, 1620, 
	1650, 1, 0, 0, 0, 1621, 1622, 5, 89, 0, 0, 1622, 1623, 5, 67, 0, 0, 1623, 
	1624, 5, 94, 0, 0, 1624, 1625, 5, 200, 0, 0, 1625, 1630, 3, 190, 95, 0, 
	1626, 1627, 5, 207, 0, 0, 1627, 1629, 3, 190, 95, 0, 1628, 1626, 1, 0, 
	0, 0, 1629, 1632, 1, 0, 0, 0, 1630, 1628, 1, 0, 0, 0, 1630, 1631, 1, 0, 
	0, 0, 1631, 1633, 1, 0, 0, 0, 1632, 1630, 1, 0, 0, 0, 1633, 1634, 5, 201, 
	0, 0, 1634, 1650, 1, 0, 0, 0, 1635, 1636, 5, 89, 0, 0, 1636, 1637, 5, 67, 
	0, 0, 1637, 1638, 5, 107, 0, 0, 1638, 1639, 5, 200, 0, 0, 1639, 1644, 3, 
	190, 95, 0, 1640, 1641, 5, 207, 0, 0, 1641, 1643, 3, 190, 95, 0, 1642, 
	1640, 1, 0, 0, 0, 1643, 1646, 1, 0, 0, 0, 1644, 1642, 1, 0, 0, 0, 1644, 
	1645, 1, 0, 0, 0, 1645, 1647, 1, 0, 0, 0, 1646, 1644, 1, 0, 0, 0, 1647, 
	1648, 5, 201, 0, 0, 1648, 1650, 1, 0, 0, 0, 1649, 1614, 1, 0, 0, 0, 1649, 
	1621, 1, 0, 0, 0, 1649, 1635, 1, 0, 0, 0, 1650, 245, 1, 0, 0, 0, 1651, 
	1652, 5, 66, 0, 0, 1652, 1653, 5, 67, 0, 0, 1653, 1654, 3, 248, 124, 0, 
	1654, 247, 1, 0, 0, 0, 1655, 1660, 3, 250, 125, 0, 1656, 1657, 5, 207, 
	0, 0, 1657, 1659, 3, 250, 125, 0, 1658, 1656, 1, 0, 0, 0, 1659, 1662, 1, 
	0, 0, 0, 1660, 1658, 1, 0, 0, 0, 1660, 1661, 1, 0, 0, 0, 1661, 249, 1, 
	0, 0, 0, 1662, 1660, 1, 0, 0, 0, 1663, 1665, 3, 190, 95, 0, 1664, 1666, 
	7, 16, 0, 0, 1665, 1664, 1, 0, 0, 0, 1665, 1666, 1, 0, 0, 0, 1666, 1669, 
	1, 0, 0, 0, 1667, 1668, 5, 86, 0, 0, 1668, 1670, 7, 17, 0, 0, 1669, 1667, 
	1, 0, 0, 0, 1669, 1670, 1, 0, 0, 0, 1670, 1680, 1, 0, 0, 0, 1671, 1673, 
	3, 200, 100, 0, 1672, 1674, 7, 16, 0, 0, 1673, 1672, 1, 0, 0, 0, 1673, 
	1674, 1, 0, 0, 0, 1674, 1677, 1, 0, 0, 0, 1675, 1676, 5, 86, 0, 0, 1676, 
	1678, 7, 17, 0, 0, 1677, 1675, 1, 0, 0, 0, 1677, 1678, 1, 0, 0, 0, 1678, 
	1680, 1, 0, 0, 0, 1679, 1663, 1, 0, 0, 0, 1679, 1671, 1, 0, 0, 0, 1680, 
	251, 1, 0, 0, 0, 1681, 1682, 5, 68, 0, 0, 1682, 1686, 5, 194, 0, 0, 1683, 
	1684, 5, 68, 0, 0, 1684, 1686, 3, 260, 130, 0, 1685, 1681, 1, 0, 0, 0, 
	1685, 1683, 1, 0, 0, 0, 1686, 253, 1, 0, 0, 0, 1687, 1688, 5, 96, 0, 0, 
	1688, 1692, 5, 194, 0, 0, 1689, 1690, 5, 96, 0, 0, 1690, 1692, 3, 260, 
	130, 0, 1691, 1687, 1, 0, 0, 0, 1691, 1689, 1, 0, 0, 0, 1692, 255, 1, 0, 
	0, 0, 1693, 1694, 5, 90, 0, 0, 1694, 1695, 5, 91, 0, 0, 1695, 257, 1, 0, 
	0, 0, 1696, 1697, 5, 15, 0, 0, 1697, 1699, 7, 18, 0, 0, 1698, 1696, 1, 
	0, 0, 0, 1699, 1702, 1, 0, 0, 0, 1700, 1698, 1, 0, 0, 0, 1700, 1701, 1, 
	0, 0, 0, 1701, 259, 1, 0, 0, 0, 1702, 1700, 1, 0, 0, 0, 1703, 1704, 5, 
	216, 0, 0, 1704, 1705, 3, 152, 76, 0, 1705, 261, 1, 0, 0, 0, 1706, 1793, 
	5, 131, 0, 0, 1707, 1793, 5, 132, 0, 0, 1708, 1793, 5, 133, 0, 0, 1709, 
	1793, 5, 134, 0, 0, 1710, 1793, 5, 135, 0, 0, 1711, 1793, 5, 136, 0, 0, 
	1712, 1793, 5, 137, 0, 0, 1713, 1793, 5, 138, 0, 0, 1714, 1793, 5, 139, 
	0, 0, 1715, 1793, 5, 140, 0, 0, 1716, 1793, 5, 141, 0, 0, 1717, 1718, 5, 
	142, 0, 0, 1718, 1719, 5, 216, 0, 0, 1719, 1793, 3, 264, 132, 0, 1720, 
	1721, 5, 143, 0, 0, 1721, 1722, 5, 216, 0, 0, 1722, 1793, 3, 264, 132, 
	0, 1723, 1724, 5, 144, 0, 0, 1724, 1725, 5, 216, 0, 0, 1725, 1793, 3, 264, 
	132, 0, 1726, 1727, 5, 145, 0, 0, 1727, 1728, 5, 216, 0, 0, 1728, 1793, 
	3, 264, 132, 0, 1729, 1730, 5, 146, 0, 0, 1730, 1731, 5, 216, 0, 0, 1731, 
	1793, 3, 264, 132, 0, 1732, 1733, 5, 147, 0, 0, 1733, 1734, 5, 216, 0, 
	0, 1734, 1793, 3, 264, 132, 0, 1735, 1736, 5, 148, 0, 0, 1736, 1737, 5, 
	216, 0, 0, 1737, 1793, 3, 264, 132, 0, 1738, 1739, 5, 149, 0, 0, 1739, 
	1740, 5, 216, 0, 0, 1740, 1793, 3, 264, 132, 0, 1741, 1742, 5, 150, 0, 
	0, 1742, 1743, 5, 216, 0, 0, 1743, 1793, 3, 264, 132, 0, 1744, 1793, 5, 
	151, 0, 0, 1745, 1793, 5, 152, 0, 0, 1746, 1793, 5, 153, 0, 0, 1747, 1748, 
	5, 154, 0, 0, 1748, 1749, 5, 216, 0, 0, 1749, 1793, 3, 264, 132, 0, 1750, 
	1751, 5, 155, 0, 0, 1751, 1752, 5, 216, 0, 0, 1752, 1793, 3, 264, 132, 
	0, 1753, 1754, 5, 156, 0, 0, 1754, 1755, 5, 216, 0, 0, 1755, 1793, 3, 264, 
	132, 0, 1756, 1793, 5, 157, 0, 0, 1757, 1793, 5, 158, 0, 0, 1758, 1793, 
	5, 159, 0, 0, 1759, 1760, 5, 160, 0, 0, 1760, 1761, 5, 216, 0, 0, 1761, 
	1793, 3, 264, 132, 0, 1762, 1763, 5, 161, 0, 0, 1763, 1764, 5, 216, 0, 
	0, 1764, 1793, 3, 264, 132, 0, 1765, 1766, 5, 162, 0, 0, 1766, 1767, 5, 
	216, 0, 0, 1767, 1793, 3, 264, 132, 0, 1768, 1793, 5, 163, 0, 0, 1769, 
	1793, 5, 164, 0, 0, 1770, 1793, 5, 165, 0, 0, 1771, 1772, 5, 166, 0, 0, 
	1772, 1773, 5, 216, 0, 0, 1773, 1793, 3, 264, 132, 0, 1774, 1775, 5, 167, 
	0, 0, 1775, 1776, 5, 216, 0, 0, 1776, 1793, 3, 264, 132, 0, 1777, 1778, 
	5, 168, 0, 0, 1778, 1779, 5, 216, 0, 0, 1779, 1793, 3, 264, 132, 0, 1780, 
	1793, 5, 169, 0, 0, 1781, 1793, 5, 170, 0, 0, 1782, 1793, 5, 171, 0, 0, 
	1783, 1784, 5, 172, 0, 0, 1784, 1785, 5, 216, 0, 0, 1785, 1793, 3, 264, 
	132, 0, 1786, 1787, 5, 173, 0, 0, 1787, 1788, 5, 216, 0, 0, 1788, 1793, 
	3, 264, 132, 0, 1789, 1790, 5, 174, 0, 0, 1790, 1791, 5, 216, 0, 0, 1791, 
	1793, 3, 264, 132, 0, 1792, 1706, 1, 0, 0, 0, 1792, 1707, 1, 0, 0, 0, 1792, 
	1708, 1, 0, 0, 0, 1792, 1709, 1, 0, 0, 0, 1792, 1710, 1, 0, 0, 0, 1792, 
	1711, 1, 0, 0, 0, 1792, 1712, 1, 0, 0, 0, 1792, 1713, 1, 0, 0, 0, 1792, 
	1714, 1, 0, 0, 0, 1792, 1715, 1, 0, 0, 0, 1792, 1716, 1, 0, 0, 0, 1792, 
	1717, 1, 0, 0, 0, 1792, 1720, 1, 0, 0, 0, 1792, 1723, 1, 0, 0, 0, 1792, 
	1726, 1, 0, 0, 0, 1792, 1729, 1, 0, 0, 0, 1792, 1732, 1, 0, 0, 0, 1792, 
	1735, 1, 0, 0, 0, 1792, 1738, 1, 0, 0, 0, 1792, 1741, 1, 0, 0, 0, 1792, 
	1744, 1, 0, 0, 0, 1792, 1745, 1, 0, 0, 0, 1792, 1746, 1, 0, 0, 0, 1792, 
	1747, 1, 0, 0, 0, 1792, 1750, 1, 0, 0, 0, 1792, 1753, 1, 0, 0, 0, 1792, 
	1756, 1, 0, 0, 0, 1792, 1757, 1, 0, 0, 0, 1792, 1758, 1, 0, 0, 0, 1792, 
	1759, 1, 0, 0, 0, 1792, 1762, 1, 0, 0, 0, 1792, 1765, 1, 0, 0, 0, 1792, 
	1768, 1, 0, 0, 0, 1792, 1769, 1, 0, 0, 0, 1792, 1770, 1, 0, 0, 0, 1792, 
	1771, 1, 0, 0, 0, 1792, 1774, 1, 0, 0, 0, 1792, 1777, 1, 0, 0, 0, 1792, 
	1780, 1, 0, 0, 0, 1792, 1781, 1, 0, 0, 0, 1792, 1782, 1, 0, 0, 0, 1792, 
	1783, 1, 0, 0, 0, 1792, 1786, 1, 0, 0, 0, 1792, 1789, 1, 0, 0, 0, 1793, 
	263, 1, 0, 0, 0, 1794, 1796, 7, 3, 0, 0, 1795, 1794, 1, 0, 0, 0, 1795, 
	1796, 1, 0, 0, 0, 1796, 1797, 1, 0, 0, 0, 1797, 1798, 5, 194, 0, 0, 1798, 
	265, 1, 0, 0, 0, 1799, 1800, 3, 292, 146, 0, 1800, 267, 1, 0, 0, 0, 1801, 
	1802, 5, 192, 0, 0, 1802, 1803, 3, 272, 136, 0, 1803, 1804, 5, 205, 0, 
	0, 1804, 1812, 1, 0, 0, 0, 1805, 1806, 5, 204, 0, 0, 1806, 1807, 5, 178, 
	0, 0, 1807, 1808, 3, 260, 130, 0, 1808, 1809, 3, 272, 136, 0, 1809, 1810, 
	5, 205, 0, 0, 1810, 1812, 1, 0, 0, 0, 1811, 1801, 1, 0, 0, 0, 1811, 1805, 
	1, 0, 0, 0, 1812, 269, 1, 0, 0, 0, 1813, 1814, 5, 193, 0, 0, 1814, 1815, 
	3, 272, 136, 0, 1815, 1816, 5, 205, 0, 0, 1816, 271, 1, 0, 0, 0, 1817, 
	1818, 5, 81, 0, 0, 1818, 1820, 3, 276, 138, 0, 1819, 1817, 1, 0, 0, 0, 
	1819, 1820, 1, 0, 0, 0, 1820, 1823, 1, 0, 0, 0, 1821, 1822, 5, 190, 0, 
	0, 1822, 1824, 3, 278, 139, 0, 1823, 1821, 1, 0, 0, 0, 1823, 1824, 1, 0, 
	0, 0, 1824, 1828, 1, 0, 0, 0, 1825, 1827, 3, 274, 137, 0, 1826, 1825, 1, 
	0, 0, 0, 1827, 1830, 1, 0, 0, 0, 1828, 1826, 1, 0, 0, 0, 1828, 1829, 1, 
	0, 0, 0, 1829, 1832, 1, 0, 0, 0, 1830, 1828, 1, 0, 0, 0, 1831, 1833, 3, 
	252, 126, 0, 1832, 1831, 1, 0, 0, 0, 1832, 1833, 1, 0, 0, 0, 1833, 1836, 
	1, 0, 0, 0, 1834, 1835, 5, 46, 0, 0, 1835, 1837, 3, 284, 142, 0, 1836, 
	1834, 1, 0, 0, 0, 1836, 1837, 1, 0, 0, 0, 1837, 273, 1, 0, 0, 0, 1838, 
	1839, 5, 53, 0, 0, 1839, 1840, 5, 189, 0, 0, 1840, 1841, 5, 209, 0, 0, 
	1841, 1879, 5, 198, 0, 0, 1842, 1843, 5, 53, 0, 0, 1843, 1844, 5, 97, 0, 
	0, 1844, 1845, 5, 98, 0, 0, 1845, 1879, 3, 236, 118, 0, 1846, 1847, 5, 
	53, 0, 0, 1847, 1853, 5, 187, 0, 0, 1848, 1849, 5, 200, 0, 0, 1849, 1850, 
	5, 188, 0, 0, 1850, 1851, 5, 209, 0, 0, 1851, 1852, 5, 194, 0, 0, 1852, 
	1854, 5, 201, 0, 0, 1853, 1848, 1, 0, 0, 0, 1853, 1854, 1, 0, 0, 0, 1854, 
	1879, 1, 0, 0, 0, 1855, 1856, 5, 53, 0, 0, 1856, 1857, 5, 186, 0, 0, 1857, 
	1858, 5, 81, 0, 0, 1858, 1859, 5, 200, 0, 0, 1859, 1860, 3, 288, 144, 0, 
	1860, 1861, 5, 201, 0, 0, 1861, 1879, 1, 0, 0, 0, 1862, 1863, 5, 53, 0, 
	0, 1863, 1864, 5, 186, 0, 0, 1864, 1865, 5, 209, 0, 0, 1865, 1879, 5, 198, 
	0, 0, 1866, 1867, 5, 53, 0, 0, 1867, 1868, 5, 185, 0, 0, 1868, 1869, 5, 
	209, 0, 0, 1869, 1879, 5, 198, 0, 0, 1870, 1871, 5, 53, 0, 0, 1871, 1872, 
	5, 184, 0, 0, 1872, 1873, 5, 209, 0, 0, 1873, 1879, 5, 198, 0, 0, 1874, 
	1875, 5, 53, 0, 0, 1875, 1879, 5, 105, 0, 0, 1876, 1877, 5, 53, 0, 0, 1877, 
	1879, 5, 104, 0, 0, 1878, 1838, 1, 0, 0, 0, 1878, 1842, 1, 0, 0, 0, 1878, 
	1846, 1, 0, 0, 0, 1878, 1855, 1, 0, 0, 0, 1878, 1862, 1, 0, 0, 0, 1878, 
	1866, 1, 0, 0, 0, 1878, 1870, 1, 0, 0, 0, 1878, 1874, 1, 0, 0, 0, 1878, 
	1876, 1, 0, 0, 0, 1879, 275, 1, 0, 0, 0, 1880, 1881, 7, 19, 0, 0, 1881, 
	1882, 5, 183, 0, 0, 1882, 277, 1, 0, 0, 0, 1883, 1888, 3, 280, 140, 0, 
	1884, 1885, 5, 207, 0, 0, 1885, 1887, 3, 278, 139, 0, 1886, 1884, 1, 0, 
	0, 0, 1887, 1890, 1, 0, 0, 0, 1888, 1886, 1, 0, 0, 0, 1888, 1889, 1, 0, 
	0, 0, 1889, 279, 1, 0, 0, 0, 1890, 1888, 1, 0, 0, 0, 1891, 1917, 3, 290, 
	145, 0, 1892, 1893, 5, 200, 0, 0, 1893, 1896, 3, 282, 141, 0, 1894, 1895, 
	5, 65, 0, 0, 1895, 1897, 3, 220, 110, 0, 1896, 1894, 1, 0, 0, 0, 1896, 
	1897, 1, 0, 0, 0, 1897, 1902, 1, 0, 0, 0, 1898, 1899, 5, 63, 0, 0, 1899, 
	1900, 5, 191, 0, 0, 1900, 1901, 5, 209, 0, 0, 1901, 1903, 3, 290, 145, 
	0, 1902, 1898, 1, 0, 0, 0, 1902, 1903, 1, 0, 0, 0, 1903, 1907, 1, 0, 0, 
	0, 1904, 1905, 5, 66, 0, 0, 1905, 1906, 5, 67, 0, 0, 1906, 1908, 3, 248, 
	124, 0, 1907, 1904, 1, 0, 0, 0, 1907, 1908, 1, 0, 0, 0, 1908, 1910, 1, 
	0, 0, 0, 1909, 1911, 3, 252, 126, 0, 1910, 1909, 1, 0, 0, 0, 1910, 1911, 
	1, 0, 0, 0, 1911, 1913, 1, 0, 0, 0, 1912, 1914, 3, 254, 127, 0, 1913, 1912, 
	1, 0, 0, 0, 1913, 1914, 1, 0, 0, 0, 1914, 1915, 1, 0, 0, 0, 1915, 1916, 
	5, 201, 0, 0, 1916, 1918, 1, 0, 0, 0, 1917, 1892, 1, 0, 0, 0, 1917, 1918, 
	1, 0, 0, 0, 1918, 281, 1, 0, 0, 0, 1919, 1924, 3, 290, 145, 0, 1920, 1921, 
	5, 207, 0, 0, 1921, 1923, 3, 282, 141, 0, 1922, 1920, 1, 0, 0, 0, 1923, 
	1926, 1, 0, 0, 0, 1924, 1922, 1, 0, 0, 0, 1924, 1925, 1, 0, 0, 0, 1925, 
	1952, 1, 0, 0, 0, 1926, 1924, 1, 0, 0, 0, 1927, 1928, 5, 95, 0, 0, 1928, 
	1929, 5, 200, 0, 0, 1929, 1930, 3, 290, 145, 0, 1930, 1932, 5, 201, 0, 
	0, 1931, 1933, 3, 290, 145, 0, 1932, 1931, 1, 0, 0, 0, 1932, 1933, 1, 0, 
	0, 0, 1933, 1952, 1, 0, 0, 0, 1934, 1935, 5, 116, 0, 0, 1935, 1936, 5, 
	200, 0, 0, 1936, 1937, 3, 290, 145, 0, 1937, 1939, 5, 201, 0, 0, 1938, 
	1940, 3, 290, 145, 0, 1939, 1938, 1, 0, 0, 0, 1939, 1940, 1, 0, 0, 0, 1940, 
	1952, 1, 0, 0, 0, 1941, 1942, 5, 108, 0, 0, 1942, 1945, 5, 200, 0, 0, 1943, 
	1946, 3, 290, 145, 0, 1944, 1946, 3, 200, 100, 0, 1945, 1943, 1, 0, 0, 
	0, 1945, 1944, 1, 0, 0, 0, 1946, 1947, 1, 0, 0, 0, 1947, 1949, 5, 201, 
	0, 0, 1948, 1950, 3, 290, 145, 0, 1949, 1948, 1, 0, 0, 0, 1949, 1950, 1, 
	0, 0, 0, 1950, 1952, 1, 0, 0, 0, 1951, 1919, 1, 0, 0, 0, 1951, 1927, 1, 
	0, 0, 0, 1951, 1934, 1, 0, 0, 0, 1951, 1941, 1, 0, 0, 0, 1952, 283, 1, 
	0, 0, 0, 1953, 1956, 3, 286, 143, 0, 1954, 1955, 5, 207, 0, 0, 1955, 1957, 
	3, 284, 142, 0, 1956, 1954, 1, 0, 0, 0, 1956, 1957, 1, 0, 0, 0, 1957, 285, 
	1, 0, 0, 0, 1958, 1959, 7, 20, 0, 0, 1959, 287, 1, 0, 0, 0, 1960, 1963, 
	5, 198, 0, 0, 1961, 1962, 5, 207, 0, 0, 1962, 1964, 3, 288, 144, 0, 1963, 
	1961, 1, 0, 0, 0, 1963, 1964, 1, 0, 0, 0, 1964, 289, 1, 0, 0, 0, 1965, 
	1970, 3, 292, 146, 0, 1966, 1967, 5, 208, 0, 0, 1967, 1969, 3, 290, 145, 
	0, 1968, 1966, 1, 0, 0, 0, 1969, 1972, 1, 0, 0, 0, 1970, 1968, 1, 0, 0, 
	0, 1970, 1971, 1, 0, 0, 0, 1971, 291, 1, 0, 0, 0, 1972, 1970, 1, 0, 0, 
	0, 1973, 1974, 7, 21, 0, 0, 1974, 293, 1, 0, 0, 0, 1975, 1976, 7, 22, 0, 
	0, 1976, 295, 1, 0, 0, 0, 195, 306, 320, 328, 333, 341, 348, 355, 359, 
	365, 369, 377, 386, 393, 402, 409, 418, 425, 431, 435, 456, 465, 473, 477, 
	483, 499, 507, 512, 523, 529, 537, 541, 543, 552, 561, 566, 570, 574, 578, 
	580, 588, 597, 603, 614, 624, 627, 631, 636, 646, 654, 657, 660, 668, 679, 
	705, 712, 721, 735, 741, 746, 753, 764, 772, 778, 791, 794, 797, 801, 820, 
	827, 834, 841, 848, 852, 858, 867, 878, 883, 888, 893, 900, 913, 917, 921, 
	923, 927, 945, 966, 982, 988, 1025, 1037, 1039, 1055, 1060, 1067, 1073, 
	1076, 1081, 1091, 1098, 1106, 1120, 1122, 1130, 1145, 1152, 1165, 1168, 
	1171, 1174, 1177, 1180, 1183, 1186, 1191, 1198, 1201, 1204, 1209, 1216, 
	1221, 1225, 1231, 1234, 1241, 1246, 1251, 1255, 1263, 1268, 1272, 1278, 
	1281, 1327, 1420, 1428, 1439, 1443, 1450, 1453, 1470, 1485, 1493, 1498, 
	1505, 1515, 1532, 1544, 1546, 1554, 1562, 1568, 1584, 1591, 1605, 1610, 
	1619, 1630, 1644, 1649, 1660, 1665, 1669, 1673, 1677, 1679, 1685, 1691, 
	1700, 1792, 1795, 1811, 1819, 1823, 1828, 1832, 1836, 1853, 1878, 1888, 
	1896, 1902, 1907, 1910, 1913, 1917, 1924, 1932, 1939, 1945, 1949, 1951, 
	1956, 1963, 1970,
}
  deserializer := antlr.NewATNDeserializer(nil)
  staticData.atn = deserializer.Deserialize(staticData.serializedATN)
  atn := staticData.atn
  staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
  decisionToDFA := staticData.decisionToDFA
  for index, state := range atn.DecisionToState {
    decisionToDFA[index] = antlr.NewDFA(state, index)
  }
}

// ApexParserInit initializes any static state used to implement ApexParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewApexParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func ApexParserInit() {
  staticData := &ApexParserParserStaticData
  staticData.once.Do(apexparserParserInit)
}

// NewApexParser produces a new parser instance for the optional input antlr.TokenStream.
func NewApexParser(input antlr.TokenStream) *ApexParser {
	ApexParserInit()
	this := new(ApexParser)
	this.BaseParser = antlr.NewBaseParser(input)
  staticData := &ApexParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "ApexParser.g4"

	return this
}

// Note that '@members' cannot be changed now, but this should have been 'globals'
// If you are looking to have variables for each instance, use '@structmembers'




// ApexParser tokens.
const (
	ApexParserEOF = antlr.TokenEOF
	ApexParserABSTRACT = 1
	ApexParserAFTER = 2
	ApexParserBEFORE = 3
	ApexParserBREAK = 4
	ApexParserCATCH = 5
	ApexParserCLASS = 6
	ApexParserCONTINUE = 7
	ApexParserDELETE = 8
	ApexParserDO = 9
	ApexParserELSE = 10
	ApexParserENUM = 11
	ApexParserEXTENDS = 12
	ApexParserFINAL = 13
	ApexParserFINALLY = 14
	ApexParserFOR = 15
	ApexParserGET = 16
	ApexParserGLOBAL = 17
	ApexParserIF = 18
	ApexParserIMPLEMENTS = 19
	ApexParserINHERITED = 20
	ApexParserINSERT = 21
	ApexParserINSTANCEOF = 22
	ApexParserINTERFACE = 23
	ApexParserMERGE = 24
	ApexParserNEW = 25
	ApexParserNULL = 26
	ApexParserON = 27
	ApexParserOVERRIDE = 28
	ApexParserPRIVATE = 29
	ApexParserPROTECTED = 30
	ApexParserPUBLIC = 31
	ApexParserRETURN = 32
	ApexParserSYSTEMRUNAS = 33
	ApexParserSET = 34
	ApexParserSHARING = 35
	ApexParserSTATIC = 36
	ApexParserSUPER = 37
	ApexParserSWITCH = 38
	ApexParserTESTMETHOD = 39
	ApexParserTHIS = 40
	ApexParserTHROW = 41
	ApexParserTRANSIENT = 42
	ApexParserTRIGGER = 43
	ApexParserTRY = 44
	ApexParserUNDELETE = 45
	ApexParserUPDATE = 46
	ApexParserUPSERT = 47
	ApexParserVIRTUAL = 48
	ApexParserVOID = 49
	ApexParserWEBSERVICE = 50
	ApexParserWHEN = 51
	ApexParserWHILE = 52
	ApexParserWITH = 53
	ApexParserWITHOUT = 54
	ApexParserLIST = 55
	ApexParserMAP = 56
	ApexParserSYSTEM = 57
	ApexParserUSER = 58
	ApexParserSELECT = 59
	ApexParserCOUNT = 60
	ApexParserFROM = 61
	ApexParserAS = 62
	ApexParserUSING = 63
	ApexParserSCOPE = 64
	ApexParserWHERE = 65
	ApexParserORDER = 66
	ApexParserBY = 67
	ApexParserLIMIT = 68
	ApexParserSOQLAND = 69
	ApexParserSOQLOR = 70
	ApexParserNOT = 71
	ApexParserAVG = 72
	ApexParserCOUNT_DISTINCT = 73
	ApexParserMIN = 74
	ApexParserMAX = 75
	ApexParserSUM = 76
	ApexParserTYPEOF = 77
	ApexParserEND = 78
	ApexParserTHEN = 79
	ApexParserLIKE = 80
	ApexParserIN = 81
	ApexParserINCLUDES = 82
	ApexParserEXCLUDES = 83
	ApexParserASC = 84
	ApexParserDESC = 85
	ApexParserNULLS = 86
	ApexParserFIRST = 87
	ApexParserLAST = 88
	ApexParserGROUP = 89
	ApexParserALL = 90
	ApexParserROWS = 91
	ApexParserVIEW = 92
	ApexParserHAVING = 93
	ApexParserROLLUP = 94
	ApexParserTOLABEL = 95
	ApexParserOFFSET = 96
	ApexParserDATA = 97
	ApexParserCATEGORY = 98
	ApexParserAT = 99
	ApexParserABOVE = 100
	ApexParserBELOW = 101
	ApexParserABOVE_OR_BELOW = 102
	ApexParserSECURITY_ENFORCED = 103
	ApexParserSYSTEM_MODE = 104
	ApexParserUSER_MODE = 105
	ApexParserREFERENCE = 106
	ApexParserCUBE = 107
	ApexParserFORMAT = 108
	ApexParserTRACKING = 109
	ApexParserVIEWSTAT = 110
	ApexParserCUSTOM = 111
	ApexParserSTANDARD = 112
	ApexParserDISTANCE = 113
	ApexParserGEOLOCATION = 114
	ApexParserGROUPING = 115
	ApexParserCONVERT_CURRENCY = 116
	ApexParserCALENDAR_MONTH = 117
	ApexParserCALENDAR_QUARTER = 118
	ApexParserCALENDAR_YEAR = 119
	ApexParserDAY_IN_MONTH = 120
	ApexParserDAY_IN_WEEK = 121
	ApexParserDAY_IN_YEAR = 122
	ApexParserDAY_ONLY = 123
	ApexParserFISCAL_MONTH = 124
	ApexParserFISCAL_QUARTER = 125
	ApexParserFISCAL_YEAR = 126
	ApexParserHOUR_IN_DAY = 127
	ApexParserWEEK_IN_MONTH = 128
	ApexParserWEEK_IN_YEAR = 129
	ApexParserCONVERT_TIMEZONE = 130
	ApexParserYESTERDAY = 131
	ApexParserTODAY = 132
	ApexParserTOMORROW = 133
	ApexParserLAST_WEEK = 134
	ApexParserTHIS_WEEK = 135
	ApexParserNEXT_WEEK = 136
	ApexParserLAST_MONTH = 137
	ApexParserTHIS_MONTH = 138
	ApexParserNEXT_MONTH = 139
	ApexParserLAST_90_DAYS = 140
	ApexParserNEXT_90_DAYS = 141
	ApexParserLAST_N_DAYS_N = 142
	ApexParserNEXT_N_DAYS_N = 143
	ApexParserN_DAYS_AGO_N = 144
	ApexParserNEXT_N_WEEKS_N = 145
	ApexParserLAST_N_WEEKS_N = 146
	ApexParserN_WEEKS_AGO_N = 147
	ApexParserNEXT_N_MONTHS_N = 148
	ApexParserLAST_N_MONTHS_N = 149
	ApexParserN_MONTHS_AGO_N = 150
	ApexParserTHIS_QUARTER = 151
	ApexParserLAST_QUARTER = 152
	ApexParserNEXT_QUARTER = 153
	ApexParserNEXT_N_QUARTERS_N = 154
	ApexParserLAST_N_QUARTERS_N = 155
	ApexParserN_QUARTERS_AGO_N = 156
	ApexParserTHIS_YEAR = 157
	ApexParserLAST_YEAR = 158
	ApexParserNEXT_YEAR = 159
	ApexParserNEXT_N_YEARS_N = 160
	ApexParserLAST_N_YEARS_N = 161
	ApexParserN_YEARS_AGO_N = 162
	ApexParserTHIS_FISCAL_QUARTER = 163
	ApexParserLAST_FISCAL_QUARTER = 164
	ApexParserNEXT_FISCAL_QUARTER = 165
	ApexParserNEXT_N_FISCAL_QUARTERS_N = 166
	ApexParserLAST_N_FISCAL_QUARTERS_N = 167
	ApexParserN_FISCAL_QUARTERS_AGO_N = 168
	ApexParserTHIS_FISCAL_YEAR = 169
	ApexParserLAST_FISCAL_YEAR = 170
	ApexParserNEXT_FISCAL_YEAR = 171
	ApexParserNEXT_N_FISCAL_YEARS_N = 172
	ApexParserLAST_N_FISCAL_YEARS_N = 173
	ApexParserN_FISCAL_YEARS_AGO_N = 174
	ApexParserDateLiteral = 175
	ApexParserDateTimeLiteral = 176
	ApexParserIntegralCurrencyLiteral = 177
	ApexParserFIND = 178
	ApexParserEMAIL = 179
	ApexParserNAME = 180
	ApexParserPHONE = 181
	ApexParserSIDEBAR = 182
	ApexParserFIELDS = 183
	ApexParserMETADATA = 184
	ApexParserPRICEBOOKID = 185
	ApexParserNETWORK = 186
	ApexParserSNIPPET = 187
	ApexParserTARGET_LENGTH = 188
	ApexParserDIVISION = 189
	ApexParserRETURNING = 190
	ApexParserLISTVIEW = 191
	ApexParserFindLiteral = 192
	ApexParserFindLiteralAlt = 193
	ApexParserIntegerLiteral = 194
	ApexParserLongLiteral = 195
	ApexParserNumberLiteral = 196
	ApexParserBooleanLiteral = 197
	ApexParserStringLiteral = 198
	ApexParserNullLiteral = 199
	ApexParserLPAREN = 200
	ApexParserRPAREN = 201
	ApexParserLBRACE = 202
	ApexParserRBRACE = 203
	ApexParserLBRACK = 204
	ApexParserRBRACK = 205
	ApexParserSEMI = 206
	ApexParserCOMMA = 207
	ApexParserDOT = 208
	ApexParserASSIGN = 209
	ApexParserGT = 210
	ApexParserLT = 211
	ApexParserBANG = 212
	ApexParserTILDE = 213
	ApexParserQUESTIONDOT = 214
	ApexParserQUESTION = 215
	ApexParserCOLON = 216
	ApexParserEQUAL = 217
	ApexParserTRIPLEEQUAL = 218
	ApexParserNOTEQUAL = 219
	ApexParserLESSANDGREATER = 220
	ApexParserTRIPLENOTEQUAL = 221
	ApexParserAND = 222
	ApexParserOR = 223
	ApexParserCOAL = 224
	ApexParserINC = 225
	ApexParserDEC = 226
	ApexParserADD = 227
	ApexParserSUB = 228
	ApexParserMUL = 229
	ApexParserDIV = 230
	ApexParserBITAND = 231
	ApexParserBITOR = 232
	ApexParserCARET = 233
	ApexParserMAPTO = 234
	ApexParserADD_ASSIGN = 235
	ApexParserSUB_ASSIGN = 236
	ApexParserMUL_ASSIGN = 237
	ApexParserDIV_ASSIGN = 238
	ApexParserAND_ASSIGN = 239
	ApexParserOR_ASSIGN = 240
	ApexParserXOR_ASSIGN = 241
	ApexParserLSHIFT_ASSIGN = 242
	ApexParserRSHIFT_ASSIGN = 243
	ApexParserURSHIFT_ASSIGN = 244
	ApexParserATSIGN = 245
	ApexParserIdentifier = 246
	ApexParserWS = 247
	ApexParserDOC_COMMENT = 248
	ApexParserCOMMENT = 249
	ApexParserLINE_COMMENT = 250
)

// ApexParser rules.
const (
	ApexParserRULE_triggerUnit = 0
	ApexParserRULE_triggerCase = 1
	ApexParserRULE_triggerBlock = 2
	ApexParserRULE_triggerBlockMember = 3
	ApexParserRULE_compilationUnit = 4
	ApexParserRULE_typeDeclaration = 5
	ApexParserRULE_classDeclaration = 6
	ApexParserRULE_enumDeclaration = 7
	ApexParserRULE_enumConstants = 8
	ApexParserRULE_interfaceDeclaration = 9
	ApexParserRULE_typeList = 10
	ApexParserRULE_classBody = 11
	ApexParserRULE_interfaceBody = 12
	ApexParserRULE_classBodyDeclaration = 13
	ApexParserRULE_modifier = 14
	ApexParserRULE_memberDeclaration = 15
	ApexParserRULE_triggerMemberDeclaration = 16
	ApexParserRULE_methodDeclaration = 17
	ApexParserRULE_constructorDeclaration = 18
	ApexParserRULE_fieldDeclaration = 19
	ApexParserRULE_propertyDeclaration = 20
	ApexParserRULE_interfaceMethodDeclaration = 21
	ApexParserRULE_variableDeclarators = 22
	ApexParserRULE_variableDeclarator = 23
	ApexParserRULE_arrayInitializer = 24
	ApexParserRULE_typeRef = 25
	ApexParserRULE_arraySubscripts = 26
	ApexParserRULE_typeName = 27
	ApexParserRULE_typeArguments = 28
	ApexParserRULE_formalParameters = 29
	ApexParserRULE_formalParameterList = 30
	ApexParserRULE_formalParameter = 31
	ApexParserRULE_qualifiedName = 32
	ApexParserRULE_literal = 33
	ApexParserRULE_annotation = 34
	ApexParserRULE_elementValuePairs = 35
	ApexParserRULE_elementValuePair = 36
	ApexParserRULE_elementValue = 37
	ApexParserRULE_elementValueArrayInitializer = 38
	ApexParserRULE_block = 39
	ApexParserRULE_localVariableDeclarationStatement = 40
	ApexParserRULE_localVariableDeclaration = 41
	ApexParserRULE_statement = 42
	ApexParserRULE_ifStatement = 43
	ApexParserRULE_switchStatement = 44
	ApexParserRULE_whenControl = 45
	ApexParserRULE_whenValue = 46
	ApexParserRULE_whenLiteral = 47
	ApexParserRULE_forStatement = 48
	ApexParserRULE_whileStatement = 49
	ApexParserRULE_doWhileStatement = 50
	ApexParserRULE_tryStatement = 51
	ApexParserRULE_returnStatement = 52
	ApexParserRULE_throwStatement = 53
	ApexParserRULE_breakStatement = 54
	ApexParserRULE_continueStatement = 55
	ApexParserRULE_accessLevel = 56
	ApexParserRULE_insertStatement = 57
	ApexParserRULE_updateStatement = 58
	ApexParserRULE_deleteStatement = 59
	ApexParserRULE_undeleteStatement = 60
	ApexParserRULE_upsertStatement = 61
	ApexParserRULE_mergeStatement = 62
	ApexParserRULE_runAsStatement = 63
	ApexParserRULE_expressionStatement = 64
	ApexParserRULE_propertyBlock = 65
	ApexParserRULE_getter = 66
	ApexParserRULE_setter = 67
	ApexParserRULE_catchClause = 68
	ApexParserRULE_finallyBlock = 69
	ApexParserRULE_forControl = 70
	ApexParserRULE_forInit = 71
	ApexParserRULE_enhancedForControl = 72
	ApexParserRULE_forUpdate = 73
	ApexParserRULE_parExpression = 74
	ApexParserRULE_expressionList = 75
	ApexParserRULE_expression = 76
	ApexParserRULE_primary = 77
	ApexParserRULE_methodCall = 78
	ApexParserRULE_dotMethodCall = 79
	ApexParserRULE_creator = 80
	ApexParserRULE_createdName = 81
	ApexParserRULE_idCreatedNamePair = 82
	ApexParserRULE_noRest = 83
	ApexParserRULE_classCreatorRest = 84
	ApexParserRULE_arrayCreatorRest = 85
	ApexParserRULE_mapCreatorRest = 86
	ApexParserRULE_mapCreatorRestPair = 87
	ApexParserRULE_setCreatorRest = 88
	ApexParserRULE_arguments = 89
	ApexParserRULE_soqlLiteral = 90
	ApexParserRULE_query = 91
	ApexParserRULE_subQuery = 92
	ApexParserRULE_selectList = 93
	ApexParserRULE_selectEntry = 94
	ApexParserRULE_fieldName = 95
	ApexParserRULE_fromNameList = 96
	ApexParserRULE_subFieldList = 97
	ApexParserRULE_subFieldEntry = 98
	ApexParserRULE_soqlFieldsParameter = 99
	ApexParserRULE_soqlFunction = 100
	ApexParserRULE_dateFieldName = 101
	ApexParserRULE_locationValue = 102
	ApexParserRULE_coordinateValue = 103
	ApexParserRULE_typeOf = 104
	ApexParserRULE_whenClause = 105
	ApexParserRULE_elseClause = 106
	ApexParserRULE_fieldNameList = 107
	ApexParserRULE_usingScope = 108
	ApexParserRULE_whereClause = 109
	ApexParserRULE_logicalExpression = 110
	ApexParserRULE_conditionalExpression = 111
	ApexParserRULE_fieldExpression = 112
	ApexParserRULE_comparisonOperator = 113
	ApexParserRULE_value = 114
	ApexParserRULE_valueList = 115
	ApexParserRULE_signedNumber = 116
	ApexParserRULE_withClause = 117
	ApexParserRULE_filteringExpression = 118
	ApexParserRULE_dataCategorySelection = 119
	ApexParserRULE_dataCategoryName = 120
	ApexParserRULE_filteringSelector = 121
	ApexParserRULE_groupByClause = 122
	ApexParserRULE_orderByClause = 123
	ApexParserRULE_fieldOrderList = 124
	ApexParserRULE_fieldOrder = 125
	ApexParserRULE_limitClause = 126
	ApexParserRULE_offsetClause = 127
	ApexParserRULE_allRowsClause = 128
	ApexParserRULE_forClauses = 129
	ApexParserRULE_boundExpression = 130
	ApexParserRULE_dateFormula = 131
	ApexParserRULE_signedInteger = 132
	ApexParserRULE_soqlId = 133
	ApexParserRULE_soslLiteral = 134
	ApexParserRULE_soslLiteralAlt = 135
	ApexParserRULE_soslClauses = 136
	ApexParserRULE_soslWithClause = 137
	ApexParserRULE_searchGroup = 138
	ApexParserRULE_fieldSpecList = 139
	ApexParserRULE_fieldSpec = 140
	ApexParserRULE_fieldList = 141
	ApexParserRULE_updateList = 142
	ApexParserRULE_updateType = 143
	ApexParserRULE_networkList = 144
	ApexParserRULE_soslId = 145
	ApexParserRULE_id = 146
	ApexParserRULE_anyId = 147
)

// ITriggerUnitContext is an interface to support dynamic dispatch.
type ITriggerUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIGGER() antlr.TerminalNode
	AllId() []IIdContext
	Id(i int) IIdContext
	ON() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllTriggerCase() []ITriggerCaseContext
	TriggerCase(i int) ITriggerCaseContext
	RPAREN() antlr.TerminalNode
	TriggerBlock() ITriggerBlockContext
	EOF() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTriggerUnitContext differentiates from other interfaces.
	IsTriggerUnitContext()
}

type TriggerUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerUnitContext() *TriggerUnitContext {
	var p = new(TriggerUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_triggerUnit
	return p
}

func InitEmptyTriggerUnitContext(p *TriggerUnitContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_triggerUnit
}

func (*TriggerUnitContext) IsTriggerUnitContext() {}

func NewTriggerUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerUnitContext {
	var p = new(TriggerUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_triggerUnit

	return p
}

func (s *TriggerUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerUnitContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(ApexParserTRIGGER, 0)
}

func (s *TriggerUnitContext) AllId() []IIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdContext); ok {
			len++
		}
	}

	tst := make([]IIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdContext); ok {
			tst[i] = t.(IIdContext)
			i++
		}
	}

	return tst
}

func (s *TriggerUnitContext) Id(i int) IIdContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *TriggerUnitContext) ON() antlr.TerminalNode {
	return s.GetToken(ApexParserON, 0)
}

func (s *TriggerUnitContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *TriggerUnitContext) AllTriggerCase() []ITriggerCaseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITriggerCaseContext); ok {
			len++
		}
	}

	tst := make([]ITriggerCaseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITriggerCaseContext); ok {
			tst[i] = t.(ITriggerCaseContext)
			i++
		}
	}

	return tst
}

func (s *TriggerUnitContext) TriggerCase(i int) ITriggerCaseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerCaseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerCaseContext)
}

func (s *TriggerUnitContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *TriggerUnitContext) TriggerBlock() ITriggerBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerBlockContext)
}

func (s *TriggerUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(ApexParserEOF, 0)
}

func (s *TriggerUnitContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *TriggerUnitContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *TriggerUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TriggerUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterTriggerUnit(s)
	}
}

func (s *TriggerUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitTriggerUnit(s)
	}
}




func (p *ApexParser) TriggerUnit() (localctx ITriggerUnitContext) {
	localctx = NewTriggerUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ApexParserRULE_triggerUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(296)
		p.Match(ApexParserTRIGGER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(297)
		p.Id()
	}
	{
		p.SetState(298)
		p.Match(ApexParserON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(299)
		p.Id()
	}
	{
		p.SetState(300)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(301)
		p.TriggerCase()
	}
	p.SetState(306)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserCOMMA {
		{
			p.SetState(302)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(303)
			p.TriggerCase()
		}


		p.SetState(308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(309)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(310)
		p.TriggerBlock()
	}
	{
		p.SetState(311)
		p.Match(ApexParserEOF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITriggerCaseContext is an interface to support dynamic dispatch.
type ITriggerCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEFORE() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	UNDELETE() antlr.TerminalNode

	// IsTriggerCaseContext differentiates from other interfaces.
	IsTriggerCaseContext()
}

type TriggerCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerCaseContext() *TriggerCaseContext {
	var p = new(TriggerCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_triggerCase
	return p
}

func InitEmptyTriggerCaseContext(p *TriggerCaseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_triggerCase
}

func (*TriggerCaseContext) IsTriggerCaseContext() {}

func NewTriggerCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerCaseContext {
	var p = new(TriggerCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_triggerCase

	return p
}

func (s *TriggerCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerCaseContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(ApexParserBEFORE, 0)
}

func (s *TriggerCaseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(ApexParserAFTER, 0)
}

func (s *TriggerCaseContext) INSERT() antlr.TerminalNode {
	return s.GetToken(ApexParserINSERT, 0)
}

func (s *TriggerCaseContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ApexParserUPDATE, 0)
}

func (s *TriggerCaseContext) DELETE() antlr.TerminalNode {
	return s.GetToken(ApexParserDELETE, 0)
}

func (s *TriggerCaseContext) UNDELETE() antlr.TerminalNode {
	return s.GetToken(ApexParserUNDELETE, 0)
}

func (s *TriggerCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TriggerCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterTriggerCase(s)
	}
}

func (s *TriggerCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitTriggerCase(s)
	}
}




func (p *ApexParser) TriggerCase() (localctx ITriggerCaseContext) {
	localctx = NewTriggerCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ApexParserRULE_triggerCase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(313)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ApexParserAFTER || _la == ApexParserBEFORE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(314)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 105553118363904) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITriggerBlockContext is an interface to support dynamic dispatch.
type ITriggerBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllTriggerBlockMember() []ITriggerBlockMemberContext
	TriggerBlockMember(i int) ITriggerBlockMemberContext

	// IsTriggerBlockContext differentiates from other interfaces.
	IsTriggerBlockContext()
}

type TriggerBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerBlockContext() *TriggerBlockContext {
	var p = new(TriggerBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_triggerBlock
	return p
}

func InitEmptyTriggerBlockContext(p *TriggerBlockContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_triggerBlock
}

func (*TriggerBlockContext) IsTriggerBlockContext() {}

func NewTriggerBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerBlockContext {
	var p = new(TriggerBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_triggerBlock

	return p
}

func (s *TriggerBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerBlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *TriggerBlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *TriggerBlockContext) AllTriggerBlockMember() []ITriggerBlockMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITriggerBlockMemberContext); ok {
			len++
		}
	}

	tst := make([]ITriggerBlockMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITriggerBlockMemberContext); ok {
			tst[i] = t.(ITriggerBlockMemberContext)
			i++
		}
	}

	return tst
}

func (s *TriggerBlockContext) TriggerBlockMember(i int) ITriggerBlockMemberContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerBlockMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerBlockMemberContext)
}

func (s *TriggerBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TriggerBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterTriggerBlock(s)
	}
}

func (s *TriggerBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitTriggerBlock(s)
	}
}




func (p *ApexParser) TriggerBlock() (localctx ITriggerBlockContext) {
	localctx = NewTriggerBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ApexParserRULE_triggerBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(316)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -134763554) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & 27021726616393085) != 0) {
		{
			p.SetState(317)
			p.TriggerBlockMember()
		}


		p.SetState(322)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(323)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITriggerBlockMemberContext is an interface to support dynamic dispatch.
type ITriggerBlockMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TriggerMemberDeclaration() ITriggerMemberDeclarationContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext
	Statement() IStatementContext

	// IsTriggerBlockMemberContext differentiates from other interfaces.
	IsTriggerBlockMemberContext()
}

type TriggerBlockMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerBlockMemberContext() *TriggerBlockMemberContext {
	var p = new(TriggerBlockMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_triggerBlockMember
	return p
}

func InitEmptyTriggerBlockMemberContext(p *TriggerBlockMemberContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_triggerBlockMember
}

func (*TriggerBlockMemberContext) IsTriggerBlockMemberContext() {}

func NewTriggerBlockMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerBlockMemberContext {
	var p = new(TriggerBlockMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_triggerBlockMember

	return p
}

func (s *TriggerBlockMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerBlockMemberContext) TriggerMemberDeclaration() ITriggerMemberDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerMemberDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerMemberDeclarationContext)
}

func (s *TriggerBlockMemberContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *TriggerBlockMemberContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *TriggerBlockMemberContext) Statement() IStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *TriggerBlockMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerBlockMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TriggerBlockMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterTriggerBlockMember(s)
	}
}

func (s *TriggerBlockMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitTriggerBlockMember(s)
	}
}




func (p *ApexParser) TriggerBlockMember() (localctx ITriggerBlockMemberContext) {
	localctx = NewTriggerBlockMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ApexParserRULE_triggerBlockMember)
	var _alt int

	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(328)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(325)
					p.Modifier()
				}


			}
			p.SetState(330)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(331)
			p.TriggerMemberDeclaration()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(332)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeDeclaration() ITypeDeclarationContext
	EOF() antlr.TerminalNode

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_compilationUnit
	return p
}

func InitEmptyCompilationUnitContext(p *CompilationUnitContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_compilationUnit
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) TypeDeclaration() ITypeDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *CompilationUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(ApexParserEOF, 0)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CompilationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitCompilationUnit(s)
	}
}




func (p *ApexParser) CompilationUnit() (localctx ICompilationUnitContext) {
	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ApexParserRULE_compilationUnit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(335)
		p.TypeDeclaration()
	}
	{
		p.SetState(336)
		p.Match(ApexParserEOF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeDeclarationContext is an interface to support dynamic dispatch.
type ITypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassDeclaration() IClassDeclarationContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext
	EnumDeclaration() IEnumDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext

	// IsTypeDeclarationContext differentiates from other interfaces.
	IsTypeDeclarationContext()
}

type TypeDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclarationContext() *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeDeclaration
	return p
}

func InitEmptyTypeDeclarationContext(p *TypeDeclarationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeDeclaration
}

func (*TypeDeclarationContext) IsTypeDeclarationContext() {}

func NewTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_typeDeclaration

	return p
}

func (s *TypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *TypeDeclarationContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *TypeDeclarationContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *TypeDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *TypeDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *TypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterTypeDeclaration(s)
	}
}

func (s *TypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitTypeDeclaration(s)
	}
}




func (p *ApexParser) TypeDeclaration() (localctx ITypeDeclarationContext) {
	localctx = NewTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ApexParserRULE_typeDeclaration)
	var _la int

	p.SetState(359)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 28433993197297666) != 0) || _la == ApexParserATSIGN {
			{
				p.SetState(338)
				p.Modifier()
			}


			p.SetState(343)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(344)
			p.ClassDeclaration()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(348)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 28433993197297666) != 0) || _la == ApexParserATSIGN {
			{
				p.SetState(345)
				p.Modifier()
			}


			p.SetState(350)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(351)
			p.EnumDeclaration()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(355)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 28433993197297666) != 0) || _la == ApexParserATSIGN {
			{
				p.SetState(352)
				p.Modifier()
			}


			p.SetState(357)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(358)
			p.InterfaceDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	Id() IIdContext
	ClassBody() IClassBodyContext
	EXTENDS() antlr.TerminalNode
	TypeRef() ITypeRefContext
	IMPLEMENTS() antlr.TerminalNode
	TypeList() ITypeListContext

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_classDeclaration
	return p
}

func InitEmptyClassDeclarationContext(p *ClassDeclarationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_classDeclaration
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) CLASS() antlr.TerminalNode {
	return s.GetToken(ApexParserCLASS, 0)
}

func (s *ClassDeclarationContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *ClassDeclarationContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ApexParserEXTENDS, 0)
}

func (s *ClassDeclarationContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *ClassDeclarationContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(ApexParserIMPLEMENTS, 0)
}

func (s *ClassDeclarationContext) TypeList() ITypeListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}




func (p *ApexParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ApexParserRULE_classDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(361)
		p.Match(ApexParserCLASS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(362)
		p.Id()
	}
	p.SetState(365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserEXTENDS {
		{
			p.SetState(363)
			p.Match(ApexParserEXTENDS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(364)
			p.TypeRef()
		}

	}
	p.SetState(369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserIMPLEMENTS {
		{
			p.SetState(367)
			p.Match(ApexParserIMPLEMENTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(368)
			p.TypeList()
		}

	}
	{
		p.SetState(371)
		p.ClassBody()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IEnumDeclarationContext is an interface to support dynamic dispatch.
type IEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENUM() antlr.TerminalNode
	Id() IIdContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	EnumConstants() IEnumConstantsContext

	// IsEnumDeclarationContext differentiates from other interfaces.
	IsEnumDeclarationContext()
}

type EnumDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDeclarationContext() *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_enumDeclaration
	return p
}

func InitEmptyEnumDeclarationContext(p *EnumDeclarationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_enumDeclaration
}

func (*EnumDeclarationContext) IsEnumDeclarationContext() {}

func NewEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_enumDeclaration

	return p
}

func (s *EnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclarationContext) ENUM() antlr.TerminalNode {
	return s.GetToken(ApexParserENUM, 0)
}

func (s *EnumDeclarationContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *EnumDeclarationContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *EnumDeclarationContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *EnumDeclarationContext) EnumConstants() IEnumConstantsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstantsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstantsContext)
}

func (s *EnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EnumDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterEnumDeclaration(s)
	}
}

func (s *EnumDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitEnumDeclaration(s)
	}
}




func (p *ApexParser) EnumDeclaration() (localctx IEnumDeclarationContext) {
	localctx = NewEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ApexParserRULE_enumDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(373)
		p.Match(ApexParserENUM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(374)
		p.Id()
	}
	{
		p.SetState(375)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(377)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -114828269935591412) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || _la == ApexParserIdentifier {
		{
			p.SetState(376)
			p.EnumConstants()
		}

	}
	{
		p.SetState(379)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IEnumConstantsContext is an interface to support dynamic dispatch.
type IEnumConstantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllId() []IIdContext
	Id(i int) IIdContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsEnumConstantsContext differentiates from other interfaces.
	IsEnumConstantsContext()
}

type EnumConstantsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantsContext() *EnumConstantsContext {
	var p = new(EnumConstantsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_enumConstants
	return p
}

func InitEmptyEnumConstantsContext(p *EnumConstantsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_enumConstants
}

func (*EnumConstantsContext) IsEnumConstantsContext() {}

func NewEnumConstantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantsContext {
	var p = new(EnumConstantsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_enumConstants

	return p
}

func (s *EnumConstantsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantsContext) AllId() []IIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdContext); ok {
			len++
		}
	}

	tst := make([]IIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdContext); ok {
			tst[i] = t.(IIdContext)
			i++
		}
	}

	return tst
}

func (s *EnumConstantsContext) Id(i int) IIdContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *EnumConstantsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *EnumConstantsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *EnumConstantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EnumConstantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterEnumConstants(s)
	}
}

func (s *EnumConstantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitEnumConstants(s)
	}
}




func (p *ApexParser) EnumConstants() (localctx IEnumConstantsContext) {
	localctx = NewEnumConstantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ApexParserRULE_enumConstants)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(381)
		p.Id()
	}
	p.SetState(386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserCOMMA {
		{
			p.SetState(382)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(383)
			p.Id()
		}


		p.SetState(388)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	Id() IIdContext
	InterfaceBody() IInterfaceBodyContext
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_interfaceDeclaration
	return p
}

func InitEmptyInterfaceDeclarationContext(p *InterfaceDeclarationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_interfaceDeclaration
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(ApexParserINTERFACE, 0)
}

func (s *InterfaceDeclarationContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *InterfaceDeclarationContext) InterfaceBody() IInterfaceBodyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceBodyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceBodyContext)
}

func (s *InterfaceDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ApexParserEXTENDS, 0)
}

func (s *InterfaceDeclarationContext) TypeList() ITypeListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitInterfaceDeclaration(s)
	}
}




func (p *ApexParser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ApexParserRULE_interfaceDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(389)
		p.Match(ApexParserINTERFACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(390)
		p.Id()
	}
	p.SetState(393)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserEXTENDS {
		{
			p.SetState(391)
			p.Match(ApexParserEXTENDS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(392)
			p.TypeList()
		}

	}
	{
		p.SetState(395)
		p.InterfaceBody()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeRef() []ITypeRefContext
	TypeRef(i int) ITypeRefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllTypeRef() []ITypeRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeRefContext); ok {
			len++
		}
	}

	tst := make([]ITypeRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeRefContext); ok {
			tst[i] = t.(ITypeRefContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) TypeRef(i int) ITypeRefContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitTypeList(s)
	}
}




func (p *ApexParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ApexParserRULE_typeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(397)
		p.TypeRef()
	}
	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserCOMMA {
		{
			p.SetState(398)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(399)
			p.TypeRef()
		}


		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IClassBodyContext is an interface to support dynamic dispatch.
type IClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllClassBodyDeclaration() []IClassBodyDeclarationContext
	ClassBodyDeclaration(i int) IClassBodyDeclarationContext

	// IsClassBodyContext differentiates from other interfaces.
	IsClassBodyContext()
}

type ClassBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyContext() *ClassBodyContext {
	var p = new(ClassBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_classBody
	return p
}

func InitEmptyClassBodyContext(p *ClassBodyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_classBody
}

func (*ClassBodyContext) IsClassBodyContext() {}

func NewClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyContext {
	var p = new(ClassBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_classBody

	return p
}

func (s *ClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *ClassBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *ClassBodyContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassBodyDeclarationContext); ok {
			tst[i] = t.(IClassBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *ClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterClassBody(s)
	}
}

func (s *ClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitClassBody(s)
	}
}




func (p *ApexParser) ClassBody() (localctx IClassBodyContext) {
	localctx = NewClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ApexParserRULE_classBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(405)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -4770931531372466) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || ((int64((_la - 202)) & ^0x3f) == 0 && ((int64(1) << (_la - 202)) & 26388279066641) != 0) {
		{
			p.SetState(406)
			p.ClassBodyDeclaration()
		}


		p.SetState(411)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(412)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInterfaceBodyContext is an interface to support dynamic dispatch.
type IInterfaceBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllInterfaceMethodDeclaration() []IInterfaceMethodDeclarationContext
	InterfaceMethodDeclaration(i int) IInterfaceMethodDeclarationContext

	// IsInterfaceBodyContext differentiates from other interfaces.
	IsInterfaceBodyContext()
}

type InterfaceBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBodyContext() *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_interfaceBody
	return p
}

func InitEmptyInterfaceBodyContext(p *InterfaceBodyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_interfaceBody
}

func (*InterfaceBodyContext) IsInterfaceBodyContext() {}

func NewInterfaceBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_interfaceBody

	return p
}

func (s *InterfaceBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *InterfaceBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *InterfaceBodyContext) AllInterfaceMethodDeclaration() []IInterfaceMethodDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceMethodDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceMethodDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceMethodDeclarationContext); ok {
			tst[i] = t.(IInterfaceMethodDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBodyContext) InterfaceMethodDeclaration(i int) IInterfaceMethodDeclarationContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodDeclarationContext)
}

func (s *InterfaceBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InterfaceBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterInterfaceBody(s)
	}
}

func (s *InterfaceBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitInterfaceBody(s)
	}
}




func (p *ApexParser) InterfaceBody() (localctx IInterfaceBodyContext) {
	localctx = NewInterfaceBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ApexParserRULE_interfaceBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(414)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -4770931539763186) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || _la == ApexParserATSIGN || _la == ApexParserIdentifier {
		{
			p.SetState(415)
			p.InterfaceMethodDeclaration()
		}


		p.SetState(420)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(421)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IClassBodyDeclarationContext is an interface to support dynamic dispatch.
type IClassBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode
	Block() IBlockContext
	STATIC() antlr.TerminalNode
	MemberDeclaration() IMemberDeclarationContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext

	// IsClassBodyDeclarationContext differentiates from other interfaces.
	IsClassBodyDeclarationContext()
}

type ClassBodyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyDeclarationContext() *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_classBodyDeclaration
	return p
}

func InitEmptyClassBodyDeclarationContext(p *ClassBodyDeclarationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_classBodyDeclaration
}

func (*ClassBodyDeclarationContext) IsClassBodyDeclarationContext() {}

func NewClassBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_classBodyDeclaration

	return p
}

func (s *ClassBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *ClassBodyDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ClassBodyDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(ApexParserSTATIC, 0)
}

func (s *ClassBodyDeclarationContext) MemberDeclaration() IMemberDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberDeclarationContext)
}

func (s *ClassBodyDeclarationContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyDeclarationContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ClassBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ClassBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterClassBodyDeclaration(s)
	}
}

func (s *ClassBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitClassBodyDeclaration(s)
	}
}




func (p *ApexParser) ClassBodyDeclaration() (localctx IClassBodyDeclarationContext) {
	localctx = NewClassBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ApexParserRULE_classBodyDeclaration)
	var _la int

	var _alt int

	p.SetState(435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(423)
			p.Match(ApexParserSEMI)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == ApexParserSTATIC {
			{
				p.SetState(424)
				p.Match(ApexParserSTATIC)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(427)
			p.Block()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(431)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(428)
					p.Modifier()
				}


			}
			p.SetState(433)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(434)
			p.MemberDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	GLOBAL() antlr.TerminalNode
	PUBLIC() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	TRANSIENT() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	WEBSERVICE() antlr.TerminalNode
	OVERRIDE() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode
	TESTMETHOD() antlr.TerminalNode
	WITH() antlr.TerminalNode
	SHARING() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	INHERITED() antlr.TerminalNode

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_modifier
	return p
}

func InitEmptyModifierContext(p *ModifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_modifier
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ModifierContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(ApexParserGLOBAL, 0)
}

func (s *ModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(ApexParserPUBLIC, 0)
}

func (s *ModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(ApexParserPROTECTED, 0)
}

func (s *ModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(ApexParserPRIVATE, 0)
}

func (s *ModifierContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(ApexParserTRANSIENT, 0)
}

func (s *ModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(ApexParserSTATIC, 0)
}

func (s *ModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(ApexParserABSTRACT, 0)
}

func (s *ModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(ApexParserFINAL, 0)
}

func (s *ModifierContext) WEBSERVICE() antlr.TerminalNode {
	return s.GetToken(ApexParserWEBSERVICE, 0)
}

func (s *ModifierContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(ApexParserOVERRIDE, 0)
}

func (s *ModifierContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(ApexParserVIRTUAL, 0)
}

func (s *ModifierContext) TESTMETHOD() antlr.TerminalNode {
	return s.GetToken(ApexParserTESTMETHOD, 0)
}

func (s *ModifierContext) WITH() antlr.TerminalNode {
	return s.GetToken(ApexParserWITH, 0)
}

func (s *ModifierContext) SHARING() antlr.TerminalNode {
	return s.GetToken(ApexParserSHARING, 0)
}

func (s *ModifierContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(ApexParserWITHOUT, 0)
}

func (s *ModifierContext) INHERITED() antlr.TerminalNode {
	return s.GetToken(ApexParserINHERITED, 0)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitModifier(s)
	}
}




func (p *ApexParser) Modifier() (localctx IModifierContext) {
	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ApexParserRULE_modifier)
	p.SetState(456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserATSIGN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(437)
			p.Annotation()
		}


	case ApexParserGLOBAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(438)
			p.Match(ApexParserGLOBAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserPUBLIC:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(439)
			p.Match(ApexParserPUBLIC)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserPROTECTED:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(440)
			p.Match(ApexParserPROTECTED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserPRIVATE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(441)
			p.Match(ApexParserPRIVATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserTRANSIENT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(442)
			p.Match(ApexParserTRANSIENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserSTATIC:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(443)
			p.Match(ApexParserSTATIC)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserABSTRACT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(444)
			p.Match(ApexParserABSTRACT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserFINAL:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(445)
			p.Match(ApexParserFINAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserWEBSERVICE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(446)
			p.Match(ApexParserWEBSERVICE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserOVERRIDE:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(447)
			p.Match(ApexParserOVERRIDE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserVIRTUAL:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(448)
			p.Match(ApexParserVIRTUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserTESTMETHOD:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(449)
			p.Match(ApexParserTESTMETHOD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserWITH:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(450)
			p.Match(ApexParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(451)
			p.Match(ApexParserSHARING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserWITHOUT:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(452)
			p.Match(ApexParserWITHOUT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(453)
			p.Match(ApexParserSHARING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserINHERITED:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(454)
			p.Match(ApexParserINHERITED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(455)
			p.Match(ApexParserSHARING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMemberDeclarationContext is an interface to support dynamic dispatch.
type IMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MethodDeclaration() IMethodDeclarationContext
	FieldDeclaration() IFieldDeclarationContext
	ConstructorDeclaration() IConstructorDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	ClassDeclaration() IClassDeclarationContext
	EnumDeclaration() IEnumDeclarationContext
	PropertyDeclaration() IPropertyDeclarationContext

	// IsMemberDeclarationContext differentiates from other interfaces.
	IsMemberDeclarationContext()
}

type MemberDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberDeclarationContext() *MemberDeclarationContext {
	var p = new(MemberDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_memberDeclaration
	return p
}

func InitEmptyMemberDeclarationContext(p *MemberDeclarationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_memberDeclaration
}

func (*MemberDeclarationContext) IsMemberDeclarationContext() {}

func NewMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberDeclarationContext {
	var p = new(MemberDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_memberDeclaration

	return p
}

func (s *MemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberDeclarationContext) MethodDeclaration() IMethodDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *MemberDeclarationContext) FieldDeclaration() IFieldDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclarationContext)
}

func (s *MemberDeclarationContext) ConstructorDeclaration() IConstructorDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorDeclarationContext)
}

func (s *MemberDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *MemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *MemberDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *MemberDeclarationContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *MemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterMemberDeclaration(s)
	}
}

func (s *MemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitMemberDeclaration(s)
	}
}




func (p *ApexParser) MemberDeclaration() (localctx IMemberDeclarationContext) {
	localctx = NewMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ApexParserRULE_memberDeclaration)
	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(458)
			p.MethodDeclaration()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(459)
			p.FieldDeclaration()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(460)
			p.ConstructorDeclaration()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(461)
			p.InterfaceDeclaration()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(462)
			p.ClassDeclaration()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(463)
			p.EnumDeclaration()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(464)
			p.PropertyDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITriggerMemberDeclarationContext is an interface to support dynamic dispatch.
type ITriggerMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MethodDeclaration() IMethodDeclarationContext
	FieldDeclaration() IFieldDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	ClassDeclaration() IClassDeclarationContext
	EnumDeclaration() IEnumDeclarationContext
	PropertyDeclaration() IPropertyDeclarationContext

	// IsTriggerMemberDeclarationContext differentiates from other interfaces.
	IsTriggerMemberDeclarationContext()
}

type TriggerMemberDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerMemberDeclarationContext() *TriggerMemberDeclarationContext {
	var p = new(TriggerMemberDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_triggerMemberDeclaration
	return p
}

func InitEmptyTriggerMemberDeclarationContext(p *TriggerMemberDeclarationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_triggerMemberDeclaration
}

func (*TriggerMemberDeclarationContext) IsTriggerMemberDeclarationContext() {}

func NewTriggerMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerMemberDeclarationContext {
	var p = new(TriggerMemberDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_triggerMemberDeclaration

	return p
}

func (s *TriggerMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerMemberDeclarationContext) MethodDeclaration() IMethodDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *TriggerMemberDeclarationContext) FieldDeclaration() IFieldDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclarationContext)
}

func (s *TriggerMemberDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *TriggerMemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *TriggerMemberDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *TriggerMemberDeclarationContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *TriggerMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TriggerMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterTriggerMemberDeclaration(s)
	}
}

func (s *TriggerMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitTriggerMemberDeclaration(s)
	}
}




func (p *ApexParser) TriggerMemberDeclaration() (localctx ITriggerMemberDeclarationContext) {
	localctx = NewTriggerMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ApexParserRULE_triggerMemberDeclaration)
	p.SetState(473)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(467)
			p.MethodDeclaration()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(468)
			p.FieldDeclaration()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(469)
			p.InterfaceDeclaration()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(470)
			p.ClassDeclaration()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(471)
			p.EnumDeclaration()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(472)
			p.PropertyDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMethodDeclarationContext is an interface to support dynamic dispatch.
type IMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	FormalParameters() IFormalParametersContext
	TypeRef() ITypeRefContext
	VOID() antlr.TerminalNode
	Block() IBlockContext
	SEMI() antlr.TerminalNode

	// IsMethodDeclarationContext differentiates from other interfaces.
	IsMethodDeclarationContext()
}

type MethodDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDeclarationContext() *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_methodDeclaration
	return p
}

func InitEmptyMethodDeclarationContext(p *MethodDeclarationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_methodDeclaration
}

func (*MethodDeclarationContext) IsMethodDeclarationContext() {}

func NewMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_methodDeclaration

	return p
}

func (s *MethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclarationContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *MethodDeclarationContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *MethodDeclarationContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *MethodDeclarationContext) VOID() antlr.TerminalNode {
	return s.GetToken(ApexParserVOID, 0)
}

func (s *MethodDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MethodDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *MethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterMethodDeclaration(s)
	}
}

func (s *MethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitMethodDeclaration(s)
	}
}




func (p *ApexParser) MethodDeclaration() (localctx IMethodDeclarationContext) {
	localctx = NewMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ApexParserRULE_methodDeclaration)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserAFTER, ApexParserBEFORE, ApexParserGET, ApexParserINHERITED, ApexParserINSTANCEOF, ApexParserSET, ApexParserSHARING, ApexParserSWITCH, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserWHEN, ApexParserWITH, ApexParserWITHOUT, ApexParserLIST, ApexParserMAP, ApexParserSYSTEM, ApexParserUSER, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserSYSTEM_MODE, ApexParserUSER_MODE, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserDISTANCE, ApexParserGEOLOCATION, ApexParserGROUPING, ApexParserCONVERT_CURRENCY, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserN_DAYS_AGO_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserN_WEEKS_AGO_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserN_MONTHS_AGO_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserN_QUARTERS_AGO_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserN_YEARS_AGO_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserN_FISCAL_QUARTERS_AGO_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserN_FISCAL_YEARS_AGO_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserIdentifier:
		{
			p.SetState(475)
			p.TypeRef()
		}


	case ApexParserVOID:
		{
			p.SetState(476)
			p.Match(ApexParserVOID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(479)
		p.Id()
	}
	{
		p.SetState(480)
		p.FormalParameters()
	}
	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserLBRACE:
		{
			p.SetState(481)
			p.Block()
		}


	case ApexParserSEMI:
		{
			p.SetState(482)
			p.Match(ApexParserSEMI)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IConstructorDeclarationContext is an interface to support dynamic dispatch.
type IConstructorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	FormalParameters() IFormalParametersContext
	Block() IBlockContext

	// IsConstructorDeclarationContext differentiates from other interfaces.
	IsConstructorDeclarationContext()
}

type ConstructorDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorDeclarationContext() *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_constructorDeclaration
	return p
}

func InitEmptyConstructorDeclarationContext(p *ConstructorDeclarationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_constructorDeclaration
}

func (*ConstructorDeclarationContext) IsConstructorDeclarationContext() {}

func NewConstructorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_constructorDeclaration

	return p
}

func (s *ConstructorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorDeclarationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ConstructorDeclarationContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *ConstructorDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ConstructorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ConstructorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterConstructorDeclaration(s)
	}
}

func (s *ConstructorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitConstructorDeclaration(s)
	}
}




func (p *ApexParser) ConstructorDeclaration() (localctx IConstructorDeclarationContext) {
	localctx = NewConstructorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ApexParserRULE_constructorDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.QualifiedName()
	}
	{
		p.SetState(486)
		p.FormalParameters()
	}
	{
		p.SetState(487)
		p.Block()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFieldDeclarationContext is an interface to support dynamic dispatch.
type IFieldDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeRef() ITypeRefContext
	VariableDeclarators() IVariableDeclaratorsContext
	SEMI() antlr.TerminalNode

	// IsFieldDeclarationContext differentiates from other interfaces.
	IsFieldDeclarationContext()
}

type FieldDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclarationContext() *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldDeclaration
	return p
}

func InitEmptyFieldDeclarationContext(p *FieldDeclarationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldDeclaration
}

func (*FieldDeclarationContext) IsFieldDeclarationContext() {}

func NewFieldDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldDeclaration

	return p
}

func (s *FieldDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclarationContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *FieldDeclarationContext) VariableDeclarators() IVariableDeclaratorsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorsContext)
}

func (s *FieldDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *FieldDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FieldDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterFieldDeclaration(s)
	}
}

func (s *FieldDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitFieldDeclaration(s)
	}
}




func (p *ApexParser) FieldDeclaration() (localctx IFieldDeclarationContext) {
	localctx = NewFieldDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ApexParserRULE_fieldDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(489)
		p.TypeRef()
	}
	{
		p.SetState(490)
		p.VariableDeclarators()
	}
	{
		p.SetState(491)
		p.Match(ApexParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPropertyDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeRef() ITypeRefContext
	Id() IIdContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllPropertyBlock() []IPropertyBlockContext
	PropertyBlock(i int) IPropertyBlockContext

	// IsPropertyDeclarationContext differentiates from other interfaces.
	IsPropertyDeclarationContext()
}

type PropertyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDeclarationContext() *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_propertyDeclaration
	return p
}

func InitEmptyPropertyDeclarationContext(p *PropertyDeclarationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_propertyDeclaration
}

func (*PropertyDeclarationContext) IsPropertyDeclarationContext() {}

func NewPropertyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_propertyDeclaration

	return p
}

func (s *PropertyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDeclarationContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *PropertyDeclarationContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *PropertyDeclarationContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *PropertyDeclarationContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *PropertyDeclarationContext) AllPropertyBlock() []IPropertyBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyBlockContext); ok {
			len++
		}
	}

	tst := make([]IPropertyBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyBlockContext); ok {
			tst[i] = t.(IPropertyBlockContext)
			i++
		}
	}

	return tst
}

func (s *PropertyDeclarationContext) PropertyBlock(i int) IPropertyBlockContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyBlockContext)
}

func (s *PropertyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PropertyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitPropertyDeclaration(s)
	}
}




func (p *ApexParser) PropertyDeclaration() (localctx IPropertyDeclarationContext) {
	localctx = NewPropertyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ApexParserRULE_propertyDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(493)
		p.TypeRef()
	}
	{
		p.SetState(494)
		p.Id()
	}
	{
		p.SetState(495)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(499)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 28434010377232386) != 0) || _la == ApexParserATSIGN {
		{
			p.SetState(496)
			p.PropertyBlock()
		}


		p.SetState(501)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(502)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInterfaceMethodDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	FormalParameters() IFormalParametersContext
	SEMI() antlr.TerminalNode
	TypeRef() ITypeRefContext
	VOID() antlr.TerminalNode
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext

	// IsInterfaceMethodDeclarationContext differentiates from other interfaces.
	IsInterfaceMethodDeclarationContext()
}

type InterfaceMethodDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodDeclarationContext() *InterfaceMethodDeclarationContext {
	var p = new(InterfaceMethodDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_interfaceMethodDeclaration
	return p
}

func InitEmptyInterfaceMethodDeclarationContext(p *InterfaceMethodDeclarationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_interfaceMethodDeclaration
}

func (*InterfaceMethodDeclarationContext) IsInterfaceMethodDeclarationContext() {}

func NewInterfaceMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodDeclarationContext {
	var p = new(InterfaceMethodDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_interfaceMethodDeclaration

	return p
}

func (s *InterfaceMethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodDeclarationContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *InterfaceMethodDeclarationContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *InterfaceMethodDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *InterfaceMethodDeclarationContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *InterfaceMethodDeclarationContext) VOID() antlr.TerminalNode {
	return s.GetToken(ApexParserVOID, 0)
}

func (s *InterfaceMethodDeclarationContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceMethodDeclarationContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *InterfaceMethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InterfaceMethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterInterfaceMethodDeclaration(s)
	}
}

func (s *InterfaceMethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitInterfaceMethodDeclaration(s)
	}
}




func (p *ApexParser) InterfaceMethodDeclaration() (localctx IInterfaceMethodDeclarationContext) {
	localctx = NewInterfaceMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ApexParserRULE_interfaceMethodDeclaration)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(504)
				p.Modifier()
			}


		}
		p.SetState(509)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserAFTER, ApexParserBEFORE, ApexParserGET, ApexParserINHERITED, ApexParserINSTANCEOF, ApexParserSET, ApexParserSHARING, ApexParserSWITCH, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserWHEN, ApexParserWITH, ApexParserWITHOUT, ApexParserLIST, ApexParserMAP, ApexParserSYSTEM, ApexParserUSER, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserSYSTEM_MODE, ApexParserUSER_MODE, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserDISTANCE, ApexParserGEOLOCATION, ApexParserGROUPING, ApexParserCONVERT_CURRENCY, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserN_DAYS_AGO_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserN_WEEKS_AGO_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserN_MONTHS_AGO_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserN_QUARTERS_AGO_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserN_YEARS_AGO_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserN_FISCAL_QUARTERS_AGO_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserN_FISCAL_YEARS_AGO_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserIdentifier:
		{
			p.SetState(510)
			p.TypeRef()
		}


	case ApexParserVOID:
		{
			p.SetState(511)
			p.Match(ApexParserVOID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(514)
		p.Id()
	}
	{
		p.SetState(515)
		p.FormalParameters()
	}
	{
		p.SetState(516)
		p.Match(ApexParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IVariableDeclaratorsContext is an interface to support dynamic dispatch.
type IVariableDeclaratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDeclarator() []IVariableDeclaratorContext
	VariableDeclarator(i int) IVariableDeclaratorContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVariableDeclaratorsContext differentiates from other interfaces.
	IsVariableDeclaratorsContext()
}

type VariableDeclaratorsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorsContext() *VariableDeclaratorsContext {
	var p = new(VariableDeclaratorsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_variableDeclarators
	return p
}

func InitEmptyVariableDeclaratorsContext(p *VariableDeclaratorsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_variableDeclarators
}

func (*VariableDeclaratorsContext) IsVariableDeclaratorsContext() {}

func NewVariableDeclaratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorsContext {
	var p = new(VariableDeclaratorsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_variableDeclarators

	return p
}

func (s *VariableDeclaratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorsContext) AllVariableDeclarator() []IVariableDeclaratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclaratorContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclaratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclaratorContext); ok {
			tst[i] = t.(IVariableDeclaratorContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclaratorsContext) VariableDeclarator(i int) IVariableDeclaratorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorContext)
}

func (s *VariableDeclaratorsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *VariableDeclaratorsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *VariableDeclaratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VariableDeclaratorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterVariableDeclarators(s)
	}
}

func (s *VariableDeclaratorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitVariableDeclarators(s)
	}
}




func (p *ApexParser) VariableDeclarators() (localctx IVariableDeclaratorsContext) {
	localctx = NewVariableDeclaratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ApexParserRULE_variableDeclarators)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(518)
		p.VariableDeclarator()
	}
	p.SetState(523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserCOMMA {
		{
			p.SetState(519)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(520)
			p.VariableDeclarator()
		}


		p.SetState(525)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IVariableDeclaratorContext is an interface to support dynamic dispatch.
type IVariableDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsVariableDeclaratorContext differentiates from other interfaces.
	IsVariableDeclaratorContext()
}

type VariableDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorContext() *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_variableDeclarator
	return p
}

func InitEmptyVariableDeclaratorContext(p *VariableDeclaratorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_variableDeclarator
}

func (*VariableDeclaratorContext) IsVariableDeclaratorContext() {}

func NewVariableDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_variableDeclarator

	return p
}

func (s *VariableDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *VariableDeclaratorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserASSIGN, 0)
}

func (s *VariableDeclaratorContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VariableDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterVariableDeclarator(s)
	}
}

func (s *VariableDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitVariableDeclarator(s)
	}
}




func (p *ApexParser) VariableDeclarator() (localctx IVariableDeclaratorContext) {
	localctx = NewVariableDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ApexParserRULE_variableDeclarator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(526)
		p.Id()
	}
	p.SetState(529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserASSIGN {
		{
			p.SetState(527)
			p.Match(ApexParserASSIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(528)
			p.expression(0)
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IArrayInitializerContext is an interface to support dynamic dispatch.
type IArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArrayInitializerContext differentiates from other interfaces.
	IsArrayInitializerContext()
}

type ArrayInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayInitializerContext() *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_arrayInitializer
	return p
}

func InitEmptyArrayInitializerContext(p *ArrayInitializerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_arrayInitializer
}

func (*ArrayInitializerContext) IsArrayInitializerContext() {}

func NewArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_arrayInitializer

	return p
}

func (s *ArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *ArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *ArrayInitializerContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayInitializerContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayInitializerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *ArrayInitializerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *ArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterArrayInitializer(s)
	}
}

func (s *ArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitArrayInitializer(s)
	}
}




func (p *ApexParser) ArrayInitializer() (localctx IArrayInitializerContext) {
	localctx = NewArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ApexParserRULE_arrayInitializer)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(531)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(543)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -6177691874033652) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & 18014527361651069) != 0) {
		{
			p.SetState(532)
			p.expression(0)
		}
		p.SetState(537)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(533)
					p.Match(ApexParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(534)
					p.expression(0)
				}


			}
			p.SetState(539)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == ApexParserCOMMA {
			{
				p.SetState(540)
				p.Match(ApexParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}

	}
	{
		p.SetState(545)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeRefContext is an interface to support dynamic dispatch.
type ITypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeName() []ITypeNameContext
	TypeName(i int) ITypeNameContext
	ArraySubscripts() IArraySubscriptsContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsTypeRefContext differentiates from other interfaces.
	IsTypeRefContext()
}

type TypeRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeRefContext() *TypeRefContext {
	var p = new(TypeRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeRef
	return p
}

func InitEmptyTypeRefContext(p *TypeRefContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeRef
}

func (*TypeRefContext) IsTypeRefContext() {}

func NewTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeRefContext {
	var p = new(TypeRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_typeRef

	return p
}

func (s *TypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeRefContext) AllTypeName() []ITypeNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeNameContext); ok {
			len++
		}
	}

	tst := make([]ITypeNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeNameContext); ok {
			tst[i] = t.(ITypeNameContext)
			i++
		}
	}

	return tst
}

func (s *TypeRefContext) TypeName(i int) ITypeNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *TypeRefContext) ArraySubscripts() IArraySubscriptsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArraySubscriptsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArraySubscriptsContext)
}

func (s *TypeRefContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ApexParserDOT)
}

func (s *TypeRefContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, i)
}

func (s *TypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterTypeRef(s)
	}
}

func (s *TypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitTypeRef(s)
	}
}




func (p *ApexParser) TypeRef() (localctx ITypeRefContext) {
	localctx = NewTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ApexParserRULE_typeRef)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(547)
		p.TypeName()
	}
	p.SetState(552)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(548)
				p.Match(ApexParserDOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(549)
				p.TypeName()
			}


		}
		p.SetState(554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(555)
		p.ArraySubscripts()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IArraySubscriptsContext is an interface to support dynamic dispatch.
type IArraySubscriptsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLBRACK() []antlr.TerminalNode
	LBRACK(i int) antlr.TerminalNode
	AllRBRACK() []antlr.TerminalNode
	RBRACK(i int) antlr.TerminalNode

	// IsArraySubscriptsContext differentiates from other interfaces.
	IsArraySubscriptsContext()
}

type ArraySubscriptsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArraySubscriptsContext() *ArraySubscriptsContext {
	var p = new(ArraySubscriptsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_arraySubscripts
	return p
}

func InitEmptyArraySubscriptsContext(p *ArraySubscriptsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_arraySubscripts
}

func (*ArraySubscriptsContext) IsArraySubscriptsContext() {}

func NewArraySubscriptsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArraySubscriptsContext {
	var p = new(ArraySubscriptsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_arraySubscripts

	return p
}

func (s *ArraySubscriptsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArraySubscriptsContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(ApexParserLBRACK)
}

func (s *ArraySubscriptsContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACK, i)
}

func (s *ArraySubscriptsContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(ApexParserRBRACK)
}

func (s *ArraySubscriptsContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACK, i)
}

func (s *ArraySubscriptsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArraySubscriptsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArraySubscriptsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterArraySubscripts(s)
	}
}

func (s *ArraySubscriptsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitArraySubscripts(s)
	}
}




func (p *ApexParser) ArraySubscripts() (localctx IArraySubscriptsContext) {
	localctx = NewArraySubscriptsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ApexParserRULE_arraySubscripts)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(557)
				p.Match(ApexParserLBRACK)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(558)
				p.Match(ApexParserRBRACK)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		}
		p.SetState(563)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIST() antlr.TerminalNode
	TypeArguments() ITypeArgumentsContext
	SET() antlr.TerminalNode
	MAP() antlr.TerminalNode
	Id() IIdContext

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeName
	return p
}

func InitEmptyTypeNameContext(p *TypeNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeName
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) LIST() antlr.TerminalNode {
	return s.GetToken(ApexParserLIST, 0)
}

func (s *TypeNameContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *TypeNameContext) SET() antlr.TerminalNode {
	return s.GetToken(ApexParserSET, 0)
}

func (s *TypeNameContext) MAP() antlr.TerminalNode {
	return s.GetToken(ApexParserMAP, 0)
}

func (s *TypeNameContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitTypeName(s)
	}
}




func (p *ApexParser) TypeName() (localctx ITypeNameContext) {
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ApexParserRULE_typeName)
	p.SetState(580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(564)
			p.Match(ApexParserLIST)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(566)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(565)
				p.TypeArguments()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(568)
			p.Match(ApexParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(570)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(569)
				p.TypeArguments()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(572)
			p.Match(ApexParserMAP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(574)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(573)
				p.TypeArguments()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(576)
			p.Id()
		}
		p.SetState(578)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(577)
				p.TypeArguments()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	TypeList() ITypeListContext
	GT() antlr.TerminalNode

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeArguments
	return p
}

func InitEmptyTypeArgumentsContext(p *TypeArgumentsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeArguments
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) LT() antlr.TerminalNode {
	return s.GetToken(ApexParserLT, 0)
}

func (s *TypeArgumentsContext) TypeList() ITypeListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeArgumentsContext) GT() antlr.TerminalNode {
	return s.GetToken(ApexParserGT, 0)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitTypeArguments(s)
	}
}




func (p *ApexParser) TypeArguments() (localctx ITypeArgumentsContext) {
	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ApexParserRULE_typeArguments)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(582)
		p.Match(ApexParserLT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(583)
		p.TypeList()
	}
	{
		p.SetState(584)
		p.Match(ApexParserGT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFormalParametersContext is an interface to support dynamic dispatch.
type IFormalParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsFormalParametersContext differentiates from other interfaces.
	IsFormalParametersContext()
}

type FormalParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParametersContext() *FormalParametersContext {
	var p = new(FormalParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_formalParameters
	return p
}

func InitEmptyFormalParametersContext(p *FormalParametersContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_formalParameters
}

func (*FormalParametersContext) IsFormalParametersContext() {}

func NewFormalParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParametersContext {
	var p = new(FormalParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_formalParameters

	return p
}

func (s *FormalParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *FormalParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *FormalParametersContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FormalParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FormalParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterFormalParameters(s)
	}
}

func (s *FormalParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitFormalParameters(s)
	}
}




func (p *ApexParser) FormalParameters() (localctx IFormalParametersContext) {
	localctx = NewFormalParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ApexParserRULE_formalParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(586)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -5333881493184498) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || _la == ApexParserATSIGN || _la == ApexParserIdentifier {
		{
			p.SetState(587)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(590)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFormalParameter() []IFormalParameterContext
	FormalParameter(i int) IFormalParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_formalParameterList
	return p
}

func InitEmptyFormalParameterListContext(p *FormalParameterListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_formalParameterList
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameter() []IFormalParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterContext); ok {
			tst[i] = t.(IFormalParameterContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameter(i int) IFormalParameterContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterContext)
}

func (s *FormalParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *FormalParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}




func (p *ApexParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ApexParserRULE_formalParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(592)
		p.FormalParameter()
	}
	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserCOMMA {
		{
			p.SetState(593)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(594)
			p.FormalParameter()
		}


		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFormalParameterContext is an interface to support dynamic dispatch.
type IFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeRef() ITypeRefContext
	Id() IIdContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext

	// IsFormalParameterContext differentiates from other interfaces.
	IsFormalParameterContext()
}

type FormalParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterContext() *FormalParameterContext {
	var p = new(FormalParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_formalParameter
	return p
}

func InitEmptyFormalParameterContext(p *FormalParameterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_formalParameter
}

func (*FormalParameterContext) IsFormalParameterContext() {}

func NewFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterContext {
	var p = new(FormalParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_formalParameter

	return p
}

func (s *FormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *FormalParameterContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *FormalParameterContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *FormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterFormalParameter(s)
	}
}

func (s *FormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitFormalParameter(s)
	}
}




func (p *ApexParser) FormalParameter() (localctx IFormalParameterContext) {
	localctx = NewFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ApexParserRULE_formalParameter)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(600)
				p.Modifier()
			}


		}
		p.SetState(605)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(606)
		p.TypeRef()
	}
	{
		p.SetState(607)
		p.Id()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllId() []IIdContext
	Id(i int) IIdContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_qualifiedName
	return p
}

func InitEmptyQualifiedNameContext(p *QualifiedNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_qualifiedName
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllId() []IIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdContext); ok {
			len++
		}
	}

	tst := make([]IIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdContext); ok {
			tst[i] = t.(IIdContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) Id(i int) IIdContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *QualifiedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ApexParserDOT)
}

func (s *QualifiedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}




func (p *ApexParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ApexParserRULE_qualifiedName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(609)
		p.Id()
	}
	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserDOT {
		{
			p.SetState(610)
			p.Match(ApexParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(611)
			p.Id()
		}


		p.SetState(616)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntegerLiteral() antlr.TerminalNode
	LongLiteral() antlr.TerminalNode
	NumberLiteral() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	BooleanLiteral() antlr.TerminalNode
	NULL() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegerLiteral, 0)
}

func (s *LiteralContext) LongLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserLongLiteral, 0)
}

func (s *LiteralContext) NumberLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserNumberLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserStringLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserBooleanLiteral, 0)
}

func (s *LiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(ApexParserNULL, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}




func (p *ApexParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ApexParserRULE_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ApexParserNULL || ((int64((_la - 194)) & ^0x3f) == 0 && ((int64(1) << (_la - 194)) & 31) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ATSIGN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ElementValuePairs() IElementValuePairsContext
	ElementValue() IElementValueContext

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_annotation
	return p
}

func InitEmptyAnnotationContext(p *AnnotationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_annotation
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserATSIGN, 0)
}

func (s *AnnotationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AnnotationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *AnnotationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *AnnotationContext) ElementValuePairs() IElementValuePairsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairsContext)
}

func (s *AnnotationContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}




func (p *ApexParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ApexParserRULE_annotation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(619)
		p.Match(ApexParserATSIGN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(620)
		p.QualifiedName()
	}
	p.SetState(627)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserLPAREN {
		{
			p.SetState(621)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(624)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(622)
				p.ElementValuePairs()
			}

			} else if p.HasError() { // JIM
				goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(623)
				p.ElementValue()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(626)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IElementValuePairsContext is an interface to support dynamic dispatch.
type IElementValuePairsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllElementValuePair() []IElementValuePairContext
	ElementValuePair(i int) IElementValuePairContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementValuePairsContext differentiates from other interfaces.
	IsElementValuePairsContext()
}

type ElementValuePairsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairsContext() *ElementValuePairsContext {
	var p = new(ElementValuePairsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elementValuePairs
	return p
}

func InitEmptyElementValuePairsContext(p *ElementValuePairsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elementValuePairs
}

func (*ElementValuePairsContext) IsElementValuePairsContext() {}

func NewElementValuePairsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairsContext {
	var p = new(ElementValuePairsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_elementValuePairs

	return p
}

func (s *ElementValuePairsContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairsContext) AllElementValuePair() []IElementValuePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementValuePairContext); ok {
			len++
		}
	}

	tst := make([]IElementValuePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementValuePairContext); ok {
			tst[i] = t.(IElementValuePairContext)
			i++
		}
	}

	return tst
}

func (s *ElementValuePairsContext) ElementValuePair(i int) IElementValuePairContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairContext)
}

func (s *ElementValuePairsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *ElementValuePairsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *ElementValuePairsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ElementValuePairsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterElementValuePairs(s)
	}
}

func (s *ElementValuePairsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitElementValuePairs(s)
	}
}




func (p *ApexParser) ElementValuePairs() (localctx IElementValuePairsContext) {
	localctx = NewElementValuePairsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ApexParserRULE_elementValuePairs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(629)
		p.ElementValuePair()
	}
	p.SetState(636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -114828269935591412) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || _la == ApexParserCOMMA || _la == ApexParserIdentifier {
		p.SetState(631)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == ApexParserCOMMA {
			{
				p.SetState(630)
				p.Match(ApexParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(633)
			p.ElementValuePair()
		}


		p.SetState(638)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IElementValuePairContext is an interface to support dynamic dispatch.
type IElementValuePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	ASSIGN() antlr.TerminalNode
	ElementValue() IElementValueContext

	// IsElementValuePairContext differentiates from other interfaces.
	IsElementValuePairContext()
}

type ElementValuePairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairContext() *ElementValuePairContext {
	var p = new(ElementValuePairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elementValuePair
	return p
}

func InitEmptyElementValuePairContext(p *ElementValuePairContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elementValuePair
}

func (*ElementValuePairContext) IsElementValuePairContext() {}

func NewElementValuePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairContext {
	var p = new(ElementValuePairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_elementValuePair

	return p
}

func (s *ElementValuePairContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *ElementValuePairContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserASSIGN, 0)
}

func (s *ElementValuePairContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValuePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ElementValuePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterElementValuePair(s)
	}
}

func (s *ElementValuePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitElementValuePair(s)
	}
}




func (p *ApexParser) ElementValuePair() (localctx IElementValuePairContext) {
	localctx = NewElementValuePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ApexParserRULE_elementValuePair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(639)
		p.Id()
	}
	{
		p.SetState(640)
		p.Match(ApexParserASSIGN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(641)
		p.ElementValue()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IElementValueContext is an interface to support dynamic dispatch.
type IElementValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Annotation() IAnnotationContext
	ElementValueArrayInitializer() IElementValueArrayInitializerContext

	// IsElementValueContext differentiates from other interfaces.
	IsElementValueContext()
}

type ElementValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueContext() *ElementValueContext {
	var p = new(ElementValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elementValue
	return p
}

func InitEmptyElementValueContext(p *ElementValueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elementValue
}

func (*ElementValueContext) IsElementValueContext() {}

func NewElementValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueContext {
	var p = new(ElementValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_elementValue

	return p
}

func (s *ElementValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElementValueContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ElementValueContext) ElementValueArrayInitializer() IElementValueArrayInitializerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueArrayInitializerContext)
}

func (s *ElementValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ElementValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterElementValue(s)
	}
}

func (s *ElementValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitElementValue(s)
	}
}




func (p *ApexParser) ElementValue() (localctx IElementValueContext) {
	localctx = NewElementValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ApexParserRULE_elementValue)
	p.SetState(646)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserAFTER, ApexParserBEFORE, ApexParserGET, ApexParserINHERITED, ApexParserINSTANCEOF, ApexParserNEW, ApexParserNULL, ApexParserSET, ApexParserSHARING, ApexParserSUPER, ApexParserSWITCH, ApexParserTHIS, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserVOID, ApexParserWHEN, ApexParserWITH, ApexParserWITHOUT, ApexParserLIST, ApexParserMAP, ApexParserSYSTEM, ApexParserUSER, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserSYSTEM_MODE, ApexParserUSER_MODE, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserDISTANCE, ApexParserGEOLOCATION, ApexParserGROUPING, ApexParserCONVERT_CURRENCY, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserN_DAYS_AGO_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserN_WEEKS_AGO_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserN_MONTHS_AGO_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserN_QUARTERS_AGO_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserN_YEARS_AGO_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserN_FISCAL_QUARTERS_AGO_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserN_FISCAL_YEARS_AGO_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserFindLiteral, ApexParserIntegerLiteral, ApexParserLongLiteral, ApexParserNumberLiteral, ApexParserBooleanLiteral, ApexParserStringLiteral, ApexParserLPAREN, ApexParserLBRACK, ApexParserBANG, ApexParserTILDE, ApexParserINC, ApexParserDEC, ApexParserADD, ApexParserSUB, ApexParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(643)
			p.expression(0)
		}


	case ApexParserATSIGN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(644)
			p.Annotation()
		}


	case ApexParserLBRACE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(645)
			p.ElementValueArrayInitializer()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IElementValueArrayInitializerContext is an interface to support dynamic dispatch.
type IElementValueArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllElementValue() []IElementValueContext
	ElementValue(i int) IElementValueContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementValueArrayInitializerContext differentiates from other interfaces.
	IsElementValueArrayInitializerContext()
}

type ElementValueArrayInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueArrayInitializerContext() *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elementValueArrayInitializer
	return p
}

func InitEmptyElementValueArrayInitializerContext(p *ElementValueArrayInitializerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elementValueArrayInitializer
}

func (*ElementValueArrayInitializerContext) IsElementValueArrayInitializerContext() {}

func NewElementValueArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_elementValueArrayInitializer

	return p
}

func (s *ElementValueArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *ElementValueArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *ElementValueArrayInitializerContext) AllElementValue() []IElementValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementValueContext); ok {
			len++
		}
	}

	tst := make([]IElementValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementValueContext); ok {
			tst[i] = t.(IElementValueContext)
			i++
		}
	}

	return tst
}

func (s *ElementValueArrayInitializerContext) ElementValue(i int) IElementValueContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValueArrayInitializerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *ElementValueArrayInitializerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *ElementValueArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ElementValueArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterElementValueArrayInitializer(s)
	}
}

func (s *ElementValueArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitElementValueArrayInitializer(s)
	}
}




func (p *ApexParser) ElementValueArrayInitializer() (localctx IElementValueArrayInitializerContext) {
	localctx = NewElementValueArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ApexParserRULE_elementValueArrayInitializer)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(648)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -6177691874033652) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & 27021726616393085) != 0) {
		{
			p.SetState(649)
			p.ElementValue()
		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(650)
					p.Match(ApexParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(651)
					p.ElementValue()
				}


			}
			p.SetState(656)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	p.SetState(660)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserCOMMA {
		{
			p.SetState(659)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(662)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *BlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *BlockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitBlock(s)
	}
}




func (p *ApexParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ApexParserRULE_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(664)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(668)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -143154274) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & 27021726616393085) != 0) {
		{
			p.SetState(665)
			p.Statement()
		}


		p.SetState(670)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(671)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILocalVariableDeclarationStatementContext is an interface to support dynamic dispatch.
type ILocalVariableDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LocalVariableDeclaration() ILocalVariableDeclarationContext
	SEMI() antlr.TerminalNode

	// IsLocalVariableDeclarationStatementContext differentiates from other interfaces.
	IsLocalVariableDeclarationStatementContext()
}

type LocalVariableDeclarationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableDeclarationStatementContext() *LocalVariableDeclarationStatementContext {
	var p = new(LocalVariableDeclarationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_localVariableDeclarationStatement
	return p
}

func InitEmptyLocalVariableDeclarationStatementContext(p *LocalVariableDeclarationStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_localVariableDeclarationStatement
}

func (*LocalVariableDeclarationStatementContext) IsLocalVariableDeclarationStatementContext() {}

func NewLocalVariableDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableDeclarationStatementContext {
	var p = new(LocalVariableDeclarationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_localVariableDeclarationStatement

	return p
}

func (s *LocalVariableDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableDeclarationStatementContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *LocalVariableDeclarationStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *LocalVariableDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LocalVariableDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterLocalVariableDeclarationStatement(s)
	}
}

func (s *LocalVariableDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitLocalVariableDeclarationStatement(s)
	}
}




func (p *ApexParser) LocalVariableDeclarationStatement() (localctx ILocalVariableDeclarationStatementContext) {
	localctx = NewLocalVariableDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ApexParserRULE_localVariableDeclarationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(673)
		p.LocalVariableDeclaration()
	}
	{
		p.SetState(674)
		p.Match(ApexParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILocalVariableDeclarationContext is an interface to support dynamic dispatch.
type ILocalVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeRef() ITypeRefContext
	VariableDeclarators() IVariableDeclaratorsContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext

	// IsLocalVariableDeclarationContext differentiates from other interfaces.
	IsLocalVariableDeclarationContext()
}

type LocalVariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableDeclarationContext() *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_localVariableDeclaration
	return p
}

func InitEmptyLocalVariableDeclarationContext(p *LocalVariableDeclarationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_localVariableDeclaration
}

func (*LocalVariableDeclarationContext) IsLocalVariableDeclarationContext() {}

func NewLocalVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_localVariableDeclaration

	return p
}

func (s *LocalVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableDeclarationContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *LocalVariableDeclarationContext) VariableDeclarators() IVariableDeclaratorsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorsContext)
}

func (s *LocalVariableDeclarationContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *LocalVariableDeclarationContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *LocalVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LocalVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterLocalVariableDeclaration(s)
	}
}

func (s *LocalVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitLocalVariableDeclaration(s)
	}
}




func (p *ApexParser) LocalVariableDeclaration() (localctx ILocalVariableDeclarationContext) {
	localctx = NewLocalVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ApexParserRULE_localVariableDeclaration)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(679)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(676)
				p.Modifier()
			}


		}
		p.SetState(681)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(682)
		p.TypeRef()
	}
	{
		p.SetState(683)
		p.VariableDeclarators()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	IfStatement() IIfStatementContext
	SwitchStatement() ISwitchStatementContext
	ForStatement() IForStatementContext
	WhileStatement() IWhileStatementContext
	DoWhileStatement() IDoWhileStatementContext
	TryStatement() ITryStatementContext
	ReturnStatement() IReturnStatementContext
	ThrowStatement() IThrowStatementContext
	BreakStatement() IBreakStatementContext
	ContinueStatement() IContinueStatementContext
	InsertStatement() IInsertStatementContext
	UpdateStatement() IUpdateStatementContext
	DeleteStatement() IDeleteStatementContext
	UndeleteStatement() IUndeleteStatementContext
	UpsertStatement() IUpsertStatementContext
	MergeStatement() IMergeStatementContext
	RunAsStatement() IRunAsStatementContext
	LocalVariableDeclarationStatement() ILocalVariableDeclarationStatementContext
	ExpressionStatement() IExpressionStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) SwitchStatement() ISwitchStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) DoWhileStatement() IDoWhileStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoWhileStatementContext)
}

func (s *StatementContext) TryStatement() ITryStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *StatementContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *StatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *StatementContext) UndeleteStatement() IUndeleteStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUndeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUndeleteStatementContext)
}

func (s *StatementContext) UpsertStatement() IUpsertStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpsertStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpsertStatementContext)
}

func (s *StatementContext) MergeStatement() IMergeStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeStatementContext)
}

func (s *StatementContext) RunAsStatement() IRunAsStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRunAsStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRunAsStatementContext)
}

func (s *StatementContext) LocalVariableDeclarationStatement() ILocalVariableDeclarationStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationStatementContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitStatement(s)
	}
}




func (p *ApexParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ApexParserRULE_statement)
	p.SetState(705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(685)
			p.Block()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(686)
			p.IfStatement()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(687)
			p.SwitchStatement()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(688)
			p.ForStatement()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(689)
			p.WhileStatement()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(690)
			p.DoWhileStatement()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(691)
			p.TryStatement()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(692)
			p.ReturnStatement()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(693)
			p.ThrowStatement()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(694)
			p.BreakStatement()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(695)
			p.ContinueStatement()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(696)
			p.InsertStatement()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(697)
			p.UpdateStatement()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(698)
			p.DeleteStatement()
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(699)
			p.UndeleteStatement()
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(700)
			p.UpsertStatement()
		}


	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(701)
			p.MergeStatement()
		}


	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(702)
			p.RunAsStatement()
		}


	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(703)
			p.LocalVariableDeclarationStatement()
		}


	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(704)
			p.ExpressionStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	ParExpression() IParExpressionContext
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	ELSE() antlr.TerminalNode

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(ApexParserIF, 0)
}

func (s *IfStatementContext) ParExpression() IParExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ApexParserELSE, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}




func (p *ApexParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ApexParserRULE_ifStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(707)
		p.Match(ApexParserIF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(708)
		p.ParExpression()
	}
	{
		p.SetState(709)
		p.Statement()
	}
	p.SetState(712)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(710)
			p.Match(ApexParserELSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(711)
			p.Statement()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWITCH() antlr.TerminalNode
	ON() antlr.TerminalNode
	Expression() IExpressionContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllWhenControl() []IWhenControlContext
	WhenControl(i int) IWhenControlContext

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_switchStatement
	return p
}

func InitEmptySwitchStatementContext(p *SwitchStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_switchStatement
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(ApexParserSWITCH, 0)
}

func (s *SwitchStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(ApexParserON, 0)
}

func (s *SwitchStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchStatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *SwitchStatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *SwitchStatementContext) AllWhenControl() []IWhenControlContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenControlContext); ok {
			len++
		}
	}

	tst := make([]IWhenControlContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenControlContext); ok {
			tst[i] = t.(IWhenControlContext)
			i++
		}
	}

	return tst
}

func (s *SwitchStatementContext) WhenControl(i int) IWhenControlContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenControlContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenControlContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSwitchStatement(s)
	}
}




func (p *ApexParser) SwitchStatement() (localctx ISwitchStatementContext) {
	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ApexParserRULE_switchStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(714)
		p.Match(ApexParserSWITCH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(715)
		p.Match(ApexParserON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(716)
		p.expression(0)
	}
	{
		p.SetState(717)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == ApexParserWHEN {
		{
			p.SetState(718)
			p.WhenControl()
		}


		p.SetState(721)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(723)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhenControlContext is an interface to support dynamic dispatch.
type IWhenControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN() antlr.TerminalNode
	WhenValue() IWhenValueContext
	Block() IBlockContext

	// IsWhenControlContext differentiates from other interfaces.
	IsWhenControlContext()
}

type WhenControlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenControlContext() *WhenControlContext {
	var p = new(WhenControlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whenControl
	return p
}

func InitEmptyWhenControlContext(p *WhenControlContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whenControl
}

func (*WhenControlContext) IsWhenControlContext() {}

func NewWhenControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenControlContext {
	var p = new(WhenControlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_whenControl

	return p
}

func (s *WhenControlContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenControlContext) WHEN() antlr.TerminalNode {
	return s.GetToken(ApexParserWHEN, 0)
}

func (s *WhenControlContext) WhenValue() IWhenValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenValueContext)
}

func (s *WhenControlContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *WhenControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WhenControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterWhenControl(s)
	}
}

func (s *WhenControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitWhenControl(s)
	}
}




func (p *ApexParser) WhenControl() (localctx IWhenControlContext) {
	localctx = NewWhenControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ApexParserRULE_whenControl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(725)
		p.Match(ApexParserWHEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(726)
		p.WhenValue()
	}
	{
		p.SetState(727)
		p.Block()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhenValueContext is an interface to support dynamic dispatch.
type IWhenValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSE() antlr.TerminalNode
	AllWhenLiteral() []IWhenLiteralContext
	WhenLiteral(i int) IWhenLiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllId() []IIdContext
	Id(i int) IIdContext

	// IsWhenValueContext differentiates from other interfaces.
	IsWhenValueContext()
}

type WhenValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenValueContext() *WhenValueContext {
	var p = new(WhenValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whenValue
	return p
}

func InitEmptyWhenValueContext(p *WhenValueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whenValue
}

func (*WhenValueContext) IsWhenValueContext() {}

func NewWhenValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenValueContext {
	var p = new(WhenValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_whenValue

	return p
}

func (s *WhenValueContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenValueContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ApexParserELSE, 0)
}

func (s *WhenValueContext) AllWhenLiteral() []IWhenLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenLiteralContext); ok {
			len++
		}
	}

	tst := make([]IWhenLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenLiteralContext); ok {
			tst[i] = t.(IWhenLiteralContext)
			i++
		}
	}

	return tst
}

func (s *WhenValueContext) WhenLiteral(i int) IWhenLiteralContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenLiteralContext)
}

func (s *WhenValueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *WhenValueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *WhenValueContext) AllId() []IIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdContext); ok {
			len++
		}
	}

	tst := make([]IIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdContext); ok {
			tst[i] = t.(IIdContext)
			i++
		}
	}

	return tst
}

func (s *WhenValueContext) Id(i int) IIdContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *WhenValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WhenValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterWhenValue(s)
	}
}

func (s *WhenValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitWhenValue(s)
	}
}




func (p *ApexParser) WhenValue() (localctx IWhenValueContext) {
	localctx = NewWhenValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ApexParserRULE_whenValue)
	var _la int

	p.SetState(741)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(729)
			p.Match(ApexParserELSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(730)
			p.WhenLiteral()
		}
		p.SetState(735)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == ApexParserCOMMA {
			{
				p.SetState(731)
				p.Match(ApexParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(732)
				p.WhenLiteral()
			}


			p.SetState(737)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(738)
			p.Id()
		}
		{
			p.SetState(739)
			p.Id()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhenLiteralContext is an interface to support dynamic dispatch.
type IWhenLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntegerLiteral() antlr.TerminalNode
	AllSUB() []antlr.TerminalNode
	SUB(i int) antlr.TerminalNode
	AllADD() []antlr.TerminalNode
	ADD(i int) antlr.TerminalNode
	LongLiteral() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	NULL() antlr.TerminalNode
	Id() IIdContext
	LPAREN() antlr.TerminalNode
	WhenLiteral() IWhenLiteralContext
	RPAREN() antlr.TerminalNode

	// IsWhenLiteralContext differentiates from other interfaces.
	IsWhenLiteralContext()
}

type WhenLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenLiteralContext() *WhenLiteralContext {
	var p = new(WhenLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whenLiteral
	return p
}

func InitEmptyWhenLiteralContext(p *WhenLiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whenLiteral
}

func (*WhenLiteralContext) IsWhenLiteralContext() {}

func NewWhenLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenLiteralContext {
	var p = new(WhenLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_whenLiteral

	return p
}

func (s *WhenLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenLiteralContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegerLiteral, 0)
}

func (s *WhenLiteralContext) AllSUB() []antlr.TerminalNode {
	return s.GetTokens(ApexParserSUB)
}

func (s *WhenLiteralContext) SUB(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserSUB, i)
}

func (s *WhenLiteralContext) AllADD() []antlr.TerminalNode {
	return s.GetTokens(ApexParserADD)
}

func (s *WhenLiteralContext) ADD(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserADD, i)
}

func (s *WhenLiteralContext) LongLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserLongLiteral, 0)
}

func (s *WhenLiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserStringLiteral, 0)
}

func (s *WhenLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(ApexParserNULL, 0)
}

func (s *WhenLiteralContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *WhenLiteralContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *WhenLiteralContext) WhenLiteral() IWhenLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenLiteralContext)
}

func (s *WhenLiteralContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *WhenLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WhenLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterWhenLiteral(s)
	}
}

func (s *WhenLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitWhenLiteral(s)
	}
}




func (p *ApexParser) WhenLiteral() (localctx IWhenLiteralContext) {
	localctx = NewWhenLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ApexParserRULE_whenLiteral)
	var _la int

	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == ApexParserADD || _la == ApexParserSUB {
			{
				p.SetState(743)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ApexParserADD || _la == ApexParserSUB) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}


			p.SetState(748)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(749)
			p.Match(ApexParserIntegerLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(753)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == ApexParserADD || _la == ApexParserSUB {
			{
				p.SetState(750)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ApexParserADD || _la == ApexParserSUB) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}


			p.SetState(755)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(756)
			p.Match(ApexParserLongLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(757)
			p.Match(ApexParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(758)
			p.Match(ApexParserNULL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(759)
			p.Id()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(760)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(761)
			p.WhenLiteral()
		}
		{
			p.SetState(762)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ForControl() IForControlContext
	RPAREN() antlr.TerminalNode
	Statement() IStatementContext
	SEMI() antlr.TerminalNode

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(ApexParserFOR, 0)
}

func (s *ForStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *ForStatementContext) ForControl() IForControlContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForControlContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForControlContext)
}

func (s *ForStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}




func (p *ApexParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ApexParserRULE_forStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(766)
		p.Match(ApexParserFOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(767)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(768)
		p.ForControl()
	}
	{
		p.SetState(769)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserABSTRACT, ApexParserAFTER, ApexParserBEFORE, ApexParserBREAK, ApexParserCONTINUE, ApexParserDELETE, ApexParserDO, ApexParserFINAL, ApexParserFOR, ApexParserGET, ApexParserGLOBAL, ApexParserIF, ApexParserINHERITED, ApexParserINSERT, ApexParserINSTANCEOF, ApexParserMERGE, ApexParserNEW, ApexParserNULL, ApexParserOVERRIDE, ApexParserPRIVATE, ApexParserPROTECTED, ApexParserPUBLIC, ApexParserRETURN, ApexParserSYSTEMRUNAS, ApexParserSET, ApexParserSHARING, ApexParserSTATIC, ApexParserSUPER, ApexParserSWITCH, ApexParserTESTMETHOD, ApexParserTHIS, ApexParserTHROW, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserTRY, ApexParserUNDELETE, ApexParserUPDATE, ApexParserUPSERT, ApexParserVIRTUAL, ApexParserVOID, ApexParserWEBSERVICE, ApexParserWHEN, ApexParserWHILE, ApexParserWITH, ApexParserWITHOUT, ApexParserLIST, ApexParserMAP, ApexParserSYSTEM, ApexParserUSER, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserSYSTEM_MODE, ApexParserUSER_MODE, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserDISTANCE, ApexParserGEOLOCATION, ApexParserGROUPING, ApexParserCONVERT_CURRENCY, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserN_DAYS_AGO_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserN_WEEKS_AGO_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserN_MONTHS_AGO_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserN_QUARTERS_AGO_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserN_YEARS_AGO_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserN_FISCAL_QUARTERS_AGO_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserN_FISCAL_YEARS_AGO_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserFindLiteral, ApexParserIntegerLiteral, ApexParserLongLiteral, ApexParserNumberLiteral, ApexParserBooleanLiteral, ApexParserStringLiteral, ApexParserLPAREN, ApexParserLBRACE, ApexParserLBRACK, ApexParserBANG, ApexParserTILDE, ApexParserINC, ApexParserDEC, ApexParserADD, ApexParserSUB, ApexParserATSIGN, ApexParserIdentifier:
		{
			p.SetState(770)
			p.Statement()
		}


	case ApexParserSEMI:
		{
			p.SetState(771)
			p.Match(ApexParserSEMI)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	ParExpression() IParExpressionContext
	Statement() IStatementContext
	SEMI() antlr.TerminalNode

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ApexParserWHILE, 0)
}

func (s *WhileStatementContext) ParExpression() IParExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}




func (p *ApexParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ApexParserRULE_whileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(774)
		p.Match(ApexParserWHILE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(775)
		p.ParExpression()
	}
	p.SetState(778)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserABSTRACT, ApexParserAFTER, ApexParserBEFORE, ApexParserBREAK, ApexParserCONTINUE, ApexParserDELETE, ApexParserDO, ApexParserFINAL, ApexParserFOR, ApexParserGET, ApexParserGLOBAL, ApexParserIF, ApexParserINHERITED, ApexParserINSERT, ApexParserINSTANCEOF, ApexParserMERGE, ApexParserNEW, ApexParserNULL, ApexParserOVERRIDE, ApexParserPRIVATE, ApexParserPROTECTED, ApexParserPUBLIC, ApexParserRETURN, ApexParserSYSTEMRUNAS, ApexParserSET, ApexParserSHARING, ApexParserSTATIC, ApexParserSUPER, ApexParserSWITCH, ApexParserTESTMETHOD, ApexParserTHIS, ApexParserTHROW, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserTRY, ApexParserUNDELETE, ApexParserUPDATE, ApexParserUPSERT, ApexParserVIRTUAL, ApexParserVOID, ApexParserWEBSERVICE, ApexParserWHEN, ApexParserWHILE, ApexParserWITH, ApexParserWITHOUT, ApexParserLIST, ApexParserMAP, ApexParserSYSTEM, ApexParserUSER, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserSYSTEM_MODE, ApexParserUSER_MODE, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserDISTANCE, ApexParserGEOLOCATION, ApexParserGROUPING, ApexParserCONVERT_CURRENCY, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserN_DAYS_AGO_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserN_WEEKS_AGO_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserN_MONTHS_AGO_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserN_QUARTERS_AGO_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserN_YEARS_AGO_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserN_FISCAL_QUARTERS_AGO_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserN_FISCAL_YEARS_AGO_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserFindLiteral, ApexParserIntegerLiteral, ApexParserLongLiteral, ApexParserNumberLiteral, ApexParserBooleanLiteral, ApexParserStringLiteral, ApexParserLPAREN, ApexParserLBRACE, ApexParserLBRACK, ApexParserBANG, ApexParserTILDE, ApexParserINC, ApexParserDEC, ApexParserADD, ApexParserSUB, ApexParserATSIGN, ApexParserIdentifier:
		{
			p.SetState(776)
			p.Statement()
		}


	case ApexParserSEMI:
		{
			p.SetState(777)
			p.Match(ApexParserSEMI)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDoWhileStatementContext is an interface to support dynamic dispatch.
type IDoWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DO() antlr.TerminalNode
	Block() IBlockContext
	WHILE() antlr.TerminalNode
	ParExpression() IParExpressionContext
	SEMI() antlr.TerminalNode

	// IsDoWhileStatementContext differentiates from other interfaces.
	IsDoWhileStatementContext()
}

type DoWhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWhileStatementContext() *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_doWhileStatement
	return p
}

func InitEmptyDoWhileStatementContext(p *DoWhileStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_doWhileStatement
}

func (*DoWhileStatementContext) IsDoWhileStatementContext() {}

func NewDoWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_doWhileStatement

	return p
}

func (s *DoWhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(ApexParserDO, 0)
}

func (s *DoWhileStatementContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *DoWhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ApexParserWHILE, 0)
}

func (s *DoWhileStatementContext) ParExpression() IParExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *DoWhileStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *DoWhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DoWhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterDoWhileStatement(s)
	}
}

func (s *DoWhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitDoWhileStatement(s)
	}
}




func (p *ApexParser) DoWhileStatement() (localctx IDoWhileStatementContext) {
	localctx = NewDoWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ApexParserRULE_doWhileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(780)
		p.Match(ApexParserDO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(781)
		p.Block()
	}
	{
		p.SetState(782)
		p.Match(ApexParserWHILE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(783)
		p.ParExpression()
	}
	{
		p.SetState(784)
		p.Match(ApexParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	Block() IBlockContext
	FinallyBlock() IFinallyBlockContext
	AllCatchClause() []ICatchClauseContext
	CatchClause(i int) ICatchClauseContext

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_tryStatement
	return p
}

func InitEmptyTryStatementContext(p *TryStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_tryStatement
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(ApexParserTRY, 0)
}

func (s *TryStatementContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) FinallyBlock() IFinallyBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyBlockContext)
}

func (s *TryStatementContext) AllCatchClause() []ICatchClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICatchClauseContext); ok {
			len++
		}
	}

	tst := make([]ICatchClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICatchClauseContext); ok {
			tst[i] = t.(ICatchClauseContext)
			i++
		}
	}

	return tst
}

func (s *TryStatementContext) CatchClause(i int) ICatchClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterTryStatement(s)
	}
}

func (s *TryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitTryStatement(s)
	}
}




func (p *ApexParser) TryStatement() (localctx ITryStatementContext) {
	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ApexParserRULE_tryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(786)
		p.Match(ApexParserTRY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(787)
		p.Block()
	}
	p.SetState(797)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserCATCH:
		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == ApexParserCATCH {
			{
				p.SetState(788)
				p.CatchClause()
			}


			p.SetState(791)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(794)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == ApexParserFINALLY {
			{
				p.SetState(793)
				p.FinallyBlock()
			}

		}


	case ApexParserFINALLY:
		{
			p.SetState(796)
			p.FinallyBlock()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	Expression() IExpressionContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ApexParserRETURN, 0)
}

func (s *ReturnStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}




func (p *ApexParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ApexParserRULE_returnStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(799)
		p.Match(ApexParserRETURN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(801)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -6177691874033652) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & 18014527361651069) != 0) {
		{
			p.SetState(800)
			p.expression(0)
		}

	}
	{
		p.SetState(803)
		p.Match(ApexParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	THROW() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_throwStatement
	return p
}

func InitEmptyThrowStatementContext(p *ThrowStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_throwStatement
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowStatementContext) THROW() antlr.TerminalNode {
	return s.GetToken(ApexParserTHROW, 0)
}

func (s *ThrowStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ThrowStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ThrowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterThrowStatement(s)
	}
}

func (s *ThrowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitThrowStatement(s)
	}
}




func (p *ApexParser) ThrowStatement() (localctx IThrowStatementContext) {
	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ApexParserRULE_throwStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(805)
		p.Match(ApexParserTHROW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(806)
		p.expression(0)
	}
	{
		p.SetState(807)
		p.Match(ApexParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BREAK() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_breakStatement
	return p
}

func InitEmptyBreakStatementContext(p *BreakStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_breakStatement
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(ApexParserBREAK, 0)
}

func (s *BreakStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}




func (p *ApexParser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ApexParserRULE_breakStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(809)
		p.Match(ApexParserBREAK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(810)
		p.Match(ApexParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTINUE() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_continueStatement
	return p
}

func InitEmptyContinueStatementContext(p *ContinueStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_continueStatement
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(ApexParserCONTINUE, 0)
}

func (s *ContinueStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}




func (p *ApexParser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ApexParserRULE_continueStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(812)
		p.Match(ApexParserCONTINUE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(813)
		p.Match(ApexParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAccessLevelContext is an interface to support dynamic dispatch.
type IAccessLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	USER() antlr.TerminalNode

	// IsAccessLevelContext differentiates from other interfaces.
	IsAccessLevelContext()
}

type AccessLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessLevelContext() *AccessLevelContext {
	var p = new(AccessLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_accessLevel
	return p
}

func InitEmptyAccessLevelContext(p *AccessLevelContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_accessLevel
}

func (*AccessLevelContext) IsAccessLevelContext() {}

func NewAccessLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessLevelContext {
	var p = new(AccessLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_accessLevel

	return p
}

func (s *AccessLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessLevelContext) AS() antlr.TerminalNode {
	return s.GetToken(ApexParserAS, 0)
}

func (s *AccessLevelContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(ApexParserSYSTEM, 0)
}

func (s *AccessLevelContext) USER() antlr.TerminalNode {
	return s.GetToken(ApexParserUSER, 0)
}

func (s *AccessLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AccessLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterAccessLevel(s)
	}
}

func (s *AccessLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitAccessLevel(s)
	}
}




func (p *ApexParser) AccessLevel() (localctx IAccessLevelContext) {
	localctx = NewAccessLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ApexParserRULE_accessLevel)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(815)
		p.Match(ApexParserAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(816)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ApexParserSYSTEM || _la == ApexParserUSER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInsertStatementContext is an interface to support dynamic dispatch.
type IInsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSERT() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode
	AccessLevel() IAccessLevelContext

	// IsInsertStatementContext differentiates from other interfaces.
	IsInsertStatementContext()
}

type InsertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertStatementContext() *InsertStatementContext {
	var p = new(InsertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_insertStatement
	return p
}

func InitEmptyInsertStatementContext(p *InsertStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_insertStatement
}

func (*InsertStatementContext) IsInsertStatementContext() {}

func NewInsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementContext {
	var p = new(InsertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_insertStatement

	return p
}

func (s *InsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(ApexParserINSERT, 0)
}

func (s *InsertStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InsertStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *InsertStatementContext) AccessLevel() IAccessLevelContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessLevelContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessLevelContext)
}

func (s *InsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InsertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterInsertStatement(s)
	}
}

func (s *InsertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitInsertStatement(s)
	}
}




func (p *ApexParser) InsertStatement() (localctx IInsertStatementContext) {
	localctx = NewInsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ApexParserRULE_insertStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(818)
		p.Match(ApexParserINSERT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(820)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(819)
			p.AccessLevel()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(822)
		p.expression(0)
	}
	{
		p.SetState(823)
		p.Match(ApexParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUpdateStatementContext is an interface to support dynamic dispatch.
type IUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPDATE() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode
	AccessLevel() IAccessLevelContext

	// IsUpdateStatementContext differentiates from other interfaces.
	IsUpdateStatementContext()
}

type UpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateStatementContext() *UpdateStatementContext {
	var p = new(UpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_updateStatement
	return p
}

func InitEmptyUpdateStatementContext(p *UpdateStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_updateStatement
}

func (*UpdateStatementContext) IsUpdateStatementContext() {}

func NewUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateStatementContext {
	var p = new(UpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_updateStatement

	return p
}

func (s *UpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ApexParserUPDATE, 0)
}

func (s *UpdateStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpdateStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *UpdateStatementContext) AccessLevel() IAccessLevelContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessLevelContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessLevelContext)
}

func (s *UpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitUpdateStatement(s)
	}
}




func (p *ApexParser) UpdateStatement() (localctx IUpdateStatementContext) {
	localctx = NewUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ApexParserRULE_updateStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(825)
		p.Match(ApexParserUPDATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(827)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(826)
			p.AccessLevel()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(829)
		p.expression(0)
	}
	{
		p.SetState(830)
		p.Match(ApexParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode
	AccessLevel() IAccessLevelContext

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_deleteStatement
	return p
}

func InitEmptyDeleteStatementContext(p *DeleteStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_deleteStatement
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(ApexParserDELETE, 0)
}

func (s *DeleteStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeleteStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *DeleteStatementContext) AccessLevel() IAccessLevelContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessLevelContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessLevelContext)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}




func (p *ApexParser) DeleteStatement() (localctx IDeleteStatementContext) {
	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ApexParserRULE_deleteStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(832)
		p.Match(ApexParserDELETE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(834)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(833)
			p.AccessLevel()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(836)
		p.expression(0)
	}
	{
		p.SetState(837)
		p.Match(ApexParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUndeleteStatementContext is an interface to support dynamic dispatch.
type IUndeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNDELETE() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode
	AccessLevel() IAccessLevelContext

	// IsUndeleteStatementContext differentiates from other interfaces.
	IsUndeleteStatementContext()
}

type UndeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUndeleteStatementContext() *UndeleteStatementContext {
	var p = new(UndeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_undeleteStatement
	return p
}

func InitEmptyUndeleteStatementContext(p *UndeleteStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_undeleteStatement
}

func (*UndeleteStatementContext) IsUndeleteStatementContext() {}

func NewUndeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UndeleteStatementContext {
	var p = new(UndeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_undeleteStatement

	return p
}

func (s *UndeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UndeleteStatementContext) UNDELETE() antlr.TerminalNode {
	return s.GetToken(ApexParserUNDELETE, 0)
}

func (s *UndeleteStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UndeleteStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *UndeleteStatementContext) AccessLevel() IAccessLevelContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessLevelContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessLevelContext)
}

func (s *UndeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UndeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UndeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterUndeleteStatement(s)
	}
}

func (s *UndeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitUndeleteStatement(s)
	}
}




func (p *ApexParser) UndeleteStatement() (localctx IUndeleteStatementContext) {
	localctx = NewUndeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ApexParserRULE_undeleteStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(839)
		p.Match(ApexParserUNDELETE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(841)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(840)
			p.AccessLevel()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(843)
		p.expression(0)
	}
	{
		p.SetState(844)
		p.Match(ApexParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUpsertStatementContext is an interface to support dynamic dispatch.
type IUpsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPSERT() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode
	AccessLevel() IAccessLevelContext
	QualifiedName() IQualifiedNameContext

	// IsUpsertStatementContext differentiates from other interfaces.
	IsUpsertStatementContext()
}

type UpsertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpsertStatementContext() *UpsertStatementContext {
	var p = new(UpsertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_upsertStatement
	return p
}

func InitEmptyUpsertStatementContext(p *UpsertStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_upsertStatement
}

func (*UpsertStatementContext) IsUpsertStatementContext() {}

func NewUpsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpsertStatementContext {
	var p = new(UpsertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_upsertStatement

	return p
}

func (s *UpsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpsertStatementContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(ApexParserUPSERT, 0)
}

func (s *UpsertStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpsertStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *UpsertStatementContext) AccessLevel() IAccessLevelContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessLevelContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessLevelContext)
}

func (s *UpsertStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *UpsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UpsertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterUpsertStatement(s)
	}
}

func (s *UpsertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitUpsertStatement(s)
	}
}




func (p *ApexParser) UpsertStatement() (localctx IUpsertStatementContext) {
	localctx = NewUpsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ApexParserRULE_upsertStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(846)
		p.Match(ApexParserUPSERT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(848)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(847)
			p.AccessLevel()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(850)
		p.expression(0)
	}
	p.SetState(852)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -114828269935591412) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || _la == ApexParserIdentifier {
		{
			p.SetState(851)
			p.QualifiedName()
		}

	}
	{
		p.SetState(854)
		p.Match(ApexParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMergeStatementContext is an interface to support dynamic dispatch.
type IMergeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MERGE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	SEMI() antlr.TerminalNode
	AccessLevel() IAccessLevelContext

	// IsMergeStatementContext differentiates from other interfaces.
	IsMergeStatementContext()
}

type MergeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeStatementContext() *MergeStatementContext {
	var p = new(MergeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_mergeStatement
	return p
}

func InitEmptyMergeStatementContext(p *MergeStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_mergeStatement
}

func (*MergeStatementContext) IsMergeStatementContext() {}

func NewMergeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeStatementContext {
	var p = new(MergeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_mergeStatement

	return p
}

func (s *MergeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeStatementContext) MERGE() antlr.TerminalNode {
	return s.GetToken(ApexParserMERGE, 0)
}

func (s *MergeStatementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MergeStatementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MergeStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *MergeStatementContext) AccessLevel() IAccessLevelContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessLevelContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessLevelContext)
}

func (s *MergeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MergeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterMergeStatement(s)
	}
}

func (s *MergeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitMergeStatement(s)
	}
}




func (p *ApexParser) MergeStatement() (localctx IMergeStatementContext) {
	localctx = NewMergeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ApexParserRULE_mergeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(856)
		p.Match(ApexParserMERGE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(858)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(857)
			p.AccessLevel()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(860)
		p.expression(0)
	}
	{
		p.SetState(861)
		p.expression(0)
	}
	{
		p.SetState(862)
		p.Match(ApexParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRunAsStatementContext is an interface to support dynamic dispatch.
type IRunAsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYSTEMRUNAS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Block() IBlockContext
	ExpressionList() IExpressionListContext

	// IsRunAsStatementContext differentiates from other interfaces.
	IsRunAsStatementContext()
}

type RunAsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRunAsStatementContext() *RunAsStatementContext {
	var p = new(RunAsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_runAsStatement
	return p
}

func InitEmptyRunAsStatementContext(p *RunAsStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_runAsStatement
}

func (*RunAsStatementContext) IsRunAsStatementContext() {}

func NewRunAsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RunAsStatementContext {
	var p = new(RunAsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_runAsStatement

	return p
}

func (s *RunAsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RunAsStatementContext) SYSTEMRUNAS() antlr.TerminalNode {
	return s.GetToken(ApexParserSYSTEMRUNAS, 0)
}

func (s *RunAsStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *RunAsStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *RunAsStatementContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *RunAsStatementContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *RunAsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RunAsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RunAsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterRunAsStatement(s)
	}
}

func (s *RunAsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitRunAsStatement(s)
	}
}




func (p *ApexParser) RunAsStatement() (localctx IRunAsStatementContext) {
	localctx = NewRunAsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ApexParserRULE_runAsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(864)
		p.Match(ApexParserSYSTEMRUNAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(865)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(867)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -6177691874033652) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & 18014527361651069) != 0) {
		{
			p.SetState(866)
			p.ExpressionList()
		}

	}
	{
		p.SetState(869)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(870)
		p.Block()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_expressionStatement
	return p
}

func InitEmptyExpressionStatementContext(p *ExpressionStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_expressionStatement
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}




func (p *ApexParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ApexParserRULE_expressionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(872)
		p.expression(0)
	}
	{
		p.SetState(873)
		p.Match(ApexParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPropertyBlockContext is an interface to support dynamic dispatch.
type IPropertyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Getter() IGetterContext
	Setter() ISetterContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext

	// IsPropertyBlockContext differentiates from other interfaces.
	IsPropertyBlockContext()
}

type PropertyBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyBlockContext() *PropertyBlockContext {
	var p = new(PropertyBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_propertyBlock
	return p
}

func InitEmptyPropertyBlockContext(p *PropertyBlockContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_propertyBlock
}

func (*PropertyBlockContext) IsPropertyBlockContext() {}

func NewPropertyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyBlockContext {
	var p = new(PropertyBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_propertyBlock

	return p
}

func (s *PropertyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyBlockContext) Getter() IGetterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *PropertyBlockContext) Setter() ISetterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *PropertyBlockContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *PropertyBlockContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *PropertyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PropertyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterPropertyBlock(s)
	}
}

func (s *PropertyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitPropertyBlock(s)
	}
}




func (p *ApexParser) PropertyBlock() (localctx IPropertyBlockContext) {
	localctx = NewPropertyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ApexParserRULE_propertyBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(878)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 28433993197297666) != 0) || _la == ApexParserATSIGN {
		{
			p.SetState(875)
			p.Modifier()
		}


		p.SetState(880)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(883)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserGET:
		{
			p.SetState(881)
			p.Getter()
		}


	case ApexParserSET:
		{
			p.SetState(882)
			p.Setter()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGetterContext is an interface to support dynamic dispatch.
type IGetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GET() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	Block() IBlockContext

	// IsGetterContext differentiates from other interfaces.
	IsGetterContext()
}

type GetterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetterContext() *GetterContext {
	var p = new(GetterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_getter
	return p
}

func InitEmptyGetterContext(p *GetterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_getter
}

func (*GetterContext) IsGetterContext() {}

func NewGetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetterContext {
	var p = new(GetterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_getter

	return p
}

func (s *GetterContext) GetParser() antlr.Parser { return s.parser }

func (s *GetterContext) GET() antlr.TerminalNode {
	return s.GetToken(ApexParserGET, 0)
}

func (s *GetterContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *GetterContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *GetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterGetter(s)
	}
}

func (s *GetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitGetter(s)
	}
}




func (p *ApexParser) Getter() (localctx IGetterContext) {
	localctx = NewGetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ApexParserRULE_getter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(885)
		p.Match(ApexParserGET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(888)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserSEMI:
		{
			p.SetState(886)
			p.Match(ApexParserSEMI)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserLBRACE:
		{
			p.SetState(887)
			p.Block()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISetterContext is an interface to support dynamic dispatch.
type ISetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	Block() IBlockContext

	// IsSetterContext differentiates from other interfaces.
	IsSetterContext()
}

type SetterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetterContext() *SetterContext {
	var p = new(SetterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_setter
	return p
}

func InitEmptySetterContext(p *SetterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_setter
}

func (*SetterContext) IsSetterContext() {}

func NewSetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetterContext {
	var p = new(SetterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_setter

	return p
}

func (s *SetterContext) GetParser() antlr.Parser { return s.parser }

func (s *SetterContext) SET() antlr.TerminalNode {
	return s.GetToken(ApexParserSET, 0)
}

func (s *SetterContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, 0)
}

func (s *SetterContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSetter(s)
	}
}

func (s *SetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSetter(s)
	}
}




func (p *ApexParser) Setter() (localctx ISetterContext) {
	localctx = NewSetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ApexParserRULE_setter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(890)
		p.Match(ApexParserSET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(893)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserSEMI:
		{
			p.SetState(891)
			p.Match(ApexParserSEMI)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserLBRACE:
		{
			p.SetState(892)
			p.Block()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATCH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	Id() IIdContext
	RPAREN() antlr.TerminalNode
	Block() IBlockContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_catchClause
	return p
}

func InitEmptyCatchClauseContext(p *CatchClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_catchClause
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) CATCH() antlr.TerminalNode {
	return s.GetToken(ApexParserCATCH, 0)
}

func (s *CatchClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *CatchClauseContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CatchClauseContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *CatchClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *CatchClauseContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchClauseContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *CatchClauseContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CatchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterCatchClause(s)
	}
}

func (s *CatchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitCatchClause(s)
	}
}




func (p *ApexParser) CatchClause() (localctx ICatchClauseContext) {
	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ApexParserRULE_catchClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(895)
		p.Match(ApexParserCATCH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(896)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(897)
				p.Modifier()
			}


		}
		p.SetState(902)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(903)
		p.QualifiedName()
	}
	{
		p.SetState(904)
		p.Id()
	}
	{
		p.SetState(905)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(906)
		p.Block()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFinallyBlockContext is an interface to support dynamic dispatch.
type IFinallyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINALLY() antlr.TerminalNode
	Block() IBlockContext

	// IsFinallyBlockContext differentiates from other interfaces.
	IsFinallyBlockContext()
}

type FinallyBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyBlockContext() *FinallyBlockContext {
	var p = new(FinallyBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_finallyBlock
	return p
}

func InitEmptyFinallyBlockContext(p *FinallyBlockContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_finallyBlock
}

func (*FinallyBlockContext) IsFinallyBlockContext() {}

func NewFinallyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyBlockContext {
	var p = new(FinallyBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_finallyBlock

	return p
}

func (s *FinallyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyBlockContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(ApexParserFINALLY, 0)
}

func (s *FinallyBlockContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FinallyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterFinallyBlock(s)
	}
}

func (s *FinallyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitFinallyBlock(s)
	}
}




func (p *ApexParser) FinallyBlock() (localctx IFinallyBlockContext) {
	localctx = NewFinallyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ApexParserRULE_finallyBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(908)
		p.Match(ApexParserFINALLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(909)
		p.Block()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IForControlContext is an interface to support dynamic dispatch.
type IForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnhancedForControl() IEnhancedForControlContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	ForInit() IForInitContext
	Expression() IExpressionContext
	ForUpdate() IForUpdateContext

	// IsForControlContext differentiates from other interfaces.
	IsForControlContext()
}

type ForControlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForControlContext() *ForControlContext {
	var p = new(ForControlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forControl
	return p
}

func InitEmptyForControlContext(p *ForControlContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forControl
}

func (*ForControlContext) IsForControlContext() {}

func NewForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForControlContext {
	var p = new(ForControlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_forControl

	return p
}

func (s *ForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *ForControlContext) EnhancedForControl() IEnhancedForControlContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedForControlContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedForControlContext)
}

func (s *ForControlContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(ApexParserSEMI)
}

func (s *ForControlContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserSEMI, i)
}

func (s *ForControlContext) ForInit() IForInitContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInitContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *ForControlContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForControlContext) ForUpdate() IForUpdateContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForUpdateContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForUpdateContext)
}

func (s *ForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ForControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterForControl(s)
	}
}

func (s *ForControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitForControl(s)
	}
}




func (p *ApexParser) ForControl() (localctx IForControlContext) {
	localctx = NewForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ApexParserRULE_forControl)
	var _la int

	p.SetState(923)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(911)
			p.EnhancedForControl()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -4769694488518642) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & 27021726616392061) != 0) {
			{
				p.SetState(912)
				p.ForInit()
			}

		}
		{
			p.SetState(915)
			p.Match(ApexParserSEMI)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(917)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -6177691874033652) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & 18014527361651069) != 0) {
			{
				p.SetState(916)
				p.expression(0)
			}

		}
		{
			p.SetState(919)
			p.Match(ApexParserSEMI)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(921)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -6177691874033652) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & 18014527361651069) != 0) {
			{
				p.SetState(920)
				p.ForUpdate()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LocalVariableDeclaration() ILocalVariableDeclarationContext
	ExpressionList() IExpressionListContext

	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forInit
	return p
}

func InitEmptyForInitContext(p *ForInitContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forInit
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *ForInitContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ForInitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterForInit(s)
	}
}

func (s *ForInitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitForInit(s)
	}
}




func (p *ApexParser) ForInit() (localctx IForInitContext) {
	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ApexParserRULE_forInit)
	p.SetState(927)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(925)
			p.LocalVariableDeclaration()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(926)
			p.ExpressionList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IEnhancedForControlContext is an interface to support dynamic dispatch.
type IEnhancedForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeRef() ITypeRefContext
	Id() IIdContext
	COLON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsEnhancedForControlContext differentiates from other interfaces.
	IsEnhancedForControlContext()
}

type EnhancedForControlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedForControlContext() *EnhancedForControlContext {
	var p = new(EnhancedForControlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_enhancedForControl
	return p
}

func InitEmptyEnhancedForControlContext(p *EnhancedForControlContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_enhancedForControl
}

func (*EnhancedForControlContext) IsEnhancedForControlContext() {}

func NewEnhancedForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedForControlContext {
	var p = new(EnhancedForControlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_enhancedForControl

	return p
}

func (s *EnhancedForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedForControlContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *EnhancedForControlContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *EnhancedForControlContext) COLON() antlr.TerminalNode {
	return s.GetToken(ApexParserCOLON, 0)
}

func (s *EnhancedForControlContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnhancedForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EnhancedForControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterEnhancedForControl(s)
	}
}

func (s *EnhancedForControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitEnhancedForControl(s)
	}
}




func (p *ApexParser) EnhancedForControl() (localctx IEnhancedForControlContext) {
	localctx = NewEnhancedForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ApexParserRULE_enhancedForControl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(929)
		p.TypeRef()
	}
	{
		p.SetState(930)
		p.Id()
	}
	{
		p.SetState(931)
		p.Match(ApexParserCOLON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(932)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IForUpdateContext is an interface to support dynamic dispatch.
type IForUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext

	// IsForUpdateContext differentiates from other interfaces.
	IsForUpdateContext()
}

type ForUpdateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForUpdateContext() *ForUpdateContext {
	var p = new(ForUpdateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forUpdate
	return p
}

func InitEmptyForUpdateContext(p *ForUpdateContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forUpdate
}

func (*ForUpdateContext) IsForUpdateContext() {}

func NewForUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForUpdateContext {
	var p = new(ForUpdateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_forUpdate

	return p
}

func (s *ForUpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *ForUpdateContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForUpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ForUpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterForUpdate(s)
	}
}

func (s *ForUpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitForUpdate(s)
	}
}




func (p *ApexParser) ForUpdate() (localctx IForUpdateContext) {
	localctx = NewForUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ApexParserRULE_forUpdate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(934)
		p.ExpressionList()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IParExpressionContext is an interface to support dynamic dispatch.
type IParExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsParExpressionContext differentiates from other interfaces.
	IsParExpressionContext()
}

type ParExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParExpressionContext() *ParExpressionContext {
	var p = new(ParExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_parExpression
	return p
}

func InitEmptyParExpressionContext(p *ParExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_parExpression
}

func (*ParExpressionContext) IsParExpressionContext() {}

func NewParExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParExpressionContext {
	var p = new(ParExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_parExpression

	return p
}

func (s *ParExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *ParExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *ParExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterParExpression(s)
	}
}

func (s *ParExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitParExpression(s)
	}
}




func (p *ApexParser) ParExpression() (localctx IParExpressionContext) {
	localctx = NewParExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ApexParserRULE_parExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(936)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(937)
		p.expression(0)
	}
	{
		p.SetState(938)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}




func (p *ApexParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ApexParserRULE_expressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(940)
		p.expression(0)
	}
	p.SetState(945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserCOMMA {
		{
			p.SetState(941)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(942)
			p.expression(0)
		}


		p.SetState(947)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyAll(ctx *ExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}





type PrimaryExpressionContext struct {
	ExpressionContext
}

func NewPrimaryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) Primary() IPrimaryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}


func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}


type Arth1ExpressionContext struct {
	ExpressionContext
}

func NewArth1ExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Arth1ExpressionContext {
	var p = new(Arth1ExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *Arth1ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arth1ExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Arth1ExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Arth1ExpressionContext) MUL() antlr.TerminalNode {
	return s.GetToken(ApexParserMUL, 0)
}

func (s *Arth1ExpressionContext) DIV() antlr.TerminalNode {
	return s.GetToken(ApexParserDIV, 0)
}


func (s *Arth1ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterArth1Expression(s)
	}
}

func (s *Arth1ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitArth1Expression(s)
	}
}


type CoalExpressionContext struct {
	ExpressionContext
}

func NewCoalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CoalExpressionContext {
	var p = new(CoalExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *CoalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CoalExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CoalExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CoalExpressionContext) COAL() antlr.TerminalNode {
	return s.GetToken(ApexParserCOAL, 0)
}


func (s *CoalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterCoalExpression(s)
	}
}

func (s *CoalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitCoalExpression(s)
	}
}


type DotExpressionContext struct {
	ExpressionContext
}

func NewDotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DotExpressionContext {
	var p = new(DotExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *DotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DotExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DotExpressionContext) DOT() antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, 0)
}

func (s *DotExpressionContext) QUESTIONDOT() antlr.TerminalNode {
	return s.GetToken(ApexParserQUESTIONDOT, 0)
}

func (s *DotExpressionContext) DotMethodCall() IDotMethodCallContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotMethodCallContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotMethodCallContext)
}

func (s *DotExpressionContext) AnyId() IAnyIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyIdContext)
}


func (s *DotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterDotExpression(s)
	}
}

func (s *DotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitDotExpression(s)
	}
}


type BitOrExpressionContext struct {
	ExpressionContext
}

func NewBitOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitOrExpressionContext {
	var p = new(BitOrExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOrExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitOrExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitOrExpressionContext) BITOR() antlr.TerminalNode {
	return s.GetToken(ApexParserBITOR, 0)
}


func (s *BitOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterBitOrExpression(s)
	}
}

func (s *BitOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitBitOrExpression(s)
	}
}


type ArrayExpressionContext struct {
	ExpressionContext
}

func NewArrayExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayExpressionContext {
	var p = new(ArrayExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ArrayExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayExpressionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACK, 0)
}

func (s *ArrayExpressionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACK, 0)
}


func (s *ArrayExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterArrayExpression(s)
	}
}

func (s *ArrayExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitArrayExpression(s)
	}
}


type TNewExpressionContext struct {
	ExpressionContext
}

func NewNewExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TNewExpressionContext {
	var p = new(TNewExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *TNewExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TNewExpressionContext) NEW() antlr.TerminalNode {
	return s.GetToken(ApexParserNEW, 0)
}

func (s *TNewExpressionContext) Creator() ICreatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatorContext)
}


func (s *TNewExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterNewExpression(s)
	}
}

func (s *TNewExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitNewExpression(s)
	}
}


type AssignExpressionContext struct {
	ExpressionContext
}

func NewAssignExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignExpressionContext {
	var p = new(AssignExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *AssignExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignExpressionContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserASSIGN, 0)
}

func (s *AssignExpressionContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserADD_ASSIGN, 0)
}

func (s *AssignExpressionContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserSUB_ASSIGN, 0)
}

func (s *AssignExpressionContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserMUL_ASSIGN, 0)
}

func (s *AssignExpressionContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserDIV_ASSIGN, 0)
}

func (s *AssignExpressionContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserAND_ASSIGN, 0)
}

func (s *AssignExpressionContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserOR_ASSIGN, 0)
}

func (s *AssignExpressionContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserXOR_ASSIGN, 0)
}

func (s *AssignExpressionContext) RSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserRSHIFT_ASSIGN, 0)
}

func (s *AssignExpressionContext) URSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserURSHIFT_ASSIGN, 0)
}

func (s *AssignExpressionContext) LSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserLSHIFT_ASSIGN, 0)
}


func (s *AssignExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterAssignExpression(s)
	}
}

func (s *AssignExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitAssignExpression(s)
	}
}


type MethodCallExpressionContext struct {
	ExpressionContext
}

func NewMethodCallExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MethodCallExpressionContext {
	var p = new(MethodCallExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *MethodCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodCallExpressionContext) MethodCall() IMethodCallContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodCallContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodCallContext)
}


func (s *MethodCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterMethodCallExpression(s)
	}
}

func (s *MethodCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitMethodCallExpression(s)
	}
}


type BitNotExpressionContext struct {
	ExpressionContext
}

func NewBitNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitNotExpressionContext {
	var p = new(BitNotExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitNotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitNotExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitNotExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitNotExpressionContext) CARET() antlr.TerminalNode {
	return s.GetToken(ApexParserCARET, 0)
}


func (s *BitNotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterBitNotExpression(s)
	}
}

func (s *BitNotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitBitNotExpression(s)
	}
}


type Arth2ExpressionContext struct {
	ExpressionContext
}

func NewArth2ExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Arth2ExpressionContext {
	var p = new(Arth2ExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *Arth2ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arth2ExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Arth2ExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Arth2ExpressionContext) ADD() antlr.TerminalNode {
	return s.GetToken(ApexParserADD, 0)
}

func (s *Arth2ExpressionContext) SUB() antlr.TerminalNode {
	return s.GetToken(ApexParserSUB, 0)
}


func (s *Arth2ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterArth2Expression(s)
	}
}

func (s *Arth2ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitArth2Expression(s)
	}
}


type LogAndExpressionContext struct {
	ExpressionContext
}

func NewLogAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogAndExpressionContext {
	var p = new(LogAndExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogAndExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogAndExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogAndExpressionContext) AND() antlr.TerminalNode {
	return s.GetToken(ApexParserAND, 0)
}


func (s *LogAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterLogAndExpression(s)
	}
}

func (s *LogAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitLogAndExpression(s)
	}
}


type CastExpressionContext struct {
	ExpressionContext
}

func NewCastExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExpressionContext {
	var p = new(CastExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *CastExpressionContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *CastExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *CastExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *CastExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterCastExpression(s)
	}
}

func (s *CastExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitCastExpression(s)
	}
}


type BitAndExpressionContext struct {
	ExpressionContext
}

func NewBitAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitAndExpressionContext {
	var p = new(BitAndExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitAndExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitAndExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitAndExpressionContext) BITAND() antlr.TerminalNode {
	return s.GetToken(ApexParserBITAND, 0)
}


func (s *BitAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterBitAndExpression(s)
	}
}

func (s *BitAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitBitAndExpression(s)
	}
}


type CmpExpressionContext struct {
	ExpressionContext
}

func NewCmpExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CmpExpressionContext {
	var p = new(CmpExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *CmpExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CmpExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CmpExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CmpExpressionContext) GT() antlr.TerminalNode {
	return s.GetToken(ApexParserGT, 0)
}

func (s *CmpExpressionContext) LT() antlr.TerminalNode {
	return s.GetToken(ApexParserLT, 0)
}

func (s *CmpExpressionContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserASSIGN, 0)
}


func (s *CmpExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterCmpExpression(s)
	}
}

func (s *CmpExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitCmpExpression(s)
	}
}


type BitExpressionContext struct {
	ExpressionContext
}

func NewBitExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitExpressionContext {
	var p = new(BitExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitExpressionContext) AllLT() []antlr.TerminalNode {
	return s.GetTokens(ApexParserLT)
}

func (s *BitExpressionContext) LT(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserLT, i)
}

func (s *BitExpressionContext) AllGT() []antlr.TerminalNode {
	return s.GetTokens(ApexParserGT)
}

func (s *BitExpressionContext) GT(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserGT, i)
}


func (s *BitExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterBitExpression(s)
	}
}

func (s *BitExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitBitExpression(s)
	}
}


type LogOrExpressionContext struct {
	ExpressionContext
}

func NewLogOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogOrExpressionContext {
	var p = new(LogOrExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogOrExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogOrExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogOrExpressionContext) OR() antlr.TerminalNode {
	return s.GetToken(ApexParserOR, 0)
}


func (s *LogOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterLogOrExpression(s)
	}
}

func (s *LogOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitLogOrExpression(s)
	}
}


type CondExpressionContext struct {
	ExpressionContext
}

func NewCondExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CondExpressionContext {
	var p = new(CondExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *CondExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CondExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CondExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CondExpressionContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ApexParserQUESTION, 0)
}

func (s *CondExpressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(ApexParserCOLON, 0)
}


func (s *CondExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterCondExpression(s)
	}
}

func (s *CondExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitCondExpression(s)
	}
}


type EqualityExpressionContext struct {
	ExpressionContext
}

func NewEqualityExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EqualityExpressionContext) TRIPLEEQUAL() antlr.TerminalNode {
	return s.GetToken(ApexParserTRIPLEEQUAL, 0)
}

func (s *EqualityExpressionContext) TRIPLENOTEQUAL() antlr.TerminalNode {
	return s.GetToken(ApexParserTRIPLENOTEQUAL, 0)
}

func (s *EqualityExpressionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(ApexParserEQUAL, 0)
}

func (s *EqualityExpressionContext) NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(ApexParserNOTEQUAL, 0)
}

func (s *EqualityExpressionContext) LESSANDGREATER() antlr.TerminalNode {
	return s.GetToken(ApexParserLESSANDGREATER, 0)
}


func (s *EqualityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitEqualityExpression(s)
	}
}


type PostOpExpressionContext struct {
	ExpressionContext
}

func NewPostOpExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostOpExpressionContext {
	var p = new(PostOpExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *PostOpExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostOpExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PostOpExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(ApexParserINC, 0)
}

func (s *PostOpExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(ApexParserDEC, 0)
}


func (s *PostOpExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterPostOpExpression(s)
	}
}

func (s *PostOpExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitPostOpExpression(s)
	}
}


type NegExpressionContext struct {
	ExpressionContext
}

func NewNegExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NegExpressionContext {
	var p = new(NegExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *NegExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NegExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NegExpressionContext) TILDE() antlr.TerminalNode {
	return s.GetToken(ApexParserTILDE, 0)
}

func (s *NegExpressionContext) BANG() antlr.TerminalNode {
	return s.GetToken(ApexParserBANG, 0)
}


func (s *NegExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterNegExpression(s)
	}
}

func (s *NegExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitNegExpression(s)
	}
}


type PreOpExpressionContext struct {
	ExpressionContext
}

func NewPreOpExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreOpExpressionContext {
	var p = new(PreOpExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *PreOpExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreOpExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PreOpExpressionContext) ADD() antlr.TerminalNode {
	return s.GetToken(ApexParserADD, 0)
}

func (s *PreOpExpressionContext) SUB() antlr.TerminalNode {
	return s.GetToken(ApexParserSUB, 0)
}

func (s *PreOpExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(ApexParserINC, 0)
}

func (s *PreOpExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(ApexParserDEC, 0)
}


func (s *PreOpExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterPreOpExpression(s)
	}
}

func (s *PreOpExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitPreOpExpression(s)
	}
}


type SubExpressionContext struct {
	ExpressionContext
}

func NewSubExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubExpressionContext {
	var p = new(SubExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *SubExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *SubExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SubExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}


func (s *SubExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSubExpression(s)
	}
}

func (s *SubExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSubExpression(s)
	}
}


type InstanceOfExpressionContext struct {
	ExpressionContext
}

func NewInstanceOfExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InstanceOfExpressionContext {
	var p = new(InstanceOfExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *InstanceOfExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceOfExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InstanceOfExpressionContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(ApexParserINSTANCEOF, 0)
}

func (s *InstanceOfExpressionContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}


func (s *InstanceOfExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterInstanceOfExpression(s)
	}
}

func (s *InstanceOfExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitInstanceOfExpression(s)
	}
}



func (p *ApexParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *ApexParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 152
	p.EnterRecursionRule(localctx, 152, ApexParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPrimaryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(949)
			p.Primary()
		}


	case 2:
		localctx = NewMethodCallExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(950)
			p.MethodCall()
		}


	case 3:
		localctx = NewNewExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(951)
			p.Match(ApexParserNEW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(952)
			p.Creator()
		}


	case 4:
		localctx = NewCastExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(953)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(954)
			p.TypeRef()
		}
		{
			p.SetState(955)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(956)
			p.expression(19)
		}


	case 5:
		localctx = NewSubExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(958)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(959)
			p.expression(0)
		}
		{
			p.SetState(960)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		localctx = NewPreOpExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(962)
			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 225)) & ^0x3f) == 0 && ((int64(1) << (_la - 225)) & 15) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(963)
			p.expression(16)
		}


	case 7:
		localctx = NewNegExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(964)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ApexParserBANG || _la == ApexParserTILDE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(965)
			p.expression(15)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1039)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1037)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArth1ExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(968)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(969)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ApexParserMUL || _la == ApexParserDIV) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(970)
					p.expression(15)
				}


			case 2:
				localctx = NewArth2ExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(971)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(972)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ApexParserADD || _la == ApexParserSUB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(973)
					p.expression(14)
				}


			case 3:
				localctx = NewBitExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(974)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				p.SetState(982)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(975)
						p.Match(ApexParserLT)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}
					{
						p.SetState(976)
						p.Match(ApexParserLT)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}


				case 2:
					{
						p.SetState(977)
						p.Match(ApexParserGT)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}
					{
						p.SetState(978)
						p.Match(ApexParserGT)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}
					{
						p.SetState(979)
						p.Match(ApexParserGT)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}


				case 3:
					{
						p.SetState(980)
						p.Match(ApexParserGT)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}
					{
						p.SetState(981)
						p.Match(ApexParserGT)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}
				{
					p.SetState(984)
					p.expression(13)
				}


			case 4:
				localctx = NewCmpExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(985)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(986)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ApexParserGT || _la == ApexParserLT) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(988)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == ApexParserASSIGN {
					{
						p.SetState(987)
						p.Match(ApexParserASSIGN)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

				}
				{
					p.SetState(990)
					p.expression(12)
				}


			case 5:
				localctx = NewEqualityExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(991)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(992)
					_la = p.GetTokenStream().LA(1)

					if !(((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & 31) != 0)) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(993)
					p.expression(10)
				}


			case 6:
				localctx = NewBitAndExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(994)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(995)
					p.Match(ApexParserBITAND)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(996)
					p.expression(9)
				}


			case 7:
				localctx = NewBitNotExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(997)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(998)
					p.Match(ApexParserCARET)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(999)
					p.expression(8)
				}


			case 8:
				localctx = NewBitOrExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(1000)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(1001)
					p.Match(ApexParserBITOR)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1002)
					p.expression(7)
				}


			case 9:
				localctx = NewLogAndExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(1003)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(1004)
					p.Match(ApexParserAND)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1005)
					p.expression(6)
				}


			case 10:
				localctx = NewLogOrExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(1006)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(1007)
					p.Match(ApexParserOR)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1008)
					p.expression(5)
				}


			case 11:
				localctx = NewCoalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(1009)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1010)
					p.Match(ApexParserCOAL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1011)
					p.expression(4)
				}


			case 12:
				localctx = NewCondExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(1012)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1013)
					p.Match(ApexParserQUESTION)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1014)
					p.expression(0)
				}
				{
					p.SetState(1015)
					p.Match(ApexParserCOLON)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1016)
					p.expression(2)
				}


			case 13:
				localctx = NewAssignExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(1018)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1019)
					_la = p.GetTokenStream().LA(1)

					if !(((int64((_la - 209)) & ^0x3f) == 0 && ((int64(1) << (_la - 209)) & 68652367873) != 0)) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1020)
					p.expression(1)
				}


			case 14:
				localctx = NewDotExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(1021)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
					goto errorExit
				}
				{
					p.SetState(1022)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ApexParserDOT || _la == ApexParserQUESTIONDOT) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(1025)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(1023)
						p.DotMethodCall()
					}


				case 2:
					{
						p.SetState(1024)
						p.AnyId()
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}


			case 15:
				localctx = NewArrayExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(1027)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
					goto errorExit
				}
				{
					p.SetState(1028)
					p.Match(ApexParserLBRACK)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1029)
					p.expression(0)
				}
				{
					p.SetState(1030)
					p.Match(ApexParserRBRACK)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case 16:
				localctx = NewPostOpExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(1032)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
					goto errorExit
				}
				{
					p.SetState(1033)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ApexParserINC || _la == ApexParserDEC) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


			case 17:
				localctx = NewInstanceOfExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ApexParserRULE_expression)
				p.SetState(1034)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(1035)
					p.Match(ApexParserINSTANCEOF)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1036)
					p.TypeRef()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1041)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_primary
	return p
}

func InitEmptyPrimaryContext(p *PrimaryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_primary
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) CopyAll(ctx *PrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type ThisPrimaryContext struct {
	PrimaryContext
}

func NewThisPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThisPrimaryContext {
	var p = new(ThisPrimaryContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *ThisPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisPrimaryContext) THIS() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS, 0)
}


func (s *ThisPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterThisPrimary(s)
	}
}

func (s *ThisPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitThisPrimary(s)
	}
}


type VoidPrimaryContext struct {
	PrimaryContext
}

func NewVoidPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VoidPrimaryContext {
	var p = new(VoidPrimaryContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *VoidPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VoidPrimaryContext) VOID() antlr.TerminalNode {
	return s.GetToken(ApexParserVOID, 0)
}

func (s *VoidPrimaryContext) DOT() antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, 0)
}

func (s *VoidPrimaryContext) CLASS() antlr.TerminalNode {
	return s.GetToken(ApexParserCLASS, 0)
}


func (s *VoidPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterVoidPrimary(s)
	}
}

func (s *VoidPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitVoidPrimary(s)
	}
}


type SoqlPrimaryContext struct {
	PrimaryContext
}

func NewSoqlPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SoqlPrimaryContext {
	var p = new(SoqlPrimaryContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *SoqlPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoqlPrimaryContext) SoqlLiteral() ISoqlLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlLiteralContext)
}


func (s *SoqlPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSoqlPrimary(s)
	}
}

func (s *SoqlPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSoqlPrimary(s)
	}
}


type SuperPrimaryContext struct {
	PrimaryContext
}

func NewSuperPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SuperPrimaryContext {
	var p = new(SuperPrimaryContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *SuperPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperPrimaryContext) SUPER() antlr.TerminalNode {
	return s.GetToken(ApexParserSUPER, 0)
}


func (s *SuperPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSuperPrimary(s)
	}
}

func (s *SuperPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSuperPrimary(s)
	}
}


type TypeRefPrimaryContext struct {
	PrimaryContext
}

func NewTypeRefPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeRefPrimaryContext {
	var p = new(TypeRefPrimaryContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *TypeRefPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeRefPrimaryContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *TypeRefPrimaryContext) DOT() antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, 0)
}

func (s *TypeRefPrimaryContext) CLASS() antlr.TerminalNode {
	return s.GetToken(ApexParserCLASS, 0)
}


func (s *TypeRefPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterTypeRefPrimary(s)
	}
}

func (s *TypeRefPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitTypeRefPrimary(s)
	}
}


type IdPrimaryContext struct {
	PrimaryContext
}

func NewIdPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdPrimaryContext {
	var p = new(IdPrimaryContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *IdPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdPrimaryContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}


func (s *IdPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterIdPrimary(s)
	}
}

func (s *IdPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitIdPrimary(s)
	}
}


type SoslPrimaryContext struct {
	PrimaryContext
}

func NewSoslPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SoslPrimaryContext {
	var p = new(SoslPrimaryContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *SoslPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoslPrimaryContext) SoslLiteral() ISoslLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoslLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoslLiteralContext)
}


func (s *SoslPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSoslPrimary(s)
	}
}

func (s *SoslPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSoslPrimary(s)
	}
}


type LiteralPrimaryContext struct {
	PrimaryContext
}

func NewLiteralPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralPrimaryContext {
	var p = new(LiteralPrimaryContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *LiteralPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralPrimaryContext) Literal() ILiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}


func (s *LiteralPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterLiteralPrimary(s)
	}
}

func (s *LiteralPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitLiteralPrimary(s)
	}
}



func (p *ApexParser) Primary() (localctx IPrimaryContext) {
	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ApexParserRULE_primary)
	p.SetState(1055)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		localctx = NewThisPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1042)
			p.Match(ApexParserTHIS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		localctx = NewSuperPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1043)
			p.Match(ApexParserSUPER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		localctx = NewLiteralPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1044)
			p.Literal()
		}


	case 4:
		localctx = NewTypeRefPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1045)
			p.TypeRef()
		}
		{
			p.SetState(1046)
			p.Match(ApexParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1047)
			p.Match(ApexParserCLASS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		localctx = NewVoidPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1049)
			p.Match(ApexParserVOID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1050)
			p.Match(ApexParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1051)
			p.Match(ApexParserCLASS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		localctx = NewIdPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1052)
			p.Id()
		}


	case 7:
		localctx = NewSoqlPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1053)
			p.SoqlLiteral()
		}


	case 8:
		localctx = NewSoslPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1054)
			p.SoslLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMethodCallContext is an interface to support dynamic dispatch.
type IMethodCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	THIS() antlr.TerminalNode
	SUPER() antlr.TerminalNode

	// IsMethodCallContext differentiates from other interfaces.
	IsMethodCallContext()
}

type MethodCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodCallContext() *MethodCallContext {
	var p = new(MethodCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_methodCall
	return p
}

func InitEmptyMethodCallContext(p *MethodCallContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_methodCall
}

func (*MethodCallContext) IsMethodCallContext() {}

func NewMethodCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodCallContext {
	var p = new(MethodCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_methodCall

	return p
}

func (s *MethodCallContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodCallContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *MethodCallContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *MethodCallContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *MethodCallContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *MethodCallContext) THIS() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS, 0)
}

func (s *MethodCallContext) SUPER() antlr.TerminalNode {
	return s.GetToken(ApexParserSUPER, 0)
}

func (s *MethodCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MethodCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterMethodCall(s)
	}
}

func (s *MethodCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitMethodCall(s)
	}
}




func (p *ApexParser) MethodCall() (localctx IMethodCallContext) {
	localctx = NewMethodCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ApexParserRULE_methodCall)
	var _la int

	p.SetState(1076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserAFTER, ApexParserBEFORE, ApexParserGET, ApexParserINHERITED, ApexParserINSTANCEOF, ApexParserSET, ApexParserSHARING, ApexParserSWITCH, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserWHEN, ApexParserWITH, ApexParserWITHOUT, ApexParserSYSTEM, ApexParserUSER, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserSYSTEM_MODE, ApexParserUSER_MODE, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserDISTANCE, ApexParserGEOLOCATION, ApexParserGROUPING, ApexParserCONVERT_CURRENCY, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserN_DAYS_AGO_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserN_WEEKS_AGO_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserN_MONTHS_AGO_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserN_QUARTERS_AGO_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserN_YEARS_AGO_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserN_FISCAL_QUARTERS_AGO_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserN_FISCAL_YEARS_AGO_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1057)
			p.Id()
		}
		{
			p.SetState(1058)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -6177691874033652) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & 18014527361651069) != 0) {
			{
				p.SetState(1059)
				p.ExpressionList()
			}

		}
		{
			p.SetState(1062)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserTHIS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1064)
			p.Match(ApexParserTHIS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1065)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1067)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -6177691874033652) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & 18014527361651069) != 0) {
			{
				p.SetState(1066)
				p.ExpressionList()
			}

		}
		{
			p.SetState(1069)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserSUPER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1070)
			p.Match(ApexParserSUPER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1071)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1073)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -6177691874033652) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & 18014527361651069) != 0) {
			{
				p.SetState(1072)
				p.ExpressionList()
			}

		}
		{
			p.SetState(1075)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDotMethodCallContext is an interface to support dynamic dispatch.
type IDotMethodCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnyId() IAnyIdContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsDotMethodCallContext differentiates from other interfaces.
	IsDotMethodCallContext()
}

type DotMethodCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotMethodCallContext() *DotMethodCallContext {
	var p = new(DotMethodCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dotMethodCall
	return p
}

func InitEmptyDotMethodCallContext(p *DotMethodCallContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dotMethodCall
}

func (*DotMethodCallContext) IsDotMethodCallContext() {}

func NewDotMethodCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DotMethodCallContext {
	var p = new(DotMethodCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_dotMethodCall

	return p
}

func (s *DotMethodCallContext) GetParser() antlr.Parser { return s.parser }

func (s *DotMethodCallContext) AnyId() IAnyIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyIdContext)
}

func (s *DotMethodCallContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *DotMethodCallContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *DotMethodCallContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *DotMethodCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DotMethodCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DotMethodCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterDotMethodCall(s)
	}
}

func (s *DotMethodCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitDotMethodCall(s)
	}
}




func (p *ApexParser) DotMethodCall() (localctx IDotMethodCallContext) {
	localctx = NewDotMethodCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ApexParserRULE_dotMethodCall)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1078)
		p.AnyId()
	}
	{
		p.SetState(1079)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1081)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -6177691874033652) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & 18014527361651069) != 0) {
		{
			p.SetState(1080)
			p.ExpressionList()
		}

	}
	{
		p.SetState(1083)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreatorContext is an interface to support dynamic dispatch.
type ICreatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreatedName() ICreatedNameContext
	NoRest() INoRestContext
	ClassCreatorRest() IClassCreatorRestContext
	ArrayCreatorRest() IArrayCreatorRestContext
	MapCreatorRest() IMapCreatorRestContext
	SetCreatorRest() ISetCreatorRestContext

	// IsCreatorContext differentiates from other interfaces.
	IsCreatorContext()
}

type CreatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatorContext() *CreatorContext {
	var p = new(CreatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_creator
	return p
}

func InitEmptyCreatorContext(p *CreatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_creator
}

func (*CreatorContext) IsCreatorContext() {}

func NewCreatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatorContext {
	var p = new(CreatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_creator

	return p
}

func (s *CreatorContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatorContext) CreatedName() ICreatedNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatedNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatedNameContext)
}

func (s *CreatorContext) NoRest() INoRestContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoRestContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoRestContext)
}

func (s *CreatorContext) ClassCreatorRest() IClassCreatorRestContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassCreatorRestContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassCreatorRestContext)
}

func (s *CreatorContext) ArrayCreatorRest() IArrayCreatorRestContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCreatorRestContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCreatorRestContext)
}

func (s *CreatorContext) MapCreatorRest() IMapCreatorRestContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapCreatorRestContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapCreatorRestContext)
}

func (s *CreatorContext) SetCreatorRest() ISetCreatorRestContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetCreatorRestContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetCreatorRestContext)
}

func (s *CreatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterCreator(s)
	}
}

func (s *CreatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitCreator(s)
	}
}




func (p *ApexParser) Creator() (localctx ICreatorContext) {
	localctx = NewCreatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ApexParserRULE_creator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1085)
		p.CreatedName()
	}
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1086)
			p.NoRest()
		}


	case 2:
		{
			p.SetState(1087)
			p.ClassCreatorRest()
		}


	case 3:
		{
			p.SetState(1088)
			p.ArrayCreatorRest()
		}


	case 4:
		{
			p.SetState(1089)
			p.MapCreatorRest()
		}


	case 5:
		{
			p.SetState(1090)
			p.SetCreatorRest()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreatedNameContext is an interface to support dynamic dispatch.
type ICreatedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdCreatedNamePair() []IIdCreatedNamePairContext
	IdCreatedNamePair(i int) IIdCreatedNamePairContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsCreatedNameContext differentiates from other interfaces.
	IsCreatedNameContext()
}

type CreatedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatedNameContext() *CreatedNameContext {
	var p = new(CreatedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_createdName
	return p
}

func InitEmptyCreatedNameContext(p *CreatedNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_createdName
}

func (*CreatedNameContext) IsCreatedNameContext() {}

func NewCreatedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatedNameContext {
	var p = new(CreatedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_createdName

	return p
}

func (s *CreatedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatedNameContext) AllIdCreatedNamePair() []IIdCreatedNamePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdCreatedNamePairContext); ok {
			len++
		}
	}

	tst := make([]IIdCreatedNamePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdCreatedNamePairContext); ok {
			tst[i] = t.(IIdCreatedNamePairContext)
			i++
		}
	}

	return tst
}

func (s *CreatedNameContext) IdCreatedNamePair(i int) IIdCreatedNamePairContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdCreatedNamePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdCreatedNamePairContext)
}

func (s *CreatedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ApexParserDOT)
}

func (s *CreatedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, i)
}

func (s *CreatedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreatedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterCreatedName(s)
	}
}

func (s *CreatedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitCreatedName(s)
	}
}




func (p *ApexParser) CreatedName() (localctx ICreatedNameContext) {
	localctx = NewCreatedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ApexParserRULE_createdName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1093)
		p.IdCreatedNamePair()
	}
	p.SetState(1098)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserDOT {
		{
			p.SetState(1094)
			p.Match(ApexParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1095)
			p.IdCreatedNamePair()
		}


		p.SetState(1100)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIdCreatedNamePairContext is an interface to support dynamic dispatch.
type IIdCreatedNamePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnyId() IAnyIdContext
	LT() antlr.TerminalNode
	TypeList() ITypeListContext
	GT() antlr.TerminalNode

	// IsIdCreatedNamePairContext differentiates from other interfaces.
	IsIdCreatedNamePairContext()
}

type IdCreatedNamePairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdCreatedNamePairContext() *IdCreatedNamePairContext {
	var p = new(IdCreatedNamePairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_idCreatedNamePair
	return p
}

func InitEmptyIdCreatedNamePairContext(p *IdCreatedNamePairContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_idCreatedNamePair
}

func (*IdCreatedNamePairContext) IsIdCreatedNamePairContext() {}

func NewIdCreatedNamePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdCreatedNamePairContext {
	var p = new(IdCreatedNamePairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_idCreatedNamePair

	return p
}

func (s *IdCreatedNamePairContext) GetParser() antlr.Parser { return s.parser }

func (s *IdCreatedNamePairContext) AnyId() IAnyIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyIdContext)
}

func (s *IdCreatedNamePairContext) LT() antlr.TerminalNode {
	return s.GetToken(ApexParserLT, 0)
}

func (s *IdCreatedNamePairContext) TypeList() ITypeListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *IdCreatedNamePairContext) GT() antlr.TerminalNode {
	return s.GetToken(ApexParserGT, 0)
}

func (s *IdCreatedNamePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdCreatedNamePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IdCreatedNamePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterIdCreatedNamePair(s)
	}
}

func (s *IdCreatedNamePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitIdCreatedNamePair(s)
	}
}




func (p *ApexParser) IdCreatedNamePair() (localctx IIdCreatedNamePairContext) {
	localctx = NewIdCreatedNamePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ApexParserRULE_idCreatedNamePair)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1101)
		p.AnyId()
	}
	p.SetState(1106)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserLT {
		{
			p.SetState(1102)
			p.Match(ApexParserLT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1103)
			p.TypeList()
		}
		{
			p.SetState(1104)
			p.Match(ApexParserGT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INoRestContext is an interface to support dynamic dispatch.
type INoRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode

	// IsNoRestContext differentiates from other interfaces.
	IsNoRestContext()
}

type NoRestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoRestContext() *NoRestContext {
	var p = new(NoRestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_noRest
	return p
}

func InitEmptyNoRestContext(p *NoRestContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_noRest
}

func (*NoRestContext) IsNoRestContext() {}

func NewNoRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NoRestContext {
	var p = new(NoRestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_noRest

	return p
}

func (s *NoRestContext) GetParser() antlr.Parser { return s.parser }

func (s *NoRestContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *NoRestContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *NoRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NoRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NoRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterNoRest(s)
	}
}

func (s *NoRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitNoRest(s)
	}
}




func (p *ApexParser) NoRest() (localctx INoRestContext) {
	localctx = NewNoRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ApexParserRULE_noRest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1108)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1109)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IClassCreatorRestContext is an interface to support dynamic dispatch.
type IClassCreatorRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Arguments() IArgumentsContext

	// IsClassCreatorRestContext differentiates from other interfaces.
	IsClassCreatorRestContext()
}

type ClassCreatorRestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassCreatorRestContext() *ClassCreatorRestContext {
	var p = new(ClassCreatorRestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_classCreatorRest
	return p
}

func InitEmptyClassCreatorRestContext(p *ClassCreatorRestContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_classCreatorRest
}

func (*ClassCreatorRestContext) IsClassCreatorRestContext() {}

func NewClassCreatorRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassCreatorRestContext {
	var p = new(ClassCreatorRestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_classCreatorRest

	return p
}

func (s *ClassCreatorRestContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassCreatorRestContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ClassCreatorRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassCreatorRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ClassCreatorRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterClassCreatorRest(s)
	}
}

func (s *ClassCreatorRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitClassCreatorRest(s)
	}
}




func (p *ApexParser) ClassCreatorRest() (localctx IClassCreatorRestContext) {
	localctx = NewClassCreatorRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ApexParserRULE_classCreatorRest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1111)
		p.Arguments()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IArrayCreatorRestContext is an interface to support dynamic dispatch.
type IArrayCreatorRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	Expression() IExpressionContext
	RBRACK() antlr.TerminalNode
	ArrayInitializer() IArrayInitializerContext

	// IsArrayCreatorRestContext differentiates from other interfaces.
	IsArrayCreatorRestContext()
}

type ArrayCreatorRestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayCreatorRestContext() *ArrayCreatorRestContext {
	var p = new(ArrayCreatorRestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_arrayCreatorRest
	return p
}

func InitEmptyArrayCreatorRestContext(p *ArrayCreatorRestContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_arrayCreatorRest
}

func (*ArrayCreatorRestContext) IsArrayCreatorRestContext() {}

func NewArrayCreatorRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayCreatorRestContext {
	var p = new(ArrayCreatorRestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_arrayCreatorRest

	return p
}

func (s *ArrayCreatorRestContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayCreatorRestContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACK, 0)
}

func (s *ArrayCreatorRestContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayCreatorRestContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACK, 0)
}

func (s *ArrayCreatorRestContext) ArrayInitializer() IArrayInitializerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *ArrayCreatorRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCreatorRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArrayCreatorRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterArrayCreatorRest(s)
	}
}

func (s *ArrayCreatorRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitArrayCreatorRest(s)
	}
}




func (p *ApexParser) ArrayCreatorRest() (localctx IArrayCreatorRestContext) {
	localctx = NewArrayCreatorRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ApexParserRULE_arrayCreatorRest)
	p.SetState(1122)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1113)
			p.Match(ApexParserLBRACK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1114)
			p.expression(0)
		}
		{
			p.SetState(1115)
			p.Match(ApexParserRBRACK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1117)
			p.Match(ApexParserLBRACK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1118)
			p.Match(ApexParserRBRACK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1120)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1119)
				p.ArrayInitializer()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMapCreatorRestContext is an interface to support dynamic dispatch.
type IMapCreatorRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	AllMapCreatorRestPair() []IMapCreatorRestPairContext
	MapCreatorRestPair(i int) IMapCreatorRestPairContext
	RBRACE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMapCreatorRestContext differentiates from other interfaces.
	IsMapCreatorRestContext()
}

type MapCreatorRestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapCreatorRestContext() *MapCreatorRestContext {
	var p = new(MapCreatorRestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_mapCreatorRest
	return p
}

func InitEmptyMapCreatorRestContext(p *MapCreatorRestContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_mapCreatorRest
}

func (*MapCreatorRestContext) IsMapCreatorRestContext() {}

func NewMapCreatorRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapCreatorRestContext {
	var p = new(MapCreatorRestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_mapCreatorRest

	return p
}

func (s *MapCreatorRestContext) GetParser() antlr.Parser { return s.parser }

func (s *MapCreatorRestContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *MapCreatorRestContext) AllMapCreatorRestPair() []IMapCreatorRestPairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapCreatorRestPairContext); ok {
			len++
		}
	}

	tst := make([]IMapCreatorRestPairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapCreatorRestPairContext); ok {
			tst[i] = t.(IMapCreatorRestPairContext)
			i++
		}
	}

	return tst
}

func (s *MapCreatorRestContext) MapCreatorRestPair(i int) IMapCreatorRestPairContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapCreatorRestPairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapCreatorRestPairContext)
}

func (s *MapCreatorRestContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *MapCreatorRestContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *MapCreatorRestContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *MapCreatorRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapCreatorRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MapCreatorRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterMapCreatorRest(s)
	}
}

func (s *MapCreatorRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitMapCreatorRest(s)
	}
}




func (p *ApexParser) MapCreatorRest() (localctx IMapCreatorRestContext) {
	localctx = NewMapCreatorRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ApexParserRULE_mapCreatorRest)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1124)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1125)
		p.MapCreatorRestPair()
	}
	p.SetState(1130)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserCOMMA {
		{
			p.SetState(1126)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1127)
			p.MapCreatorRestPair()
		}


		p.SetState(1132)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1133)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMapCreatorRestPairContext is an interface to support dynamic dispatch.
type IMapCreatorRestPairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	MAPTO() antlr.TerminalNode

	// IsMapCreatorRestPairContext differentiates from other interfaces.
	IsMapCreatorRestPairContext()
}

type MapCreatorRestPairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapCreatorRestPairContext() *MapCreatorRestPairContext {
	var p = new(MapCreatorRestPairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_mapCreatorRestPair
	return p
}

func InitEmptyMapCreatorRestPairContext(p *MapCreatorRestPairContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_mapCreatorRestPair
}

func (*MapCreatorRestPairContext) IsMapCreatorRestPairContext() {}

func NewMapCreatorRestPairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapCreatorRestPairContext {
	var p = new(MapCreatorRestPairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_mapCreatorRestPair

	return p
}

func (s *MapCreatorRestPairContext) GetParser() antlr.Parser { return s.parser }

func (s *MapCreatorRestPairContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MapCreatorRestPairContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapCreatorRestPairContext) MAPTO() antlr.TerminalNode {
	return s.GetToken(ApexParserMAPTO, 0)
}

func (s *MapCreatorRestPairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapCreatorRestPairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MapCreatorRestPairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterMapCreatorRestPair(s)
	}
}

func (s *MapCreatorRestPairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitMapCreatorRestPair(s)
	}
}




func (p *ApexParser) MapCreatorRestPair() (localctx IMapCreatorRestPairContext) {
	localctx = NewMapCreatorRestPairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ApexParserRULE_mapCreatorRestPair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1135)
		p.expression(0)
	}
	{
		p.SetState(1136)
		p.Match(ApexParserMAPTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1137)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISetCreatorRestContext is an interface to support dynamic dispatch.
type ISetCreatorRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RBRACE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSetCreatorRestContext differentiates from other interfaces.
	IsSetCreatorRestContext()
}

type SetCreatorRestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetCreatorRestContext() *SetCreatorRestContext {
	var p = new(SetCreatorRestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_setCreatorRest
	return p
}

func InitEmptySetCreatorRestContext(p *SetCreatorRestContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_setCreatorRest
}

func (*SetCreatorRestContext) IsSetCreatorRestContext() {}

func NewSetCreatorRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetCreatorRestContext {
	var p = new(SetCreatorRestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_setCreatorRest

	return p
}

func (s *SetCreatorRestContext) GetParser() antlr.Parser { return s.parser }

func (s *SetCreatorRestContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACE, 0)
}

func (s *SetCreatorRestContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SetCreatorRestContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetCreatorRestContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACE, 0)
}

func (s *SetCreatorRestContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *SetCreatorRestContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *SetCreatorRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCreatorRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SetCreatorRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSetCreatorRest(s)
	}
}

func (s *SetCreatorRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSetCreatorRest(s)
	}
}




func (p *ApexParser) SetCreatorRest() (localctx ISetCreatorRestContext) {
	localctx = NewSetCreatorRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ApexParserRULE_setCreatorRest)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1139)
		p.Match(ApexParserLBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1140)
		p.expression(0)
	}
	p.SetState(1145)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserCOMMA {
		{
			p.SetState(1141)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		{
			p.SetState(1142)
			p.expression(0)
		}



		p.SetState(1147)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1148)
		p.Match(ApexParserRBRACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_arguments
	return p
}

func InitEmptyArgumentsContext(p *ArgumentsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_arguments
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *ArgumentsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *ArgumentsContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitArguments(s)
	}
}




func (p *ApexParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ApexParserRULE_arguments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1150)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1152)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -6177691874033652) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & 18014527361651069) != 0) {
		{
			p.SetState(1151)
			p.ExpressionList()
		}

	}
	{
		p.SetState(1154)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISoqlLiteralContext is an interface to support dynamic dispatch.
type ISoqlLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	Query() IQueryContext
	RBRACK() antlr.TerminalNode

	// IsSoqlLiteralContext differentiates from other interfaces.
	IsSoqlLiteralContext()
}

type SoqlLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoqlLiteralContext() *SoqlLiteralContext {
	var p = new(SoqlLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soqlLiteral
	return p
}

func InitEmptySoqlLiteralContext(p *SoqlLiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soqlLiteral
}

func (*SoqlLiteralContext) IsSoqlLiteralContext() {}

func NewSoqlLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoqlLiteralContext {
	var p = new(SoqlLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soqlLiteral

	return p
}

func (s *SoqlLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SoqlLiteralContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACK, 0)
}

func (s *SoqlLiteralContext) Query() IQueryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SoqlLiteralContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACK, 0)
}

func (s *SoqlLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoqlLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SoqlLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSoqlLiteral(s)
	}
}

func (s *SoqlLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSoqlLiteral(s)
	}
}




func (p *ApexParser) SoqlLiteral() (localctx ISoqlLiteralContext) {
	localctx = NewSoqlLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ApexParserRULE_soqlLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1156)
		p.Match(ApexParserLBRACK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1157)
		p.Query()
	}
	{
		p.SetState(1158)
		p.Match(ApexParserRBRACK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SelectList() ISelectListContext
	FROM() antlr.TerminalNode
	FromNameList() IFromNameListContext
	ForClauses() IForClausesContext
	UsingScope() IUsingScopeContext
	WhereClause() IWhereClauseContext
	WithClause() IWithClauseContext
	GroupByClause() IGroupByClauseContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext
	OffsetClause() IOffsetClauseContext
	AllRowsClause() IAllRowsClauseContext
	UPDATE() antlr.TerminalNode
	UpdateList() IUpdateListContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ApexParserSELECT, 0)
}

func (s *QueryContext) SelectList() ISelectListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectListContext)
}

func (s *QueryContext) FROM() antlr.TerminalNode {
	return s.GetToken(ApexParserFROM, 0)
}

func (s *QueryContext) FromNameList() IFromNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromNameListContext)
}

func (s *QueryContext) ForClauses() IForClausesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForClausesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForClausesContext)
}

func (s *QueryContext) UsingScope() IUsingScopeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingScopeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingScopeContext)
}

func (s *QueryContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *QueryContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *QueryContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *QueryContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *QueryContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QueryContext) OffsetClause() IOffsetClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOffsetClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOffsetClauseContext)
}

func (s *QueryContext) AllRowsClause() IAllRowsClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllRowsClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllRowsClauseContext)
}

func (s *QueryContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ApexParserUPDATE, 0)
}

func (s *QueryContext) UpdateList() IUpdateListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateListContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitQuery(s)
	}
}




func (p *ApexParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ApexParserRULE_query)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1160)
		p.Match(ApexParserSELECT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1161)
		p.SelectList()
	}
	{
		p.SetState(1162)
		p.Match(ApexParserFROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1163)
		p.FromNameList()
	}
	p.SetState(1165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserUSING {
		{
			p.SetState(1164)
			p.UsingScope()
		}

	}
	p.SetState(1168)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserWHERE {
		{
			p.SetState(1167)
			p.WhereClause()
		}

	}
	p.SetState(1171)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserWITH {
		{
			p.SetState(1170)
			p.WithClause()
		}

	}
	p.SetState(1174)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserGROUP {
		{
			p.SetState(1173)
			p.GroupByClause()
		}

	}
	p.SetState(1177)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserORDER {
		{
			p.SetState(1176)
			p.OrderByClause()
		}

	}
	p.SetState(1180)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserLIMIT {
		{
			p.SetState(1179)
			p.LimitClause()
		}

	}
	p.SetState(1183)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserOFFSET {
		{
			p.SetState(1182)
			p.OffsetClause()
		}

	}
	p.SetState(1186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserALL {
		{
			p.SetState(1185)
			p.AllRowsClause()
		}

	}
	{
		p.SetState(1188)
		p.ForClauses()
	}
	p.SetState(1191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserUPDATE {
		{
			p.SetState(1189)
			p.Match(ApexParserUPDATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1190)
			p.UpdateList()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISubQueryContext is an interface to support dynamic dispatch.
type ISubQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SubFieldList() ISubFieldListContext
	FROM() antlr.TerminalNode
	FromNameList() IFromNameListContext
	ForClauses() IForClausesContext
	WhereClause() IWhereClauseContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext
	UPDATE() antlr.TerminalNode
	UpdateList() IUpdateListContext

	// IsSubQueryContext differentiates from other interfaces.
	IsSubQueryContext()
}

type SubQueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubQueryContext() *SubQueryContext {
	var p = new(SubQueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_subQuery
	return p
}

func InitEmptySubQueryContext(p *SubQueryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_subQuery
}

func (*SubQueryContext) IsSubQueryContext() {}

func NewSubQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubQueryContext {
	var p = new(SubQueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_subQuery

	return p
}

func (s *SubQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SubQueryContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ApexParserSELECT, 0)
}

func (s *SubQueryContext) SubFieldList() ISubFieldListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubFieldListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubFieldListContext)
}

func (s *SubQueryContext) FROM() antlr.TerminalNode {
	return s.GetToken(ApexParserFROM, 0)
}

func (s *SubQueryContext) FromNameList() IFromNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromNameListContext)
}

func (s *SubQueryContext) ForClauses() IForClausesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForClausesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForClausesContext)
}

func (s *SubQueryContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *SubQueryContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SubQueryContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *SubQueryContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ApexParserUPDATE, 0)
}

func (s *SubQueryContext) UpdateList() IUpdateListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateListContext)
}

func (s *SubQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SubQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSubQuery(s)
	}
}

func (s *SubQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSubQuery(s)
	}
}




func (p *ApexParser) SubQuery() (localctx ISubQueryContext) {
	localctx = NewSubQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ApexParserRULE_subQuery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1193)
		p.Match(ApexParserSELECT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1194)
		p.SubFieldList()
	}
	{
		p.SetState(1195)
		p.Match(ApexParserFROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1196)
		p.FromNameList()
	}
	p.SetState(1198)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserWHERE {
		{
			p.SetState(1197)
			p.WhereClause()
		}

	}
	p.SetState(1201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserORDER {
		{
			p.SetState(1200)
			p.OrderByClause()
		}

	}
	p.SetState(1204)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserLIMIT {
		{
			p.SetState(1203)
			p.LimitClause()
		}

	}
	{
		p.SetState(1206)
		p.ForClauses()
	}
	p.SetState(1209)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserUPDATE {
		{
			p.SetState(1207)
			p.Match(ApexParserUPDATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1208)
			p.UpdateList()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectListContext is an interface to support dynamic dispatch.
type ISelectListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelectEntry() []ISelectEntryContext
	SelectEntry(i int) ISelectEntryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectListContext differentiates from other interfaces.
	IsSelectListContext()
}

type SelectListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectListContext() *SelectListContext {
	var p = new(SelectListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_selectList
	return p
}

func InitEmptySelectListContext(p *SelectListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_selectList
}

func (*SelectListContext) IsSelectListContext() {}

func NewSelectListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectListContext {
	var p = new(SelectListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_selectList

	return p
}

func (s *SelectListContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectListContext) AllSelectEntry() []ISelectEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectEntryContext); ok {
			len++
		}
	}

	tst := make([]ISelectEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectEntryContext); ok {
			tst[i] = t.(ISelectEntryContext)
			i++
		}
	}

	return tst
}

func (s *SelectListContext) SelectEntry(i int) ISelectEntryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectEntryContext)
}

func (s *SelectListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *SelectListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *SelectListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSelectList(s)
	}
}

func (s *SelectListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSelectList(s)
	}
}




func (p *ApexParser) SelectList() (localctx ISelectListContext) {
	localctx = NewSelectListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ApexParserRULE_selectList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1211)
		p.SelectEntry()
	}
	p.SetState(1216)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserCOMMA {
		{
			p.SetState(1212)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1213)
			p.SelectEntry()
		}


		p.SetState(1218)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectEntryContext is an interface to support dynamic dispatch.
type ISelectEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext
	SoqlId() ISoqlIdContext
	SoqlFunction() ISoqlFunctionContext
	LPAREN() antlr.TerminalNode
	SubQuery() ISubQueryContext
	RPAREN() antlr.TerminalNode
	TypeOf() ITypeOfContext

	// IsSelectEntryContext differentiates from other interfaces.
	IsSelectEntryContext()
}

type SelectEntryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectEntryContext() *SelectEntryContext {
	var p = new(SelectEntryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_selectEntry
	return p
}

func InitEmptySelectEntryContext(p *SelectEntryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_selectEntry
}

func (*SelectEntryContext) IsSelectEntryContext() {}

func NewSelectEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectEntryContext {
	var p = new(SelectEntryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_selectEntry

	return p
}

func (s *SelectEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectEntryContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *SelectEntryContext) SoqlId() ISoqlIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlIdContext)
}

func (s *SelectEntryContext) SoqlFunction() ISoqlFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlFunctionContext)
}

func (s *SelectEntryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *SelectEntryContext) SubQuery() ISubQueryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQueryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQueryContext)
}

func (s *SelectEntryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *SelectEntryContext) TypeOf() ITypeOfContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeOfContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeOfContext)
}

func (s *SelectEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSelectEntry(s)
	}
}

func (s *SelectEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSelectEntry(s)
	}
}




func (p *ApexParser) SelectEntry() (localctx ISelectEntryContext) {
	localctx = NewSelectEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ApexParserRULE_selectEntry)
	p.SetState(1234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1219)
			p.FieldName()
		}
		p.SetState(1221)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1220)
				p.SoqlId()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1223)
			p.SoqlFunction()
		}
		p.SetState(1225)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1224)
				p.SoqlId()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1227)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1228)
			p.SubQuery()
		}
		{
			p.SetState(1229)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1231)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1230)
				p.SoqlId()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1233)
			p.TypeOf()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFieldNameContext is an interface to support dynamic dispatch.
type IFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSoqlId() []ISoqlIdContext
	SoqlId(i int) ISoqlIdContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsFieldNameContext differentiates from other interfaces.
	IsFieldNameContext()
}

type FieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldNameContext() *FieldNameContext {
	var p = new(FieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldName
	return p
}

func InitEmptyFieldNameContext(p *FieldNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldName
}

func (*FieldNameContext) IsFieldNameContext() {}

func NewFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldNameContext {
	var p = new(FieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldName

	return p
}

func (s *FieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldNameContext) AllSoqlId() []ISoqlIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISoqlIdContext); ok {
			len++
		}
	}

	tst := make([]ISoqlIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISoqlIdContext); ok {
			tst[i] = t.(ISoqlIdContext)
			i++
		}
	}

	return tst
}

func (s *FieldNameContext) SoqlId(i int) ISoqlIdContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlIdContext)
}

func (s *FieldNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ApexParserDOT)
}

func (s *FieldNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, i)
}

func (s *FieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterFieldName(s)
	}
}

func (s *FieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitFieldName(s)
	}
}




func (p *ApexParser) FieldName() (localctx IFieldNameContext) {
	localctx = NewFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ApexParserRULE_fieldName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1236)
		p.SoqlId()
	}
	p.SetState(1241)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserDOT {
		{
			p.SetState(1237)
			p.Match(ApexParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1238)
			p.SoqlId()
		}


		p.SetState(1243)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFromNameListContext is an interface to support dynamic dispatch.
type IFromNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFieldName() []IFieldNameContext
	FieldName(i int) IFieldNameContext
	AllSoqlId() []ISoqlIdContext
	SoqlId(i int) ISoqlIdContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFromNameListContext differentiates from other interfaces.
	IsFromNameListContext()
}

type FromNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromNameListContext() *FromNameListContext {
	var p = new(FromNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fromNameList
	return p
}

func InitEmptyFromNameListContext(p *FromNameListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fromNameList
}

func (*FromNameListContext) IsFromNameListContext() {}

func NewFromNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromNameListContext {
	var p = new(FromNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fromNameList

	return p
}

func (s *FromNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *FromNameListContext) AllFieldName() []IFieldNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldNameContext); ok {
			len++
		}
	}

	tst := make([]IFieldNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldNameContext); ok {
			tst[i] = t.(IFieldNameContext)
			i++
		}
	}

	return tst
}

func (s *FromNameListContext) FieldName(i int) IFieldNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *FromNameListContext) AllSoqlId() []ISoqlIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISoqlIdContext); ok {
			len++
		}
	}

	tst := make([]ISoqlIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISoqlIdContext); ok {
			tst[i] = t.(ISoqlIdContext)
			i++
		}
	}

	return tst
}

func (s *FromNameListContext) SoqlId(i int) ISoqlIdContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlIdContext)
}

func (s *FromNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *FromNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *FromNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FromNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterFromNameList(s)
	}
}

func (s *FromNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitFromNameList(s)
	}
}




func (p *ApexParser) FromNameList() (localctx IFromNameListContext) {
	localctx = NewFromNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ApexParserRULE_fromNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1244)
		p.FieldName()
	}
	p.SetState(1246)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1245)
			p.SoqlId()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserCOMMA {
		{
			p.SetState(1248)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1249)
			p.FieldName()
		}
		p.SetState(1251)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1250)
				p.SoqlId()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


		p.SetState(1257)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISubFieldListContext is an interface to support dynamic dispatch.
type ISubFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSubFieldEntry() []ISubFieldEntryContext
	SubFieldEntry(i int) ISubFieldEntryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSubFieldListContext differentiates from other interfaces.
	IsSubFieldListContext()
}

type SubFieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubFieldListContext() *SubFieldListContext {
	var p = new(SubFieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_subFieldList
	return p
}

func InitEmptySubFieldListContext(p *SubFieldListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_subFieldList
}

func (*SubFieldListContext) IsSubFieldListContext() {}

func NewSubFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubFieldListContext {
	var p = new(SubFieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_subFieldList

	return p
}

func (s *SubFieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *SubFieldListContext) AllSubFieldEntry() []ISubFieldEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubFieldEntryContext); ok {
			len++
		}
	}

	tst := make([]ISubFieldEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubFieldEntryContext); ok {
			tst[i] = t.(ISubFieldEntryContext)
			i++
		}
	}

	return tst
}

func (s *SubFieldListContext) SubFieldEntry(i int) ISubFieldEntryContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubFieldEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubFieldEntryContext)
}

func (s *SubFieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *SubFieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *SubFieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubFieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SubFieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSubFieldList(s)
	}
}

func (s *SubFieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSubFieldList(s)
	}
}




func (p *ApexParser) SubFieldList() (localctx ISubFieldListContext) {
	localctx = NewSubFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ApexParserRULE_subFieldList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1258)
		p.SubFieldEntry()
	}
	p.SetState(1263)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserCOMMA {
		{
			p.SetState(1259)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1260)
			p.SubFieldEntry()
		}


		p.SetState(1265)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISubFieldEntryContext is an interface to support dynamic dispatch.
type ISubFieldEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext
	SoqlId() ISoqlIdContext
	SoqlFunction() ISoqlFunctionContext
	LPAREN() antlr.TerminalNode
	SubQuery() ISubQueryContext
	RPAREN() antlr.TerminalNode
	TypeOf() ITypeOfContext

	// IsSubFieldEntryContext differentiates from other interfaces.
	IsSubFieldEntryContext()
}

type SubFieldEntryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubFieldEntryContext() *SubFieldEntryContext {
	var p = new(SubFieldEntryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_subFieldEntry
	return p
}

func InitEmptySubFieldEntryContext(p *SubFieldEntryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_subFieldEntry
}

func (*SubFieldEntryContext) IsSubFieldEntryContext() {}

func NewSubFieldEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubFieldEntryContext {
	var p = new(SubFieldEntryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_subFieldEntry

	return p
}

func (s *SubFieldEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *SubFieldEntryContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *SubFieldEntryContext) SoqlId() ISoqlIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlIdContext)
}

func (s *SubFieldEntryContext) SoqlFunction() ISoqlFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlFunctionContext)
}

func (s *SubFieldEntryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *SubFieldEntryContext) SubQuery() ISubQueryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQueryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQueryContext)
}

func (s *SubFieldEntryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *SubFieldEntryContext) TypeOf() ITypeOfContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeOfContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeOfContext)
}

func (s *SubFieldEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubFieldEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SubFieldEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSubFieldEntry(s)
	}
}

func (s *SubFieldEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSubFieldEntry(s)
	}
}




func (p *ApexParser) SubFieldEntry() (localctx ISubFieldEntryContext) {
	localctx = NewSubFieldEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ApexParserRULE_subFieldEntry)
	p.SetState(1281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1266)
			p.FieldName()
		}
		p.SetState(1268)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1267)
				p.SoqlId()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1270)
			p.SoqlFunction()
		}
		p.SetState(1272)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1271)
				p.SoqlId()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1274)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1275)
			p.SubQuery()
		}
		{
			p.SetState(1276)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1278)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1277)
				p.SoqlId()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1280)
			p.TypeOf()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISoqlFieldsParameterContext is an interface to support dynamic dispatch.
type ISoqlFieldsParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	CUSTOM() antlr.TerminalNode
	STANDARD() antlr.TerminalNode

	// IsSoqlFieldsParameterContext differentiates from other interfaces.
	IsSoqlFieldsParameterContext()
}

type SoqlFieldsParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoqlFieldsParameterContext() *SoqlFieldsParameterContext {
	var p = new(SoqlFieldsParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soqlFieldsParameter
	return p
}

func InitEmptySoqlFieldsParameterContext(p *SoqlFieldsParameterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soqlFieldsParameter
}

func (*SoqlFieldsParameterContext) IsSoqlFieldsParameterContext() {}

func NewSoqlFieldsParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoqlFieldsParameterContext {
	var p = new(SoqlFieldsParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soqlFieldsParameter

	return p
}

func (s *SoqlFieldsParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *SoqlFieldsParameterContext) ALL() antlr.TerminalNode {
	return s.GetToken(ApexParserALL, 0)
}

func (s *SoqlFieldsParameterContext) CUSTOM() antlr.TerminalNode {
	return s.GetToken(ApexParserCUSTOM, 0)
}

func (s *SoqlFieldsParameterContext) STANDARD() antlr.TerminalNode {
	return s.GetToken(ApexParserSTANDARD, 0)
}

func (s *SoqlFieldsParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoqlFieldsParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SoqlFieldsParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSoqlFieldsParameter(s)
	}
}

func (s *SoqlFieldsParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSoqlFieldsParameter(s)
	}
}




func (p *ApexParser) SoqlFieldsParameter() (localctx ISoqlFieldsParameterContext) {
	localctx = NewSoqlFieldsParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ApexParserRULE_soqlFieldsParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1283)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 90)) & ^0x3f) == 0 && ((int64(1) << (_la - 90)) & 6291457) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISoqlFunctionContext is an interface to support dynamic dispatch.
type ISoqlFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AVG() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	FieldName() IFieldNameContext
	RPAREN() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	COUNT_DISTINCT() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MAX() antlr.TerminalNode
	SUM() antlr.TerminalNode
	TOLABEL() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	SoqlFunction() ISoqlFunctionContext
	CALENDAR_MONTH() antlr.TerminalNode
	DateFieldName() IDateFieldNameContext
	CALENDAR_QUARTER() antlr.TerminalNode
	CALENDAR_YEAR() antlr.TerminalNode
	DAY_IN_MONTH() antlr.TerminalNode
	DAY_IN_WEEK() antlr.TerminalNode
	DAY_IN_YEAR() antlr.TerminalNode
	DAY_ONLY() antlr.TerminalNode
	FISCAL_MONTH() antlr.TerminalNode
	FISCAL_QUARTER() antlr.TerminalNode
	FISCAL_YEAR() antlr.TerminalNode
	HOUR_IN_DAY() antlr.TerminalNode
	WEEK_IN_MONTH() antlr.TerminalNode
	WEEK_IN_YEAR() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	SoqlFieldsParameter() ISoqlFieldsParameterContext
	DISTANCE() antlr.TerminalNode
	AllLocationValue() []ILocationValueContext
	LocationValue(i int) ILocationValueContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	CONVERT_CURRENCY() antlr.TerminalNode

	// IsSoqlFunctionContext differentiates from other interfaces.
	IsSoqlFunctionContext()
}

type SoqlFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoqlFunctionContext() *SoqlFunctionContext {
	var p = new(SoqlFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soqlFunction
	return p
}

func InitEmptySoqlFunctionContext(p *SoqlFunctionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soqlFunction
}

func (*SoqlFunctionContext) IsSoqlFunctionContext() {}

func NewSoqlFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoqlFunctionContext {
	var p = new(SoqlFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soqlFunction

	return p
}

func (s *SoqlFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SoqlFunctionContext) AVG() antlr.TerminalNode {
	return s.GetToken(ApexParserAVG, 0)
}

func (s *SoqlFunctionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *SoqlFunctionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *SoqlFunctionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *SoqlFunctionContext) COUNT() antlr.TerminalNode {
	return s.GetToken(ApexParserCOUNT, 0)
}

func (s *SoqlFunctionContext) COUNT_DISTINCT() antlr.TerminalNode {
	return s.GetToken(ApexParserCOUNT_DISTINCT, 0)
}

func (s *SoqlFunctionContext) MIN() antlr.TerminalNode {
	return s.GetToken(ApexParserMIN, 0)
}

func (s *SoqlFunctionContext) MAX() antlr.TerminalNode {
	return s.GetToken(ApexParserMAX, 0)
}

func (s *SoqlFunctionContext) SUM() antlr.TerminalNode {
	return s.GetToken(ApexParserSUM, 0)
}

func (s *SoqlFunctionContext) TOLABEL() antlr.TerminalNode {
	return s.GetToken(ApexParserTOLABEL, 0)
}

func (s *SoqlFunctionContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ApexParserFORMAT, 0)
}

func (s *SoqlFunctionContext) SoqlFunction() ISoqlFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlFunctionContext)
}

func (s *SoqlFunctionContext) CALENDAR_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_MONTH, 0)
}

func (s *SoqlFunctionContext) DateFieldName() IDateFieldNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateFieldNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateFieldNameContext)
}

func (s *SoqlFunctionContext) CALENDAR_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_QUARTER, 0)
}

func (s *SoqlFunctionContext) CALENDAR_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_YEAR, 0)
}

func (s *SoqlFunctionContext) DAY_IN_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_MONTH, 0)
}

func (s *SoqlFunctionContext) DAY_IN_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_WEEK, 0)
}

func (s *SoqlFunctionContext) DAY_IN_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_YEAR, 0)
}

func (s *SoqlFunctionContext) DAY_ONLY() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_ONLY, 0)
}

func (s *SoqlFunctionContext) FISCAL_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_MONTH, 0)
}

func (s *SoqlFunctionContext) FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_QUARTER, 0)
}

func (s *SoqlFunctionContext) FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_YEAR, 0)
}

func (s *SoqlFunctionContext) HOUR_IN_DAY() antlr.TerminalNode {
	return s.GetToken(ApexParserHOUR_IN_DAY, 0)
}

func (s *SoqlFunctionContext) WEEK_IN_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserWEEK_IN_MONTH, 0)
}

func (s *SoqlFunctionContext) WEEK_IN_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserWEEK_IN_YEAR, 0)
}

func (s *SoqlFunctionContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(ApexParserFIELDS, 0)
}

func (s *SoqlFunctionContext) SoqlFieldsParameter() ISoqlFieldsParameterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlFieldsParameterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlFieldsParameterContext)
}

func (s *SoqlFunctionContext) DISTANCE() antlr.TerminalNode {
	return s.GetToken(ApexParserDISTANCE, 0)
}

func (s *SoqlFunctionContext) AllLocationValue() []ILocationValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILocationValueContext); ok {
			len++
		}
	}

	tst := make([]ILocationValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILocationValueContext); ok {
			tst[i] = t.(ILocationValueContext)
			i++
		}
	}

	return tst
}

func (s *SoqlFunctionContext) LocationValue(i int) ILocationValueContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocationValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocationValueContext)
}

func (s *SoqlFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *SoqlFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *SoqlFunctionContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserStringLiteral, 0)
}

func (s *SoqlFunctionContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(ApexParserGROUPING, 0)
}

func (s *SoqlFunctionContext) CONVERT_CURRENCY() antlr.TerminalNode {
	return s.GetToken(ApexParserCONVERT_CURRENCY, 0)
}

func (s *SoqlFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoqlFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SoqlFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSoqlFunction(s)
	}
}

func (s *SoqlFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSoqlFunction(s)
	}
}




func (p *ApexParser) SoqlFunction() (localctx ISoqlFunctionContext) {
	localctx = NewSoqlFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ApexParserRULE_soqlFunction)
	p.SetState(1420)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1285)
			p.Match(ApexParserAVG)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1286)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1287)
			p.FieldName()
		}
		{
			p.SetState(1288)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1290)
			p.Match(ApexParserCOUNT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1291)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1292)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1293)
			p.Match(ApexParserCOUNT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1294)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1295)
			p.FieldName()
		}
		{
			p.SetState(1296)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1298)
			p.Match(ApexParserCOUNT_DISTINCT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1299)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1300)
			p.FieldName()
		}
		{
			p.SetState(1301)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1303)
			p.Match(ApexParserMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1304)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1305)
			p.FieldName()
		}
		{
			p.SetState(1306)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1308)
			p.Match(ApexParserMAX)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1309)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1310)
			p.FieldName()
		}
		{
			p.SetState(1311)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1313)
			p.Match(ApexParserSUM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1314)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1315)
			p.FieldName()
		}
		{
			p.SetState(1316)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1318)
			p.Match(ApexParserTOLABEL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1319)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1320)
			p.FieldName()
		}
		{
			p.SetState(1321)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1323)
			p.Match(ApexParserFORMAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1324)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1325)
				p.FieldName()
			}


		case 2:
			{
				p.SetState(1326)
				p.SoqlFunction()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1329)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1331)
			p.Match(ApexParserCALENDAR_MONTH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1332)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1333)
			p.DateFieldName()
		}
		{
			p.SetState(1334)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1336)
			p.Match(ApexParserCALENDAR_QUARTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1337)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1338)
			p.DateFieldName()
		}
		{
			p.SetState(1339)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1341)
			p.Match(ApexParserCALENDAR_YEAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1342)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1343)
			p.DateFieldName()
		}
		{
			p.SetState(1344)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1346)
			p.Match(ApexParserDAY_IN_MONTH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1347)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1348)
			p.DateFieldName()
		}
		{
			p.SetState(1349)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1351)
			p.Match(ApexParserDAY_IN_WEEK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1352)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1353)
			p.DateFieldName()
		}
		{
			p.SetState(1354)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1356)
			p.Match(ApexParserDAY_IN_YEAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1357)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1358)
			p.DateFieldName()
		}
		{
			p.SetState(1359)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1361)
			p.Match(ApexParserDAY_ONLY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1362)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1363)
			p.DateFieldName()
		}
		{
			p.SetState(1364)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1366)
			p.Match(ApexParserFISCAL_MONTH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1367)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1368)
			p.DateFieldName()
		}
		{
			p.SetState(1369)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1371)
			p.Match(ApexParserFISCAL_QUARTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1372)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1373)
			p.DateFieldName()
		}
		{
			p.SetState(1374)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1376)
			p.Match(ApexParserFISCAL_YEAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1377)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1378)
			p.DateFieldName()
		}
		{
			p.SetState(1379)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1381)
			p.Match(ApexParserHOUR_IN_DAY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1382)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1383)
			p.DateFieldName()
		}
		{
			p.SetState(1384)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1386)
			p.Match(ApexParserWEEK_IN_MONTH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1387)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1388)
			p.DateFieldName()
		}
		{
			p.SetState(1389)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1391)
			p.Match(ApexParserWEEK_IN_YEAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1392)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1393)
			p.DateFieldName()
		}
		{
			p.SetState(1394)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1396)
			p.Match(ApexParserFIELDS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1397)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1398)
			p.SoqlFieldsParameter()
		}
		{
			p.SetState(1399)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1401)
			p.Match(ApexParserDISTANCE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1402)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1403)
			p.LocationValue()
		}
		{
			p.SetState(1404)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1405)
			p.LocationValue()
		}
		{
			p.SetState(1406)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1407)
			p.Match(ApexParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1408)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1410)
			p.Match(ApexParserGROUPING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1411)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1412)
			p.FieldName()
		}
		{
			p.SetState(1413)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1415)
			p.Match(ApexParserCONVERT_CURRENCY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1416)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1417)
			p.FieldName()
		}
		{
			p.SetState(1418)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDateFieldNameContext is an interface to support dynamic dispatch.
type IDateFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONVERT_TIMEZONE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	FieldName() IFieldNameContext
	RPAREN() antlr.TerminalNode

	// IsDateFieldNameContext differentiates from other interfaces.
	IsDateFieldNameContext()
}

type DateFieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateFieldNameContext() *DateFieldNameContext {
	var p = new(DateFieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dateFieldName
	return p
}

func InitEmptyDateFieldNameContext(p *DateFieldNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dateFieldName
}

func (*DateFieldNameContext) IsDateFieldNameContext() {}

func NewDateFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateFieldNameContext {
	var p = new(DateFieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_dateFieldName

	return p
}

func (s *DateFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DateFieldNameContext) CONVERT_TIMEZONE() antlr.TerminalNode {
	return s.GetToken(ApexParserCONVERT_TIMEZONE, 0)
}

func (s *DateFieldNameContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *DateFieldNameContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *DateFieldNameContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *DateFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DateFieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterDateFieldName(s)
	}
}

func (s *DateFieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitDateFieldName(s)
	}
}




func (p *ApexParser) DateFieldName() (localctx IDateFieldNameContext) {
	localctx = NewDateFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ApexParserRULE_dateFieldName)
	p.SetState(1428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1422)
			p.Match(ApexParserCONVERT_TIMEZONE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1423)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1424)
			p.FieldName()
		}
		{
			p.SetState(1425)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1427)
			p.FieldName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILocationValueContext is an interface to support dynamic dispatch.
type ILocationValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext
	BoundExpression() IBoundExpressionContext
	GEOLOCATION() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllCoordinateValue() []ICoordinateValueContext
	CoordinateValue(i int) ICoordinateValueContext
	COMMA() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsLocationValueContext differentiates from other interfaces.
	IsLocationValueContext()
}

type LocationValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocationValueContext() *LocationValueContext {
	var p = new(LocationValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_locationValue
	return p
}

func InitEmptyLocationValueContext(p *LocationValueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_locationValue
}

func (*LocationValueContext) IsLocationValueContext() {}

func NewLocationValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocationValueContext {
	var p = new(LocationValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_locationValue

	return p
}

func (s *LocationValueContext) GetParser() antlr.Parser { return s.parser }

func (s *LocationValueContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *LocationValueContext) BoundExpression() IBoundExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoundExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoundExpressionContext)
}

func (s *LocationValueContext) GEOLOCATION() antlr.TerminalNode {
	return s.GetToken(ApexParserGEOLOCATION, 0)
}

func (s *LocationValueContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *LocationValueContext) AllCoordinateValue() []ICoordinateValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICoordinateValueContext); ok {
			len++
		}
	}

	tst := make([]ICoordinateValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICoordinateValueContext); ok {
			tst[i] = t.(ICoordinateValueContext)
			i++
		}
	}

	return tst
}

func (s *LocationValueContext) CoordinateValue(i int) ICoordinateValueContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICoordinateValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICoordinateValueContext)
}

func (s *LocationValueContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, 0)
}

func (s *LocationValueContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *LocationValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocationValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LocationValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterLocationValue(s)
	}
}

func (s *LocationValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitLocationValue(s)
	}
}




func (p *ApexParser) LocationValue() (localctx ILocationValueContext) {
	localctx = NewLocationValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ApexParserRULE_locationValue)
	p.SetState(1439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1430)
			p.FieldName()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1431)
			p.BoundExpression()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1432)
			p.Match(ApexParserGEOLOCATION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1433)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1434)
			p.CoordinateValue()
		}
		{
			p.SetState(1435)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1436)
			p.CoordinateValue()
		}
		{
			p.SetState(1437)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICoordinateValueContext is an interface to support dynamic dispatch.
type ICoordinateValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SignedNumber() ISignedNumberContext
	BoundExpression() IBoundExpressionContext

	// IsCoordinateValueContext differentiates from other interfaces.
	IsCoordinateValueContext()
}

type CoordinateValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCoordinateValueContext() *CoordinateValueContext {
	var p = new(CoordinateValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_coordinateValue
	return p
}

func InitEmptyCoordinateValueContext(p *CoordinateValueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_coordinateValue
}

func (*CoordinateValueContext) IsCoordinateValueContext() {}

func NewCoordinateValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CoordinateValueContext {
	var p = new(CoordinateValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_coordinateValue

	return p
}

func (s *CoordinateValueContext) GetParser() antlr.Parser { return s.parser }

func (s *CoordinateValueContext) SignedNumber() ISignedNumberContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignedNumberContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignedNumberContext)
}

func (s *CoordinateValueContext) BoundExpression() IBoundExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoundExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoundExpressionContext)
}

func (s *CoordinateValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CoordinateValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CoordinateValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterCoordinateValue(s)
	}
}

func (s *CoordinateValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitCoordinateValue(s)
	}
}




func (p *ApexParser) CoordinateValue() (localctx ICoordinateValueContext) {
	localctx = NewCoordinateValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ApexParserRULE_coordinateValue)
	p.SetState(1443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserIntegerLiteral, ApexParserNumberLiteral, ApexParserADD, ApexParserSUB:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1441)
			p.SignedNumber()
		}


	case ApexParserCOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1442)
			p.BoundExpression()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeOfContext is an interface to support dynamic dispatch.
type ITypeOfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPEOF() antlr.TerminalNode
	FieldName() IFieldNameContext
	END() antlr.TerminalNode
	AllWhenClause() []IWhenClauseContext
	WhenClause(i int) IWhenClauseContext
	ElseClause() IElseClauseContext

	// IsTypeOfContext differentiates from other interfaces.
	IsTypeOfContext()
}

type TypeOfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeOfContext() *TypeOfContext {
	var p = new(TypeOfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeOf
	return p
}

func InitEmptyTypeOfContext(p *TypeOfContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_typeOf
}

func (*TypeOfContext) IsTypeOfContext() {}

func NewTypeOfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeOfContext {
	var p = new(TypeOfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_typeOf

	return p
}

func (s *TypeOfContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeOfContext) TYPEOF() antlr.TerminalNode {
	return s.GetToken(ApexParserTYPEOF, 0)
}

func (s *TypeOfContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *TypeOfContext) END() antlr.TerminalNode {
	return s.GetToken(ApexParserEND, 0)
}

func (s *TypeOfContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *TypeOfContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *TypeOfContext) ElseClause() IElseClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseClauseContext)
}

func (s *TypeOfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeOfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeOfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterTypeOf(s)
	}
}

func (s *TypeOfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitTypeOf(s)
	}
}




func (p *ApexParser) TypeOf() (localctx ITypeOfContext) {
	localctx = NewTypeOfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ApexParserRULE_typeOf)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1445)
		p.Match(ApexParserTYPEOF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1446)
		p.FieldName()
	}
	p.SetState(1448)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == ApexParserWHEN {
		{
			p.SetState(1447)
			p.WhenClause()
		}


		p.SetState(1450)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserELSE {
		{
			p.SetState(1452)
			p.ElseClause()
		}

	}
	{
		p.SetState(1455)
		p.Match(ApexParserEND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN() antlr.TerminalNode
	FieldName() IFieldNameContext
	THEN() antlr.TerminalNode
	FieldNameList() IFieldNameListContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(ApexParserWHEN, 0)
}

func (s *WhenClauseContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(ApexParserTHEN, 0)
}

func (s *WhenClauseContext) FieldNameList() IFieldNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameListContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitWhenClause(s)
	}
}




func (p *ApexParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ApexParserRULE_whenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1457)
		p.Match(ApexParserWHEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1458)
		p.FieldName()
	}
	{
		p.SetState(1459)
		p.Match(ApexParserTHEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1460)
		p.FieldNameList()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IElseClauseContext is an interface to support dynamic dispatch.
type IElseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSE() antlr.TerminalNode
	FieldNameList() IFieldNameListContext

	// IsElseClauseContext differentiates from other interfaces.
	IsElseClauseContext()
}

type ElseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseClauseContext() *ElseClauseContext {
	var p = new(ElseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elseClause
	return p
}

func InitEmptyElseClauseContext(p *ElseClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_elseClause
}

func (*ElseClauseContext) IsElseClauseContext() {}

func NewElseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseClauseContext {
	var p = new(ElseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_elseClause

	return p
}

func (s *ElseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseClauseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ApexParserELSE, 0)
}

func (s *ElseClauseContext) FieldNameList() IFieldNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameListContext)
}

func (s *ElseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ElseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterElseClause(s)
	}
}

func (s *ElseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitElseClause(s)
	}
}




func (p *ApexParser) ElseClause() (localctx IElseClauseContext) {
	localctx = NewElseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, ApexParserRULE_elseClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1462)
		p.Match(ApexParserELSE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1463)
		p.FieldNameList()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFieldNameListContext is an interface to support dynamic dispatch.
type IFieldNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFieldName() []IFieldNameContext
	FieldName(i int) IFieldNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFieldNameListContext differentiates from other interfaces.
	IsFieldNameListContext()
}

type FieldNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldNameListContext() *FieldNameListContext {
	var p = new(FieldNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldNameList
	return p
}

func InitEmptyFieldNameListContext(p *FieldNameListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldNameList
}

func (*FieldNameListContext) IsFieldNameListContext() {}

func NewFieldNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldNameListContext {
	var p = new(FieldNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldNameList

	return p
}

func (s *FieldNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldNameListContext) AllFieldName() []IFieldNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldNameContext); ok {
			len++
		}
	}

	tst := make([]IFieldNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldNameContext); ok {
			tst[i] = t.(IFieldNameContext)
			i++
		}
	}

	return tst
}

func (s *FieldNameListContext) FieldName(i int) IFieldNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *FieldNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *FieldNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *FieldNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FieldNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterFieldNameList(s)
	}
}

func (s *FieldNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitFieldNameList(s)
	}
}




func (p *ApexParser) FieldNameList() (localctx IFieldNameListContext) {
	localctx = NewFieldNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, ApexParserRULE_fieldNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1465)
		p.FieldName()
	}
	p.SetState(1470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserCOMMA {
		{
			p.SetState(1466)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1467)
			p.FieldName()
		}


		p.SetState(1472)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUsingScopeContext is an interface to support dynamic dispatch.
type IUsingScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING() antlr.TerminalNode
	SCOPE() antlr.TerminalNode
	SoqlId() ISoqlIdContext

	// IsUsingScopeContext differentiates from other interfaces.
	IsUsingScopeContext()
}

type UsingScopeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingScopeContext() *UsingScopeContext {
	var p = new(UsingScopeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_usingScope
	return p
}

func InitEmptyUsingScopeContext(p *UsingScopeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_usingScope
}

func (*UsingScopeContext) IsUsingScopeContext() {}

func NewUsingScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingScopeContext {
	var p = new(UsingScopeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_usingScope

	return p
}

func (s *UsingScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingScopeContext) USING() antlr.TerminalNode {
	return s.GetToken(ApexParserUSING, 0)
}

func (s *UsingScopeContext) SCOPE() antlr.TerminalNode {
	return s.GetToken(ApexParserSCOPE, 0)
}

func (s *UsingScopeContext) SoqlId() ISoqlIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlIdContext)
}

func (s *UsingScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UsingScopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterUsingScope(s)
	}
}

func (s *UsingScopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitUsingScope(s)
	}
}




func (p *ApexParser) UsingScope() (localctx IUsingScopeContext) {
	localctx = NewUsingScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, ApexParserRULE_usingScope)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1473)
		p.Match(ApexParserUSING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1474)
		p.Match(ApexParserSCOPE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1475)
		p.SoqlId()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	LogicalExpression() ILogicalExpressionContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ApexParserWHERE, 0)
}

func (s *WhereClauseContext) LogicalExpression() ILogicalExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalExpressionContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitWhereClause(s)
	}
}




func (p *ApexParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, ApexParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1477)
		p.Match(ApexParserWHERE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1478)
		p.LogicalExpression()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILogicalExpressionContext is an interface to support dynamic dispatch.
type ILogicalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConditionalExpression() []IConditionalExpressionContext
	ConditionalExpression(i int) IConditionalExpressionContext
	AllSOQLAND() []antlr.TerminalNode
	SOQLAND(i int) antlr.TerminalNode
	AllSOQLOR() []antlr.TerminalNode
	SOQLOR(i int) antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsLogicalExpressionContext differentiates from other interfaces.
	IsLogicalExpressionContext()
}

type LogicalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalExpressionContext() *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_logicalExpression
	return p
}

func InitEmptyLogicalExpressionContext(p *LogicalExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_logicalExpression
}

func (*LogicalExpressionContext) IsLogicalExpressionContext() {}

func NewLogicalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_logicalExpression

	return p
}

func (s *LogicalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalExpressionContext) AllConditionalExpression() []IConditionalExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			len++
		}
	}

	tst := make([]IConditionalExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConditionalExpressionContext); ok {
			tst[i] = t.(IConditionalExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalExpressionContext) ConditionalExpression(i int) IConditionalExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *LogicalExpressionContext) AllSOQLAND() []antlr.TerminalNode {
	return s.GetTokens(ApexParserSOQLAND)
}

func (s *LogicalExpressionContext) SOQLAND(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserSOQLAND, i)
}

func (s *LogicalExpressionContext) AllSOQLOR() []antlr.TerminalNode {
	return s.GetTokens(ApexParserSOQLOR)
}

func (s *LogicalExpressionContext) SOQLOR(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserSOQLOR, i)
}

func (s *LogicalExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(ApexParserNOT, 0)
}

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LogicalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitLogicalExpression(s)
	}
}




func (p *ApexParser) LogicalExpression() (localctx ILogicalExpressionContext) {
	localctx = NewLogicalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, ApexParserRULE_logicalExpression)
	var _la int

	p.SetState(1498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1480)
			p.ConditionalExpression()
		}
		p.SetState(1485)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == ApexParserSOQLAND {
			{
				p.SetState(1481)
				p.Match(ApexParserSOQLAND)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1482)
				p.ConditionalExpression()
			}


			p.SetState(1487)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1488)
			p.ConditionalExpression()
		}
		p.SetState(1493)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == ApexParserSOQLOR {
			{
				p.SetState(1489)
				p.Match(ApexParserSOQLOR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1490)
				p.ConditionalExpression()
			}


			p.SetState(1495)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1496)
			p.Match(ApexParserNOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1497)
			p.ConditionalExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IConditionalExpressionContext is an interface to support dynamic dispatch.
type IConditionalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	LogicalExpression() ILogicalExpressionContext
	RPAREN() antlr.TerminalNode
	FieldExpression() IFieldExpressionContext

	// IsConditionalExpressionContext differentiates from other interfaces.
	IsConditionalExpressionContext()
}

type ConditionalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalExpressionContext() *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_conditionalExpression
	return p
}

func InitEmptyConditionalExpressionContext(p *ConditionalExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_conditionalExpression
}

func (*ConditionalExpressionContext) IsConditionalExpressionContext() {}

func NewConditionalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_conditionalExpression

	return p
}

func (s *ConditionalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *ConditionalExpressionContext) LogicalExpression() ILogicalExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalExpressionContext)
}

func (s *ConditionalExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *ConditionalExpressionContext) FieldExpression() IFieldExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldExpressionContext)
}

func (s *ConditionalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ConditionalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterConditionalExpression(s)
	}
}

func (s *ConditionalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitConditionalExpression(s)
	}
}




func (p *ApexParser) ConditionalExpression() (localctx IConditionalExpressionContext) {
	localctx = NewConditionalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, ApexParserRULE_conditionalExpression)
	p.SetState(1505)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1500)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1501)
			p.LogicalExpression()
		}
		{
			p.SetState(1502)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserAFTER, ApexParserBEFORE, ApexParserGET, ApexParserINHERITED, ApexParserINSTANCEOF, ApexParserSET, ApexParserSHARING, ApexParserSWITCH, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserWHEN, ApexParserWITH, ApexParserWITHOUT, ApexParserSYSTEM, ApexParserUSER, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserSYSTEM_MODE, ApexParserUSER_MODE, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserDISTANCE, ApexParserGEOLOCATION, ApexParserGROUPING, ApexParserCONVERT_CURRENCY, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserN_DAYS_AGO_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserN_WEEKS_AGO_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserN_MONTHS_AGO_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserN_QUARTERS_AGO_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserN_YEARS_AGO_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserN_FISCAL_QUARTERS_AGO_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserN_FISCAL_YEARS_AGO_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1504)
			p.FieldExpression()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFieldExpressionContext is an interface to support dynamic dispatch.
type IFieldExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext
	ComparisonOperator() IComparisonOperatorContext
	Value() IValueContext
	SoqlFunction() ISoqlFunctionContext

	// IsFieldExpressionContext differentiates from other interfaces.
	IsFieldExpressionContext()
}

type FieldExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldExpressionContext() *FieldExpressionContext {
	var p = new(FieldExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldExpression
	return p
}

func InitEmptyFieldExpressionContext(p *FieldExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldExpression
}

func (*FieldExpressionContext) IsFieldExpressionContext() {}

func NewFieldExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldExpressionContext {
	var p = new(FieldExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldExpression

	return p
}

func (s *FieldExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldExpressionContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *FieldExpressionContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *FieldExpressionContext) Value() IValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *FieldExpressionContext) SoqlFunction() ISoqlFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlFunctionContext)
}

func (s *FieldExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FieldExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterFieldExpression(s)
	}
}

func (s *FieldExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitFieldExpression(s)
	}
}




func (p *ApexParser) FieldExpression() (localctx IFieldExpressionContext) {
	localctx = NewFieldExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, ApexParserRULE_fieldExpression)
	p.SetState(1515)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1507)
			p.FieldName()
		}
		{
			p.SetState(1508)
			p.ComparisonOperator()
		}
		{
			p.SetState(1509)
			p.Value()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1511)
			p.SoqlFunction()
		}
		{
			p.SetState(1512)
			p.ComparisonOperator()
		}
		{
			p.SetState(1513)
			p.Value()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	NOTEQUAL() antlr.TerminalNode
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	LESSANDGREATER() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	IN() antlr.TerminalNode
	NOT() antlr.TerminalNode
	INCLUDES() antlr.TerminalNode
	EXCLUDES() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserASSIGN, 0)
}

func (s *ComparisonOperatorContext) NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(ApexParserNOTEQUAL, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(ApexParserLT, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(ApexParserGT, 0)
}

func (s *ComparisonOperatorContext) LESSANDGREATER() antlr.TerminalNode {
	return s.GetToken(ApexParserLESSANDGREATER, 0)
}

func (s *ComparisonOperatorContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ApexParserLIKE, 0)
}

func (s *ComparisonOperatorContext) IN() antlr.TerminalNode {
	return s.GetToken(ApexParserIN, 0)
}

func (s *ComparisonOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(ApexParserNOT, 0)
}

func (s *ComparisonOperatorContext) INCLUDES() antlr.TerminalNode {
	return s.GetToken(ApexParserINCLUDES, 0)
}

func (s *ComparisonOperatorContext) EXCLUDES() antlr.TerminalNode {
	return s.GetToken(ApexParserEXCLUDES, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}




func (p *ApexParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, ApexParserRULE_comparisonOperator)
	p.SetState(1532)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1517)
			p.Match(ApexParserASSIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1518)
			p.Match(ApexParserNOTEQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1519)
			p.Match(ApexParserLT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1520)
			p.Match(ApexParserGT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1521)
			p.Match(ApexParserLT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1522)
			p.Match(ApexParserASSIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1523)
			p.Match(ApexParserGT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1524)
			p.Match(ApexParserASSIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1525)
			p.Match(ApexParserLESSANDGREATER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1526)
			p.Match(ApexParserLIKE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1527)
			p.Match(ApexParserIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1528)
			p.Match(ApexParserNOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1529)
			p.Match(ApexParserIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1530)
			p.Match(ApexParserINCLUDES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1531)
			p.Match(ApexParserEXCLUDES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL() antlr.TerminalNode
	BooleanLiteral() antlr.TerminalNode
	SignedNumber() ISignedNumberContext
	StringLiteral() antlr.TerminalNode
	DateLiteral() antlr.TerminalNode
	DateTimeLiteral() antlr.TerminalNode
	DateFormula() IDateFormulaContext
	IntegralCurrencyLiteral() antlr.TerminalNode
	DOT() antlr.TerminalNode
	IntegerLiteral() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	SubQuery() ISubQueryContext
	RPAREN() antlr.TerminalNode
	ValueList() IValueListContext
	BoundExpression() IBoundExpressionContext

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_value
	return p
}

func InitEmptyValueContext(p *ValueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_value
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) NULL() antlr.TerminalNode {
	return s.GetToken(ApexParserNULL, 0)
}

func (s *ValueContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserBooleanLiteral, 0)
}

func (s *ValueContext) SignedNumber() ISignedNumberContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignedNumberContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignedNumberContext)
}

func (s *ValueContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserStringLiteral, 0)
}

func (s *ValueContext) DateLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserDateLiteral, 0)
}

func (s *ValueContext) DateTimeLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserDateTimeLiteral, 0)
}

func (s *ValueContext) DateFormula() IDateFormulaContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateFormulaContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateFormulaContext)
}

func (s *ValueContext) IntegralCurrencyLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegralCurrencyLiteral, 0)
}

func (s *ValueContext) DOT() antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, 0)
}

func (s *ValueContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegerLiteral, 0)
}

func (s *ValueContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *ValueContext) SubQuery() ISubQueryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQueryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQueryContext)
}

func (s *ValueContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *ValueContext) ValueList() IValueListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueListContext)
}

func (s *ValueContext) BoundExpression() IBoundExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoundExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoundExpressionContext)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterValue(s)
	}
}

func (s *ValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitValue(s)
	}
}




func (p *ApexParser) Value() (localctx IValueContext) {
	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, ApexParserRULE_value)
	var _la int

	p.SetState(1554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1534)
			p.Match(ApexParserNULL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1535)
			p.Match(ApexParserBooleanLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1536)
			p.SignedNumber()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1537)
			p.Match(ApexParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1538)
			p.Match(ApexParserDateLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1539)
			p.Match(ApexParserDateTimeLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1540)
			p.DateFormula()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1541)
			p.Match(ApexParserIntegralCurrencyLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1546)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == ApexParserDOT {
			{
				p.SetState(1542)
				p.Match(ApexParserDOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(1544)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == ApexParserIntegerLiteral {
				{
					p.SetState(1543)
					p.Match(ApexParserIntegerLiteral)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}

		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1548)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1549)
			p.SubQuery()
		}
		{
			p.SetState(1550)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1552)
			p.ValueList()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1553)
			p.BoundExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValueListContext is an interface to support dynamic dispatch.
type IValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllValue() []IValueContext
	Value(i int) IValueContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsValueListContext differentiates from other interfaces.
	IsValueListContext()
}

type ValueListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueListContext() *ValueListContext {
	var p = new(ValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_valueList
	return p
}

func InitEmptyValueListContext(p *ValueListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_valueList
}

func (*ValueListContext) IsValueListContext() {}

func NewValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueListContext {
	var p = new(ValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_valueList

	return p
}

func (s *ValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueListContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *ValueListContext) AllValue() []IValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueContext); ok {
			len++
		}
	}

	tst := make([]IValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueContext); ok {
			tst[i] = t.(IValueContext)
			i++
		}
	}

	return tst
}

func (s *ValueListContext) Value(i int) IValueContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ValueListContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *ValueListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *ValueListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *ValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterValueList(s)
	}
}

func (s *ValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitValueList(s)
	}
}




func (p *ApexParser) ValueList() (localctx IValueListContext) {
	localctx = NewValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, ApexParserRULE_valueList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1556)
		p.Match(ApexParserLPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1557)
		p.Value()
	}
	p.SetState(1562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserCOMMA {
		{
			p.SetState(1558)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1559)
			p.Value()
		}


		p.SetState(1564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1565)
		p.Match(ApexParserRPAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISignedNumberContext is an interface to support dynamic dispatch.
type ISignedNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntegerLiteral() antlr.TerminalNode
	NumberLiteral() antlr.TerminalNode
	ADD() antlr.TerminalNode
	SUB() antlr.TerminalNode

	// IsSignedNumberContext differentiates from other interfaces.
	IsSignedNumberContext()
}

type SignedNumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignedNumberContext() *SignedNumberContext {
	var p = new(SignedNumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_signedNumber
	return p
}

func InitEmptySignedNumberContext(p *SignedNumberContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_signedNumber
}

func (*SignedNumberContext) IsSignedNumberContext() {}

func NewSignedNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignedNumberContext {
	var p = new(SignedNumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_signedNumber

	return p
}

func (s *SignedNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *SignedNumberContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegerLiteral, 0)
}

func (s *SignedNumberContext) NumberLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserNumberLiteral, 0)
}

func (s *SignedNumberContext) ADD() antlr.TerminalNode {
	return s.GetToken(ApexParserADD, 0)
}

func (s *SignedNumberContext) SUB() antlr.TerminalNode {
	return s.GetToken(ApexParserSUB, 0)
}

func (s *SignedNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignedNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SignedNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSignedNumber(s)
	}
}

func (s *SignedNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSignedNumber(s)
	}
}




func (p *ApexParser) SignedNumber() (localctx ISignedNumberContext) {
	localctx = NewSignedNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, ApexParserRULE_signedNumber)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserADD || _la == ApexParserSUB {
		{
			p.SetState(1567)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ApexParserADD || _la == ApexParserSUB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1570)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ApexParserIntegerLiteral || _la == ApexParserNumberLiteral) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	DATA() antlr.TerminalNode
	CATEGORY() antlr.TerminalNode
	FilteringExpression() IFilteringExpressionContext
	SECURITY_ENFORCED() antlr.TerminalNode
	SYSTEM_MODE() antlr.TerminalNode
	USER_MODE() antlr.TerminalNode
	LogicalExpression() ILogicalExpressionContext

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(ApexParserWITH, 0)
}

func (s *WithClauseContext) DATA() antlr.TerminalNode {
	return s.GetToken(ApexParserDATA, 0)
}

func (s *WithClauseContext) CATEGORY() antlr.TerminalNode {
	return s.GetToken(ApexParserCATEGORY, 0)
}

func (s *WithClauseContext) FilteringExpression() IFilteringExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilteringExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilteringExpressionContext)
}

func (s *WithClauseContext) SECURITY_ENFORCED() antlr.TerminalNode {
	return s.GetToken(ApexParserSECURITY_ENFORCED, 0)
}

func (s *WithClauseContext) SYSTEM_MODE() antlr.TerminalNode {
	return s.GetToken(ApexParserSYSTEM_MODE, 0)
}

func (s *WithClauseContext) USER_MODE() antlr.TerminalNode {
	return s.GetToken(ApexParserUSER_MODE, 0)
}

func (s *WithClauseContext) LogicalExpression() ILogicalExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalExpressionContext)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitWithClause(s)
	}
}




func (p *ApexParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, ApexParserRULE_withClause)
	p.SetState(1584)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 152, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1572)
			p.Match(ApexParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1573)
			p.Match(ApexParserDATA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1574)
			p.Match(ApexParserCATEGORY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1575)
			p.FilteringExpression()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1576)
			p.Match(ApexParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1577)
			p.Match(ApexParserSECURITY_ENFORCED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1578)
			p.Match(ApexParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1579)
			p.Match(ApexParserSYSTEM_MODE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1580)
			p.Match(ApexParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1581)
			p.Match(ApexParserUSER_MODE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1582)
			p.Match(ApexParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1583)
			p.LogicalExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFilteringExpressionContext is an interface to support dynamic dispatch.
type IFilteringExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDataCategorySelection() []IDataCategorySelectionContext
	DataCategorySelection(i int) IDataCategorySelectionContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode

	// IsFilteringExpressionContext differentiates from other interfaces.
	IsFilteringExpressionContext()
}

type FilteringExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilteringExpressionContext() *FilteringExpressionContext {
	var p = new(FilteringExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_filteringExpression
	return p
}

func InitEmptyFilteringExpressionContext(p *FilteringExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_filteringExpression
}

func (*FilteringExpressionContext) IsFilteringExpressionContext() {}

func NewFilteringExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilteringExpressionContext {
	var p = new(FilteringExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_filteringExpression

	return p
}

func (s *FilteringExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FilteringExpressionContext) AllDataCategorySelection() []IDataCategorySelectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataCategorySelectionContext); ok {
			len++
		}
	}

	tst := make([]IDataCategorySelectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataCategorySelectionContext); ok {
			tst[i] = t.(IDataCategorySelectionContext)
			i++
		}
	}

	return tst
}

func (s *FilteringExpressionContext) DataCategorySelection(i int) IDataCategorySelectionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCategorySelectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCategorySelectionContext)
}

func (s *FilteringExpressionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(ApexParserAND)
}

func (s *FilteringExpressionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserAND, i)
}

func (s *FilteringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilteringExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FilteringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterFilteringExpression(s)
	}
}

func (s *FilteringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitFilteringExpression(s)
	}
}




func (p *ApexParser) FilteringExpression() (localctx IFilteringExpressionContext) {
	localctx = NewFilteringExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, ApexParserRULE_filteringExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1586)
		p.DataCategorySelection()
	}
	p.SetState(1591)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserAND {
		{
			p.SetState(1587)
			p.Match(ApexParserAND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1588)
			p.DataCategorySelection()
		}


		p.SetState(1593)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDataCategorySelectionContext is an interface to support dynamic dispatch.
type IDataCategorySelectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SoqlId() ISoqlIdContext
	FilteringSelector() IFilteringSelectorContext
	DataCategoryName() IDataCategoryNameContext

	// IsDataCategorySelectionContext differentiates from other interfaces.
	IsDataCategorySelectionContext()
}

type DataCategorySelectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataCategorySelectionContext() *DataCategorySelectionContext {
	var p = new(DataCategorySelectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dataCategorySelection
	return p
}

func InitEmptyDataCategorySelectionContext(p *DataCategorySelectionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dataCategorySelection
}

func (*DataCategorySelectionContext) IsDataCategorySelectionContext() {}

func NewDataCategorySelectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCategorySelectionContext {
	var p = new(DataCategorySelectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_dataCategorySelection

	return p
}

func (s *DataCategorySelectionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCategorySelectionContext) SoqlId() ISoqlIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlIdContext)
}

func (s *DataCategorySelectionContext) FilteringSelector() IFilteringSelectorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilteringSelectorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilteringSelectorContext)
}

func (s *DataCategorySelectionContext) DataCategoryName() IDataCategoryNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCategoryNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCategoryNameContext)
}

func (s *DataCategorySelectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCategorySelectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DataCategorySelectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterDataCategorySelection(s)
	}
}

func (s *DataCategorySelectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitDataCategorySelection(s)
	}
}




func (p *ApexParser) DataCategorySelection() (localctx IDataCategorySelectionContext) {
	localctx = NewDataCategorySelectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, ApexParserRULE_dataCategorySelection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1594)
		p.SoqlId()
	}
	{
		p.SetState(1595)
		p.FilteringSelector()
	}
	{
		p.SetState(1596)
		p.DataCategoryName()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDataCategoryNameContext is an interface to support dynamic dispatch.
type IDataCategoryNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSoqlId() []ISoqlIdContext
	SoqlId(i int) ISoqlIdContext
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDataCategoryNameContext differentiates from other interfaces.
	IsDataCategoryNameContext()
}

type DataCategoryNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataCategoryNameContext() *DataCategoryNameContext {
	var p = new(DataCategoryNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dataCategoryName
	return p
}

func InitEmptyDataCategoryNameContext(p *DataCategoryNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dataCategoryName
}

func (*DataCategoryNameContext) IsDataCategoryNameContext() {}

func NewDataCategoryNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCategoryNameContext {
	var p = new(DataCategoryNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_dataCategoryName

	return p
}

func (s *DataCategoryNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCategoryNameContext) AllSoqlId() []ISoqlIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISoqlIdContext); ok {
			len++
		}
	}

	tst := make([]ISoqlIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISoqlIdContext); ok {
			tst[i] = t.(ISoqlIdContext)
			i++
		}
	}

	return tst
}

func (s *DataCategoryNameContext) SoqlId(i int) ISoqlIdContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlIdContext)
}

func (s *DataCategoryNameContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ApexParserLPAREN)
}

func (s *DataCategoryNameContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, i)
}

func (s *DataCategoryNameContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *DataCategoryNameContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *DataCategoryNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCategoryNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DataCategoryNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterDataCategoryName(s)
	}
}

func (s *DataCategoryNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitDataCategoryName(s)
	}
}




func (p *ApexParser) DataCategoryName() (localctx IDataCategoryNameContext) {
	localctx = NewDataCategoryNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, ApexParserRULE_dataCategoryName)
	var _la int

	p.SetState(1610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserAFTER, ApexParserBEFORE, ApexParserGET, ApexParserINHERITED, ApexParserINSTANCEOF, ApexParserSET, ApexParserSHARING, ApexParserSWITCH, ApexParserTRANSIENT, ApexParserTRIGGER, ApexParserWHEN, ApexParserWITH, ApexParserWITHOUT, ApexParserSYSTEM, ApexParserUSER, ApexParserSELECT, ApexParserCOUNT, ApexParserFROM, ApexParserAS, ApexParserUSING, ApexParserSCOPE, ApexParserWHERE, ApexParserORDER, ApexParserBY, ApexParserLIMIT, ApexParserSOQLAND, ApexParserSOQLOR, ApexParserNOT, ApexParserAVG, ApexParserCOUNT_DISTINCT, ApexParserMIN, ApexParserMAX, ApexParserSUM, ApexParserTYPEOF, ApexParserEND, ApexParserTHEN, ApexParserLIKE, ApexParserIN, ApexParserINCLUDES, ApexParserEXCLUDES, ApexParserASC, ApexParserDESC, ApexParserNULLS, ApexParserFIRST, ApexParserLAST, ApexParserGROUP, ApexParserALL, ApexParserROWS, ApexParserVIEW, ApexParserHAVING, ApexParserROLLUP, ApexParserTOLABEL, ApexParserOFFSET, ApexParserDATA, ApexParserCATEGORY, ApexParserAT, ApexParserABOVE, ApexParserBELOW, ApexParserABOVE_OR_BELOW, ApexParserSECURITY_ENFORCED, ApexParserSYSTEM_MODE, ApexParserUSER_MODE, ApexParserREFERENCE, ApexParserCUBE, ApexParserFORMAT, ApexParserTRACKING, ApexParserVIEWSTAT, ApexParserCUSTOM, ApexParserSTANDARD, ApexParserDISTANCE, ApexParserGEOLOCATION, ApexParserGROUPING, ApexParserCONVERT_CURRENCY, ApexParserCALENDAR_MONTH, ApexParserCALENDAR_QUARTER, ApexParserCALENDAR_YEAR, ApexParserDAY_IN_MONTH, ApexParserDAY_IN_WEEK, ApexParserDAY_IN_YEAR, ApexParserDAY_ONLY, ApexParserFISCAL_MONTH, ApexParserFISCAL_QUARTER, ApexParserFISCAL_YEAR, ApexParserHOUR_IN_DAY, ApexParserWEEK_IN_MONTH, ApexParserWEEK_IN_YEAR, ApexParserCONVERT_TIMEZONE, ApexParserYESTERDAY, ApexParserTODAY, ApexParserTOMORROW, ApexParserLAST_WEEK, ApexParserTHIS_WEEK, ApexParserNEXT_WEEK, ApexParserLAST_MONTH, ApexParserTHIS_MONTH, ApexParserNEXT_MONTH, ApexParserLAST_90_DAYS, ApexParserNEXT_90_DAYS, ApexParserLAST_N_DAYS_N, ApexParserNEXT_N_DAYS_N, ApexParserN_DAYS_AGO_N, ApexParserNEXT_N_WEEKS_N, ApexParserLAST_N_WEEKS_N, ApexParserN_WEEKS_AGO_N, ApexParserNEXT_N_MONTHS_N, ApexParserLAST_N_MONTHS_N, ApexParserN_MONTHS_AGO_N, ApexParserTHIS_QUARTER, ApexParserLAST_QUARTER, ApexParserNEXT_QUARTER, ApexParserNEXT_N_QUARTERS_N, ApexParserLAST_N_QUARTERS_N, ApexParserN_QUARTERS_AGO_N, ApexParserTHIS_YEAR, ApexParserLAST_YEAR, ApexParserNEXT_YEAR, ApexParserNEXT_N_YEARS_N, ApexParserLAST_N_YEARS_N, ApexParserN_YEARS_AGO_N, ApexParserTHIS_FISCAL_QUARTER, ApexParserLAST_FISCAL_QUARTER, ApexParserNEXT_FISCAL_QUARTER, ApexParserNEXT_N_FISCAL_QUARTERS_N, ApexParserLAST_N_FISCAL_QUARTERS_N, ApexParserN_FISCAL_QUARTERS_AGO_N, ApexParserTHIS_FISCAL_YEAR, ApexParserLAST_FISCAL_YEAR, ApexParserNEXT_FISCAL_YEAR, ApexParserNEXT_N_FISCAL_YEARS_N, ApexParserLAST_N_FISCAL_YEARS_N, ApexParserN_FISCAL_YEARS_AGO_N, ApexParserIntegralCurrencyLiteral, ApexParserFIND, ApexParserEMAIL, ApexParserNAME, ApexParserPHONE, ApexParserSIDEBAR, ApexParserFIELDS, ApexParserMETADATA, ApexParserPRICEBOOKID, ApexParserNETWORK, ApexParserSNIPPET, ApexParserTARGET_LENGTH, ApexParserDIVISION, ApexParserRETURNING, ApexParserLISTVIEW, ApexParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1598)
			p.SoqlId()
		}


	case ApexParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1599)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1600)
			p.SoqlId()
		}
		p.SetState(1605)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == ApexParserCOMMA {
			{
				p.SetState(1601)
				p.Match(ApexParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1602)
				p.SoqlId()
			}


			p.SetState(1607)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1608)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFilteringSelectorContext is an interface to support dynamic dispatch.
type IFilteringSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	ABOVE() antlr.TerminalNode
	BELOW() antlr.TerminalNode
	ABOVE_OR_BELOW() antlr.TerminalNode

	// IsFilteringSelectorContext differentiates from other interfaces.
	IsFilteringSelectorContext()
}

type FilteringSelectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilteringSelectorContext() *FilteringSelectorContext {
	var p = new(FilteringSelectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_filteringSelector
	return p
}

func InitEmptyFilteringSelectorContext(p *FilteringSelectorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_filteringSelector
}

func (*FilteringSelectorContext) IsFilteringSelectorContext() {}

func NewFilteringSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilteringSelectorContext {
	var p = new(FilteringSelectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_filteringSelector

	return p
}

func (s *FilteringSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *FilteringSelectorContext) AT() antlr.TerminalNode {
	return s.GetToken(ApexParserAT, 0)
}

func (s *FilteringSelectorContext) ABOVE() antlr.TerminalNode {
	return s.GetToken(ApexParserABOVE, 0)
}

func (s *FilteringSelectorContext) BELOW() antlr.TerminalNode {
	return s.GetToken(ApexParserBELOW, 0)
}

func (s *FilteringSelectorContext) ABOVE_OR_BELOW() antlr.TerminalNode {
	return s.GetToken(ApexParserABOVE_OR_BELOW, 0)
}

func (s *FilteringSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilteringSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FilteringSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterFilteringSelector(s)
	}
}

func (s *FilteringSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitFilteringSelector(s)
	}
}




func (p *ApexParser) FilteringSelector() (localctx IFilteringSelectorContext) {
	localctx = NewFilteringSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, ApexParserRULE_filteringSelector)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1612)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 99)) & ^0x3f) == 0 && ((int64(1) << (_la - 99)) & 15) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	SelectList() ISelectListContext
	HAVING() antlr.TerminalNode
	LogicalExpression() ILogicalExpressionContext
	ROLLUP() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllFieldName() []IFieldNameContext
	FieldName(i int) IFieldNameContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	CUBE() antlr.TerminalNode

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_groupByClause
	return p
}

func InitEmptyGroupByClauseContext(p *GroupByClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_groupByClause
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(ApexParserGROUP, 0)
}

func (s *GroupByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ApexParserBY, 0)
}

func (s *GroupByClauseContext) SelectList() ISelectListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectListContext)
}

func (s *GroupByClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(ApexParserHAVING, 0)
}

func (s *GroupByClauseContext) LogicalExpression() ILogicalExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalExpressionContext)
}

func (s *GroupByClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(ApexParserROLLUP, 0)
}

func (s *GroupByClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *GroupByClauseContext) AllFieldName() []IFieldNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldNameContext); ok {
			len++
		}
	}

	tst := make([]IFieldNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldNameContext); ok {
			tst[i] = t.(IFieldNameContext)
			i++
		}
	}

	return tst
}

func (s *GroupByClauseContext) FieldName(i int) IFieldNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *GroupByClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *GroupByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *GroupByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *GroupByClauseContext) CUBE() antlr.TerminalNode {
	return s.GetToken(ApexParserCUBE, 0)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}




func (p *ApexParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, ApexParserRULE_groupByClause)
	var _la int

	p.SetState(1649)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1614)
			p.Match(ApexParserGROUP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1615)
			p.Match(ApexParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1616)
			p.SelectList()
		}
		p.SetState(1619)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == ApexParserHAVING {
			{
				p.SetState(1617)
				p.Match(ApexParserHAVING)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1618)
				p.LogicalExpression()
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1621)
			p.Match(ApexParserGROUP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1622)
			p.Match(ApexParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1623)
			p.Match(ApexParserROLLUP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1624)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1625)
			p.FieldName()
		}
		p.SetState(1630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == ApexParserCOMMA {
			{
				p.SetState(1626)
				p.Match(ApexParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1627)
				p.FieldName()
			}


			p.SetState(1632)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1633)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1635)
			p.Match(ApexParserGROUP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1636)
			p.Match(ApexParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1637)
			p.Match(ApexParserCUBE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1638)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1639)
			p.FieldName()
		}
		p.SetState(1644)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == ApexParserCOMMA {
			{
				p.SetState(1640)
				p.Match(ApexParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1641)
				p.FieldName()
			}


			p.SetState(1646)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1647)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	FieldOrderList() IFieldOrderListContext

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_orderByClause
	return p
}

func InitEmptyOrderByClauseContext(p *OrderByClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_orderByClause
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ApexParserORDER, 0)
}

func (s *OrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ApexParserBY, 0)
}

func (s *OrderByClauseContext) FieldOrderList() IFieldOrderListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldOrderListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldOrderListContext)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterOrderByClause(s)
	}
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitOrderByClause(s)
	}
}




func (p *ApexParser) OrderByClause() (localctx IOrderByClauseContext) {
	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, ApexParserRULE_orderByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1651)
		p.Match(ApexParserORDER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1652)
		p.Match(ApexParserBY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1653)
		p.FieldOrderList()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFieldOrderListContext is an interface to support dynamic dispatch.
type IFieldOrderListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFieldOrder() []IFieldOrderContext
	FieldOrder(i int) IFieldOrderContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFieldOrderListContext differentiates from other interfaces.
	IsFieldOrderListContext()
}

type FieldOrderListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldOrderListContext() *FieldOrderListContext {
	var p = new(FieldOrderListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldOrderList
	return p
}

func InitEmptyFieldOrderListContext(p *FieldOrderListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldOrderList
}

func (*FieldOrderListContext) IsFieldOrderListContext() {}

func NewFieldOrderListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldOrderListContext {
	var p = new(FieldOrderListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldOrderList

	return p
}

func (s *FieldOrderListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldOrderListContext) AllFieldOrder() []IFieldOrderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldOrderContext); ok {
			len++
		}
	}

	tst := make([]IFieldOrderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldOrderContext); ok {
			tst[i] = t.(IFieldOrderContext)
			i++
		}
	}

	return tst
}

func (s *FieldOrderListContext) FieldOrder(i int) IFieldOrderContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldOrderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldOrderContext)
}

func (s *FieldOrderListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *FieldOrderListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *FieldOrderListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldOrderListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FieldOrderListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterFieldOrderList(s)
	}
}

func (s *FieldOrderListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitFieldOrderList(s)
	}
}




func (p *ApexParser) FieldOrderList() (localctx IFieldOrderListContext) {
	localctx = NewFieldOrderListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, ApexParserRULE_fieldOrderList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1655)
		p.FieldOrder()
	}
	p.SetState(1660)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserCOMMA {
		{
			p.SetState(1656)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1657)
			p.FieldOrder()
		}


		p.SetState(1662)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFieldOrderContext is an interface to support dynamic dispatch.
type IFieldOrderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext
	NULLS() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode
	SoqlFunction() ISoqlFunctionContext

	// IsFieldOrderContext differentiates from other interfaces.
	IsFieldOrderContext()
}

type FieldOrderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldOrderContext() *FieldOrderContext {
	var p = new(FieldOrderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldOrder
	return p
}

func InitEmptyFieldOrderContext(p *FieldOrderContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldOrder
}

func (*FieldOrderContext) IsFieldOrderContext() {}

func NewFieldOrderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldOrderContext {
	var p = new(FieldOrderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldOrder

	return p
}

func (s *FieldOrderContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldOrderContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *FieldOrderContext) NULLS() antlr.TerminalNode {
	return s.GetToken(ApexParserNULLS, 0)
}

func (s *FieldOrderContext) ASC() antlr.TerminalNode {
	return s.GetToken(ApexParserASC, 0)
}

func (s *FieldOrderContext) DESC() antlr.TerminalNode {
	return s.GetToken(ApexParserDESC, 0)
}

func (s *FieldOrderContext) FIRST() antlr.TerminalNode {
	return s.GetToken(ApexParserFIRST, 0)
}

func (s *FieldOrderContext) LAST() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST, 0)
}

func (s *FieldOrderContext) SoqlFunction() ISoqlFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlFunctionContext)
}

func (s *FieldOrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldOrderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FieldOrderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterFieldOrder(s)
	}
}

func (s *FieldOrderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitFieldOrder(s)
	}
}




func (p *ApexParser) FieldOrder() (localctx IFieldOrderContext) {
	localctx = NewFieldOrderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, ApexParserRULE_fieldOrder)
	var _la int

	p.SetState(1679)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1663)
			p.FieldName()
		}
		p.SetState(1665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == ApexParserASC || _la == ApexParserDESC {
			{
				p.SetState(1664)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ApexParserASC || _la == ApexParserDESC) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1669)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == ApexParserNULLS {
			{
				p.SetState(1667)
				p.Match(ApexParserNULLS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1668)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ApexParserFIRST || _la == ApexParserLAST) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1671)
			p.SoqlFunction()
		}
		p.SetState(1673)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == ApexParserASC || _la == ApexParserDESC {
			{
				p.SetState(1672)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ApexParserASC || _la == ApexParserDESC) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == ApexParserNULLS {
			{
				p.SetState(1675)
				p.Match(ApexParserNULLS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1676)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ApexParserFIRST || _la == ApexParserLAST) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT() antlr.TerminalNode
	IntegerLiteral() antlr.TerminalNode
	BoundExpression() IBoundExpressionContext

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ApexParserLIMIT, 0)
}

func (s *LimitClauseContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegerLiteral, 0)
}

func (s *LimitClauseContext) BoundExpression() IBoundExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoundExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoundExpressionContext)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}




func (p *ApexParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, ApexParserRULE_limitClause)
	p.SetState(1685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1681)
			p.Match(ApexParserLIMIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1682)
			p.Match(ApexParserIntegerLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1683)
			p.Match(ApexParserLIMIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1684)
			p.BoundExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOffsetClauseContext is an interface to support dynamic dispatch.
type IOffsetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OFFSET() antlr.TerminalNode
	IntegerLiteral() antlr.TerminalNode
	BoundExpression() IBoundExpressionContext

	// IsOffsetClauseContext differentiates from other interfaces.
	IsOffsetClauseContext()
}

type OffsetClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOffsetClauseContext() *OffsetClauseContext {
	var p = new(OffsetClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_offsetClause
	return p
}

func InitEmptyOffsetClauseContext(p *OffsetClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_offsetClause
}

func (*OffsetClauseContext) IsOffsetClauseContext() {}

func NewOffsetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OffsetClauseContext {
	var p = new(OffsetClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_offsetClause

	return p
}

func (s *OffsetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OffsetClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(ApexParserOFFSET, 0)
}

func (s *OffsetClauseContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegerLiteral, 0)
}

func (s *OffsetClauseContext) BoundExpression() IBoundExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoundExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoundExpressionContext)
}

func (s *OffsetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OffsetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OffsetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterOffsetClause(s)
	}
}

func (s *OffsetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitOffsetClause(s)
	}
}




func (p *ApexParser) OffsetClause() (localctx IOffsetClauseContext) {
	localctx = NewOffsetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, ApexParserRULE_offsetClause)
	p.SetState(1691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1687)
			p.Match(ApexParserOFFSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1688)
			p.Match(ApexParserIntegerLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1689)
			p.Match(ApexParserOFFSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1690)
			p.BoundExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAllRowsClauseContext is an interface to support dynamic dispatch.
type IAllRowsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	ROWS() antlr.TerminalNode

	// IsAllRowsClauseContext differentiates from other interfaces.
	IsAllRowsClauseContext()
}

type AllRowsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllRowsClauseContext() *AllRowsClauseContext {
	var p = new(AllRowsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_allRowsClause
	return p
}

func InitEmptyAllRowsClauseContext(p *AllRowsClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_allRowsClause
}

func (*AllRowsClauseContext) IsAllRowsClauseContext() {}

func NewAllRowsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllRowsClauseContext {
	var p = new(AllRowsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_allRowsClause

	return p
}

func (s *AllRowsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AllRowsClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(ApexParserALL, 0)
}

func (s *AllRowsClauseContext) ROWS() antlr.TerminalNode {
	return s.GetToken(ApexParserROWS, 0)
}

func (s *AllRowsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllRowsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AllRowsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterAllRowsClause(s)
	}
}

func (s *AllRowsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitAllRowsClause(s)
	}
}




func (p *ApexParser) AllRowsClause() (localctx IAllRowsClauseContext) {
	localctx = NewAllRowsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, ApexParserRULE_allRowsClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1693)
		p.Match(ApexParserALL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1694)
		p.Match(ApexParserROWS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IForClausesContext is an interface to support dynamic dispatch.
type IForClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFOR() []antlr.TerminalNode
	FOR(i int) antlr.TerminalNode
	AllVIEW() []antlr.TerminalNode
	VIEW(i int) antlr.TerminalNode
	AllUPDATE() []antlr.TerminalNode
	UPDATE(i int) antlr.TerminalNode
	AllREFERENCE() []antlr.TerminalNode
	REFERENCE(i int) antlr.TerminalNode

	// IsForClausesContext differentiates from other interfaces.
	IsForClausesContext()
}

type ForClausesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForClausesContext() *ForClausesContext {
	var p = new(ForClausesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forClauses
	return p
}

func InitEmptyForClausesContext(p *ForClausesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_forClauses
}

func (*ForClausesContext) IsForClausesContext() {}

func NewForClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForClausesContext {
	var p = new(ForClausesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_forClauses

	return p
}

func (s *ForClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *ForClausesContext) AllFOR() []antlr.TerminalNode {
	return s.GetTokens(ApexParserFOR)
}

func (s *ForClausesContext) FOR(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserFOR, i)
}

func (s *ForClausesContext) AllVIEW() []antlr.TerminalNode {
	return s.GetTokens(ApexParserVIEW)
}

func (s *ForClausesContext) VIEW(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserVIEW, i)
}

func (s *ForClausesContext) AllUPDATE() []antlr.TerminalNode {
	return s.GetTokens(ApexParserUPDATE)
}

func (s *ForClausesContext) UPDATE(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserUPDATE, i)
}

func (s *ForClausesContext) AllREFERENCE() []antlr.TerminalNode {
	return s.GetTokens(ApexParserREFERENCE)
}

func (s *ForClausesContext) REFERENCE(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserREFERENCE, i)
}

func (s *ForClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ForClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterForClauses(s)
	}
}

func (s *ForClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitForClauses(s)
	}
}




func (p *ApexParser) ForClauses() (localctx IForClausesContext) {
	localctx = NewForClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, ApexParserRULE_forClauses)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1700)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserFOR {
		{
			p.SetState(1696)
			p.Match(ApexParserFOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1697)
			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 46)) & ^0x3f) == 0 && ((int64(1) << (_la - 46)) & 1152991873351024641) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(1702)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBoundExpressionContext is an interface to support dynamic dispatch.
type IBoundExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsBoundExpressionContext differentiates from other interfaces.
	IsBoundExpressionContext()
}

type BoundExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoundExpressionContext() *BoundExpressionContext {
	var p = new(BoundExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_boundExpression
	return p
}

func InitEmptyBoundExpressionContext(p *BoundExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_boundExpression
}

func (*BoundExpressionContext) IsBoundExpressionContext() {}

func NewBoundExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoundExpressionContext {
	var p = new(BoundExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_boundExpression

	return p
}

func (s *BoundExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BoundExpressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(ApexParserCOLON, 0)
}

func (s *BoundExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BoundExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoundExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BoundExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterBoundExpression(s)
	}
}

func (s *BoundExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitBoundExpression(s)
	}
}




func (p *ApexParser) BoundExpression() (localctx IBoundExpressionContext) {
	localctx = NewBoundExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, ApexParserRULE_boundExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1703)
		p.Match(ApexParserCOLON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1704)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDateFormulaContext is an interface to support dynamic dispatch.
type IDateFormulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YESTERDAY() antlr.TerminalNode
	TODAY() antlr.TerminalNode
	TOMORROW() antlr.TerminalNode
	LAST_WEEK() antlr.TerminalNode
	THIS_WEEK() antlr.TerminalNode
	NEXT_WEEK() antlr.TerminalNode
	LAST_MONTH() antlr.TerminalNode
	THIS_MONTH() antlr.TerminalNode
	NEXT_MONTH() antlr.TerminalNode
	LAST_90_DAYS() antlr.TerminalNode
	NEXT_90_DAYS() antlr.TerminalNode
	LAST_N_DAYS_N() antlr.TerminalNode
	COLON() antlr.TerminalNode
	SignedInteger() ISignedIntegerContext
	NEXT_N_DAYS_N() antlr.TerminalNode
	N_DAYS_AGO_N() antlr.TerminalNode
	NEXT_N_WEEKS_N() antlr.TerminalNode
	LAST_N_WEEKS_N() antlr.TerminalNode
	N_WEEKS_AGO_N() antlr.TerminalNode
	NEXT_N_MONTHS_N() antlr.TerminalNode
	LAST_N_MONTHS_N() antlr.TerminalNode
	N_MONTHS_AGO_N() antlr.TerminalNode
	THIS_QUARTER() antlr.TerminalNode
	LAST_QUARTER() antlr.TerminalNode
	NEXT_QUARTER() antlr.TerminalNode
	NEXT_N_QUARTERS_N() antlr.TerminalNode
	LAST_N_QUARTERS_N() antlr.TerminalNode
	N_QUARTERS_AGO_N() antlr.TerminalNode
	THIS_YEAR() antlr.TerminalNode
	LAST_YEAR() antlr.TerminalNode
	NEXT_YEAR() antlr.TerminalNode
	NEXT_N_YEARS_N() antlr.TerminalNode
	LAST_N_YEARS_N() antlr.TerminalNode
	N_YEARS_AGO_N() antlr.TerminalNode
	THIS_FISCAL_QUARTER() antlr.TerminalNode
	LAST_FISCAL_QUARTER() antlr.TerminalNode
	NEXT_FISCAL_QUARTER() antlr.TerminalNode
	NEXT_N_FISCAL_QUARTERS_N() antlr.TerminalNode
	LAST_N_FISCAL_QUARTERS_N() antlr.TerminalNode
	N_FISCAL_QUARTERS_AGO_N() antlr.TerminalNode
	THIS_FISCAL_YEAR() antlr.TerminalNode
	LAST_FISCAL_YEAR() antlr.TerminalNode
	NEXT_FISCAL_YEAR() antlr.TerminalNode
	NEXT_N_FISCAL_YEARS_N() antlr.TerminalNode
	LAST_N_FISCAL_YEARS_N() antlr.TerminalNode
	N_FISCAL_YEARS_AGO_N() antlr.TerminalNode

	// IsDateFormulaContext differentiates from other interfaces.
	IsDateFormulaContext()
}

type DateFormulaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateFormulaContext() *DateFormulaContext {
	var p = new(DateFormulaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dateFormula
	return p
}

func InitEmptyDateFormulaContext(p *DateFormulaContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_dateFormula
}

func (*DateFormulaContext) IsDateFormulaContext() {}

func NewDateFormulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateFormulaContext {
	var p = new(DateFormulaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_dateFormula

	return p
}

func (s *DateFormulaContext) GetParser() antlr.Parser { return s.parser }

func (s *DateFormulaContext) YESTERDAY() antlr.TerminalNode {
	return s.GetToken(ApexParserYESTERDAY, 0)
}

func (s *DateFormulaContext) TODAY() antlr.TerminalNode {
	return s.GetToken(ApexParserTODAY, 0)
}

func (s *DateFormulaContext) TOMORROW() antlr.TerminalNode {
	return s.GetToken(ApexParserTOMORROW, 0)
}

func (s *DateFormulaContext) LAST_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_WEEK, 0)
}

func (s *DateFormulaContext) THIS_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_WEEK, 0)
}

func (s *DateFormulaContext) NEXT_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_WEEK, 0)
}

func (s *DateFormulaContext) LAST_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_MONTH, 0)
}

func (s *DateFormulaContext) THIS_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_MONTH, 0)
}

func (s *DateFormulaContext) NEXT_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_MONTH, 0)
}

func (s *DateFormulaContext) LAST_90_DAYS() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_90_DAYS, 0)
}

func (s *DateFormulaContext) NEXT_90_DAYS() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_90_DAYS, 0)
}

func (s *DateFormulaContext) LAST_N_DAYS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_DAYS_N, 0)
}

func (s *DateFormulaContext) COLON() antlr.TerminalNode {
	return s.GetToken(ApexParserCOLON, 0)
}

func (s *DateFormulaContext) SignedInteger() ISignedIntegerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignedIntegerContext)
}

func (s *DateFormulaContext) NEXT_N_DAYS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_DAYS_N, 0)
}

func (s *DateFormulaContext) N_DAYS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_DAYS_AGO_N, 0)
}

func (s *DateFormulaContext) NEXT_N_WEEKS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_WEEKS_N, 0)
}

func (s *DateFormulaContext) LAST_N_WEEKS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_WEEKS_N, 0)
}

func (s *DateFormulaContext) N_WEEKS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_WEEKS_AGO_N, 0)
}

func (s *DateFormulaContext) NEXT_N_MONTHS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_MONTHS_N, 0)
}

func (s *DateFormulaContext) LAST_N_MONTHS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_MONTHS_N, 0)
}

func (s *DateFormulaContext) N_MONTHS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_MONTHS_AGO_N, 0)
}

func (s *DateFormulaContext) THIS_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_QUARTER, 0)
}

func (s *DateFormulaContext) LAST_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_QUARTER, 0)
}

func (s *DateFormulaContext) NEXT_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_QUARTER, 0)
}

func (s *DateFormulaContext) NEXT_N_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_QUARTERS_N, 0)
}

func (s *DateFormulaContext) LAST_N_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_QUARTERS_N, 0)
}

func (s *DateFormulaContext) N_QUARTERS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_QUARTERS_AGO_N, 0)
}

func (s *DateFormulaContext) THIS_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_YEAR, 0)
}

func (s *DateFormulaContext) LAST_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_YEAR, 0)
}

func (s *DateFormulaContext) NEXT_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_YEAR, 0)
}

func (s *DateFormulaContext) NEXT_N_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_YEARS_N, 0)
}

func (s *DateFormulaContext) LAST_N_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_YEARS_N, 0)
}

func (s *DateFormulaContext) N_YEARS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_YEARS_AGO_N, 0)
}

func (s *DateFormulaContext) THIS_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_FISCAL_QUARTER, 0)
}

func (s *DateFormulaContext) LAST_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_FISCAL_QUARTER, 0)
}

func (s *DateFormulaContext) NEXT_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_FISCAL_QUARTER, 0)
}

func (s *DateFormulaContext) NEXT_N_FISCAL_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_FISCAL_QUARTERS_N, 0)
}

func (s *DateFormulaContext) LAST_N_FISCAL_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_FISCAL_QUARTERS_N, 0)
}

func (s *DateFormulaContext) N_FISCAL_QUARTERS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_FISCAL_QUARTERS_AGO_N, 0)
}

func (s *DateFormulaContext) THIS_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_FISCAL_YEAR, 0)
}

func (s *DateFormulaContext) LAST_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_FISCAL_YEAR, 0)
}

func (s *DateFormulaContext) NEXT_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_FISCAL_YEAR, 0)
}

func (s *DateFormulaContext) NEXT_N_FISCAL_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_FISCAL_YEARS_N, 0)
}

func (s *DateFormulaContext) LAST_N_FISCAL_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_FISCAL_YEARS_N, 0)
}

func (s *DateFormulaContext) N_FISCAL_YEARS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_FISCAL_YEARS_AGO_N, 0)
}

func (s *DateFormulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateFormulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DateFormulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterDateFormula(s)
	}
}

func (s *DateFormulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitDateFormula(s)
	}
}




func (p *ApexParser) DateFormula() (localctx IDateFormulaContext) {
	localctx = NewDateFormulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, ApexParserRULE_dateFormula)
	p.SetState(1792)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserYESTERDAY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1706)
			p.Match(ApexParserYESTERDAY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserTODAY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1707)
			p.Match(ApexParserTODAY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserTOMORROW:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1708)
			p.Match(ApexParserTOMORROW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserLAST_WEEK:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1709)
			p.Match(ApexParserLAST_WEEK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserTHIS_WEEK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1710)
			p.Match(ApexParserTHIS_WEEK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserNEXT_WEEK:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1711)
			p.Match(ApexParserNEXT_WEEK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserLAST_MONTH:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1712)
			p.Match(ApexParserLAST_MONTH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserTHIS_MONTH:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1713)
			p.Match(ApexParserTHIS_MONTH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserNEXT_MONTH:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1714)
			p.Match(ApexParserNEXT_MONTH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserLAST_90_DAYS:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1715)
			p.Match(ApexParserLAST_90_DAYS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserNEXT_90_DAYS:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1716)
			p.Match(ApexParserNEXT_90_DAYS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserLAST_N_DAYS_N:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1717)
			p.Match(ApexParserLAST_N_DAYS_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1718)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1719)
			p.SignedInteger()
		}


	case ApexParserNEXT_N_DAYS_N:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1720)
			p.Match(ApexParserNEXT_N_DAYS_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1721)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1722)
			p.SignedInteger()
		}


	case ApexParserN_DAYS_AGO_N:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1723)
			p.Match(ApexParserN_DAYS_AGO_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1724)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1725)
			p.SignedInteger()
		}


	case ApexParserNEXT_N_WEEKS_N:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1726)
			p.Match(ApexParserNEXT_N_WEEKS_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1727)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1728)
			p.SignedInteger()
		}


	case ApexParserLAST_N_WEEKS_N:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1729)
			p.Match(ApexParserLAST_N_WEEKS_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1730)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1731)
			p.SignedInteger()
		}


	case ApexParserN_WEEKS_AGO_N:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1732)
			p.Match(ApexParserN_WEEKS_AGO_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1733)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1734)
			p.SignedInteger()
		}


	case ApexParserNEXT_N_MONTHS_N:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1735)
			p.Match(ApexParserNEXT_N_MONTHS_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1736)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1737)
			p.SignedInteger()
		}


	case ApexParserLAST_N_MONTHS_N:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1738)
			p.Match(ApexParserLAST_N_MONTHS_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1739)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1740)
			p.SignedInteger()
		}


	case ApexParserN_MONTHS_AGO_N:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1741)
			p.Match(ApexParserN_MONTHS_AGO_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1742)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1743)
			p.SignedInteger()
		}


	case ApexParserTHIS_QUARTER:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1744)
			p.Match(ApexParserTHIS_QUARTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserLAST_QUARTER:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1745)
			p.Match(ApexParserLAST_QUARTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserNEXT_QUARTER:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1746)
			p.Match(ApexParserNEXT_QUARTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserNEXT_N_QUARTERS_N:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1747)
			p.Match(ApexParserNEXT_N_QUARTERS_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1748)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1749)
			p.SignedInteger()
		}


	case ApexParserLAST_N_QUARTERS_N:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1750)
			p.Match(ApexParserLAST_N_QUARTERS_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1751)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1752)
			p.SignedInteger()
		}


	case ApexParserN_QUARTERS_AGO_N:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1753)
			p.Match(ApexParserN_QUARTERS_AGO_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1754)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1755)
			p.SignedInteger()
		}


	case ApexParserTHIS_YEAR:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1756)
			p.Match(ApexParserTHIS_YEAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserLAST_YEAR:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1757)
			p.Match(ApexParserLAST_YEAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserNEXT_YEAR:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1758)
			p.Match(ApexParserNEXT_YEAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserNEXT_N_YEARS_N:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1759)
			p.Match(ApexParserNEXT_N_YEARS_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1760)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1761)
			p.SignedInteger()
		}


	case ApexParserLAST_N_YEARS_N:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1762)
			p.Match(ApexParserLAST_N_YEARS_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1763)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1764)
			p.SignedInteger()
		}


	case ApexParserN_YEARS_AGO_N:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1765)
			p.Match(ApexParserN_YEARS_AGO_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1766)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1767)
			p.SignedInteger()
		}


	case ApexParserTHIS_FISCAL_QUARTER:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1768)
			p.Match(ApexParserTHIS_FISCAL_QUARTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserLAST_FISCAL_QUARTER:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1769)
			p.Match(ApexParserLAST_FISCAL_QUARTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserNEXT_FISCAL_QUARTER:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1770)
			p.Match(ApexParserNEXT_FISCAL_QUARTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserNEXT_N_FISCAL_QUARTERS_N:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1771)
			p.Match(ApexParserNEXT_N_FISCAL_QUARTERS_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1772)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1773)
			p.SignedInteger()
		}


	case ApexParserLAST_N_FISCAL_QUARTERS_N:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1774)
			p.Match(ApexParserLAST_N_FISCAL_QUARTERS_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1775)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1776)
			p.SignedInteger()
		}


	case ApexParserN_FISCAL_QUARTERS_AGO_N:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(1777)
			p.Match(ApexParserN_FISCAL_QUARTERS_AGO_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1778)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1779)
			p.SignedInteger()
		}


	case ApexParserTHIS_FISCAL_YEAR:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(1780)
			p.Match(ApexParserTHIS_FISCAL_YEAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserLAST_FISCAL_YEAR:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(1781)
			p.Match(ApexParserLAST_FISCAL_YEAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserNEXT_FISCAL_YEAR:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(1782)
			p.Match(ApexParserNEXT_FISCAL_YEAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserNEXT_N_FISCAL_YEARS_N:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(1783)
			p.Match(ApexParserNEXT_N_FISCAL_YEARS_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1784)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1785)
			p.SignedInteger()
		}


	case ApexParserLAST_N_FISCAL_YEARS_N:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(1786)
			p.Match(ApexParserLAST_N_FISCAL_YEARS_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1787)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1788)
			p.SignedInteger()
		}


	case ApexParserN_FISCAL_YEARS_AGO_N:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(1789)
			p.Match(ApexParserN_FISCAL_YEARS_AGO_N)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1790)
			p.Match(ApexParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1791)
			p.SignedInteger()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISignedIntegerContext is an interface to support dynamic dispatch.
type ISignedIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntegerLiteral() antlr.TerminalNode
	ADD() antlr.TerminalNode
	SUB() antlr.TerminalNode

	// IsSignedIntegerContext differentiates from other interfaces.
	IsSignedIntegerContext()
}

type SignedIntegerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignedIntegerContext() *SignedIntegerContext {
	var p = new(SignedIntegerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_signedInteger
	return p
}

func InitEmptySignedIntegerContext(p *SignedIntegerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_signedInteger
}

func (*SignedIntegerContext) IsSignedIntegerContext() {}

func NewSignedIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignedIntegerContext {
	var p = new(SignedIntegerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_signedInteger

	return p
}

func (s *SignedIntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *SignedIntegerContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegerLiteral, 0)
}

func (s *SignedIntegerContext) ADD() antlr.TerminalNode {
	return s.GetToken(ApexParserADD, 0)
}

func (s *SignedIntegerContext) SUB() antlr.TerminalNode {
	return s.GetToken(ApexParserSUB, 0)
}

func (s *SignedIntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignedIntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SignedIntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSignedInteger(s)
	}
}

func (s *SignedIntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSignedInteger(s)
	}
}




func (p *ApexParser) SignedInteger() (localctx ISignedIntegerContext) {
	localctx = NewSignedIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, ApexParserRULE_signedInteger)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserADD || _la == ApexParserSUB {
		{
			p.SetState(1794)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ApexParserADD || _la == ApexParserSUB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1797)
		p.Match(ApexParserIntegerLiteral)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISoqlIdContext is an interface to support dynamic dispatch.
type ISoqlIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext

	// IsSoqlIdContext differentiates from other interfaces.
	IsSoqlIdContext()
}

type SoqlIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoqlIdContext() *SoqlIdContext {
	var p = new(SoqlIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soqlId
	return p
}

func InitEmptySoqlIdContext(p *SoqlIdContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soqlId
}

func (*SoqlIdContext) IsSoqlIdContext() {}

func NewSoqlIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoqlIdContext {
	var p = new(SoqlIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soqlId

	return p
}

func (s *SoqlIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SoqlIdContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *SoqlIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoqlIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SoqlIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSoqlId(s)
	}
}

func (s *SoqlIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSoqlId(s)
	}
}




func (p *ApexParser) SoqlId() (localctx ISoqlIdContext) {
	localctx = NewSoqlIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, ApexParserRULE_soqlId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1799)
		p.Id()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISoslLiteralContext is an interface to support dynamic dispatch.
type ISoslLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FindLiteral() antlr.TerminalNode
	SoslClauses() ISoslClausesContext
	RBRACK() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	FIND() antlr.TerminalNode
	BoundExpression() IBoundExpressionContext

	// IsSoslLiteralContext differentiates from other interfaces.
	IsSoslLiteralContext()
}

type SoslLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoslLiteralContext() *SoslLiteralContext {
	var p = new(SoslLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslLiteral
	return p
}

func InitEmptySoslLiteralContext(p *SoslLiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslLiteral
}

func (*SoslLiteralContext) IsSoslLiteralContext() {}

func NewSoslLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoslLiteralContext {
	var p = new(SoslLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soslLiteral

	return p
}

func (s *SoslLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SoslLiteralContext) FindLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserFindLiteral, 0)
}

func (s *SoslLiteralContext) SoslClauses() ISoslClausesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoslClausesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoslClausesContext)
}

func (s *SoslLiteralContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACK, 0)
}

func (s *SoslLiteralContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserLBRACK, 0)
}

func (s *SoslLiteralContext) FIND() antlr.TerminalNode {
	return s.GetToken(ApexParserFIND, 0)
}

func (s *SoslLiteralContext) BoundExpression() IBoundExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoundExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoundExpressionContext)
}

func (s *SoslLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoslLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SoslLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSoslLiteral(s)
	}
}

func (s *SoslLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSoslLiteral(s)
	}
}




func (p *ApexParser) SoslLiteral() (localctx ISoslLiteralContext) {
	localctx = NewSoslLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, ApexParserRULE_soslLiteral)
	p.SetState(1811)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ApexParserFindLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1801)
			p.Match(ApexParserFindLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1802)
			p.SoslClauses()
		}
		{
			p.SetState(1803)
			p.Match(ApexParserRBRACK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case ApexParserLBRACK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1805)
			p.Match(ApexParserLBRACK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1806)
			p.Match(ApexParserFIND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1807)
			p.BoundExpression()
		}
		{
			p.SetState(1808)
			p.SoslClauses()
		}
		{
			p.SetState(1809)
			p.Match(ApexParserRBRACK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISoslLiteralAltContext is an interface to support dynamic dispatch.
type ISoslLiteralAltContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FindLiteralAlt() antlr.TerminalNode
	SoslClauses() ISoslClausesContext
	RBRACK() antlr.TerminalNode

	// IsSoslLiteralAltContext differentiates from other interfaces.
	IsSoslLiteralAltContext()
}

type SoslLiteralAltContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoslLiteralAltContext() *SoslLiteralAltContext {
	var p = new(SoslLiteralAltContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslLiteralAlt
	return p
}

func InitEmptySoslLiteralAltContext(p *SoslLiteralAltContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslLiteralAlt
}

func (*SoslLiteralAltContext) IsSoslLiteralAltContext() {}

func NewSoslLiteralAltContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoslLiteralAltContext {
	var p = new(SoslLiteralAltContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soslLiteralAlt

	return p
}

func (s *SoslLiteralAltContext) GetParser() antlr.Parser { return s.parser }

func (s *SoslLiteralAltContext) FindLiteralAlt() antlr.TerminalNode {
	return s.GetToken(ApexParserFindLiteralAlt, 0)
}

func (s *SoslLiteralAltContext) SoslClauses() ISoslClausesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoslClausesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoslClausesContext)
}

func (s *SoslLiteralAltContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ApexParserRBRACK, 0)
}

func (s *SoslLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoslLiteralAltContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SoslLiteralAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSoslLiteralAlt(s)
	}
}

func (s *SoslLiteralAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSoslLiteralAlt(s)
	}
}




func (p *ApexParser) SoslLiteralAlt() (localctx ISoslLiteralAltContext) {
	localctx = NewSoslLiteralAltContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, ApexParserRULE_soslLiteralAlt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1813)
		p.Match(ApexParserFindLiteralAlt)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1814)
		p.SoslClauses()
	}
	{
		p.SetState(1815)
		p.Match(ApexParserRBRACK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISoslClausesContext is an interface to support dynamic dispatch.
type ISoslClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IN() antlr.TerminalNode
	SearchGroup() ISearchGroupContext
	RETURNING() antlr.TerminalNode
	FieldSpecList() IFieldSpecListContext
	AllSoslWithClause() []ISoslWithClauseContext
	SoslWithClause(i int) ISoslWithClauseContext
	LimitClause() ILimitClauseContext
	UPDATE() antlr.TerminalNode
	UpdateList() IUpdateListContext

	// IsSoslClausesContext differentiates from other interfaces.
	IsSoslClausesContext()
}

type SoslClausesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoslClausesContext() *SoslClausesContext {
	var p = new(SoslClausesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslClauses
	return p
}

func InitEmptySoslClausesContext(p *SoslClausesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslClauses
}

func (*SoslClausesContext) IsSoslClausesContext() {}

func NewSoslClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoslClausesContext {
	var p = new(SoslClausesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soslClauses

	return p
}

func (s *SoslClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *SoslClausesContext) IN() antlr.TerminalNode {
	return s.GetToken(ApexParserIN, 0)
}

func (s *SoslClausesContext) SearchGroup() ISearchGroupContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchGroupContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchGroupContext)
}

func (s *SoslClausesContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(ApexParserRETURNING, 0)
}

func (s *SoslClausesContext) FieldSpecList() IFieldSpecListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldSpecListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldSpecListContext)
}

func (s *SoslClausesContext) AllSoslWithClause() []ISoslWithClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISoslWithClauseContext); ok {
			len++
		}
	}

	tst := make([]ISoslWithClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISoslWithClauseContext); ok {
			tst[i] = t.(ISoslWithClauseContext)
			i++
		}
	}

	return tst
}

func (s *SoslClausesContext) SoslWithClause(i int) ISoslWithClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoslWithClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoslWithClauseContext)
}

func (s *SoslClausesContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *SoslClausesContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ApexParserUPDATE, 0)
}

func (s *SoslClausesContext) UpdateList() IUpdateListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateListContext)
}

func (s *SoslClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoslClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SoslClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSoslClauses(s)
	}
}

func (s *SoslClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSoslClauses(s)
	}
}




func (p *ApexParser) SoslClauses() (localctx ISoslClausesContext) {
	localctx = NewSoslClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, ApexParserRULE_soslClauses)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserIN {
		{
			p.SetState(1817)
			p.Match(ApexParserIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1818)
			p.SearchGroup()
		}

	}
	p.SetState(1823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserRETURNING {
		{
			p.SetState(1821)
			p.Match(ApexParserRETURNING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1822)
			p.FieldSpecList()
		}

	}
	p.SetState(1828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == ApexParserWITH {
		{
			p.SetState(1825)
			p.SoslWithClause()
		}


		p.SetState(1830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserLIMIT {
		{
			p.SetState(1831)
			p.LimitClause()
		}

	}
	p.SetState(1836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserUPDATE {
		{
			p.SetState(1834)
			p.Match(ApexParserUPDATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1835)
			p.UpdateList()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISoslWithClauseContext is an interface to support dynamic dispatch.
type ISoslWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	DIVISION() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	DATA() antlr.TerminalNode
	CATEGORY() antlr.TerminalNode
	FilteringExpression() IFilteringExpressionContext
	SNIPPET() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	TARGET_LENGTH() antlr.TerminalNode
	IntegerLiteral() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	NETWORK() antlr.TerminalNode
	IN() antlr.TerminalNode
	NetworkList() INetworkListContext
	PRICEBOOKID() antlr.TerminalNode
	METADATA() antlr.TerminalNode
	USER_MODE() antlr.TerminalNode
	SYSTEM_MODE() antlr.TerminalNode

	// IsSoslWithClauseContext differentiates from other interfaces.
	IsSoslWithClauseContext()
}

type SoslWithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoslWithClauseContext() *SoslWithClauseContext {
	var p = new(SoslWithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslWithClause
	return p
}

func InitEmptySoslWithClauseContext(p *SoslWithClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslWithClause
}

func (*SoslWithClauseContext) IsSoslWithClauseContext() {}

func NewSoslWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoslWithClauseContext {
	var p = new(SoslWithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soslWithClause

	return p
}

func (s *SoslWithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SoslWithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(ApexParserWITH, 0)
}

func (s *SoslWithClauseContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(ApexParserDIVISION, 0)
}

func (s *SoslWithClauseContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserASSIGN, 0)
}

func (s *SoslWithClauseContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserStringLiteral, 0)
}

func (s *SoslWithClauseContext) DATA() antlr.TerminalNode {
	return s.GetToken(ApexParserDATA, 0)
}

func (s *SoslWithClauseContext) CATEGORY() antlr.TerminalNode {
	return s.GetToken(ApexParserCATEGORY, 0)
}

func (s *SoslWithClauseContext) FilteringExpression() IFilteringExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilteringExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilteringExpressionContext)
}

func (s *SoslWithClauseContext) SNIPPET() antlr.TerminalNode {
	return s.GetToken(ApexParserSNIPPET, 0)
}

func (s *SoslWithClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *SoslWithClauseContext) TARGET_LENGTH() antlr.TerminalNode {
	return s.GetToken(ApexParserTARGET_LENGTH, 0)
}

func (s *SoslWithClauseContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegerLiteral, 0)
}

func (s *SoslWithClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *SoslWithClauseContext) NETWORK() antlr.TerminalNode {
	return s.GetToken(ApexParserNETWORK, 0)
}

func (s *SoslWithClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(ApexParserIN, 0)
}

func (s *SoslWithClauseContext) NetworkList() INetworkListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INetworkListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INetworkListContext)
}

func (s *SoslWithClauseContext) PRICEBOOKID() antlr.TerminalNode {
	return s.GetToken(ApexParserPRICEBOOKID, 0)
}

func (s *SoslWithClauseContext) METADATA() antlr.TerminalNode {
	return s.GetToken(ApexParserMETADATA, 0)
}

func (s *SoslWithClauseContext) USER_MODE() antlr.TerminalNode {
	return s.GetToken(ApexParserUSER_MODE, 0)
}

func (s *SoslWithClauseContext) SYSTEM_MODE() antlr.TerminalNode {
	return s.GetToken(ApexParserSYSTEM_MODE, 0)
}

func (s *SoslWithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoslWithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SoslWithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSoslWithClause(s)
	}
}

func (s *SoslWithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSoslWithClause(s)
	}
}




func (p *ApexParser) SoslWithClause() (localctx ISoslWithClauseContext) {
	localctx = NewSoslWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, ApexParserRULE_soslWithClause)
	var _la int

	p.SetState(1878)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1838)
			p.Match(ApexParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1839)
			p.Match(ApexParserDIVISION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1840)
			p.Match(ApexParserASSIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1841)
			p.Match(ApexParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1842)
			p.Match(ApexParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1843)
			p.Match(ApexParserDATA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1844)
			p.Match(ApexParserCATEGORY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1845)
			p.FilteringExpression()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1846)
			p.Match(ApexParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1847)
			p.Match(ApexParserSNIPPET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1853)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == ApexParserLPAREN {
			{
				p.SetState(1848)
				p.Match(ApexParserLPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1849)
				p.Match(ApexParserTARGET_LENGTH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1850)
				p.Match(ApexParserASSIGN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1851)
				p.Match(ApexParserIntegerLiteral)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1852)
				p.Match(ApexParserRPAREN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1855)
			p.Match(ApexParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1856)
			p.Match(ApexParserNETWORK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1857)
			p.Match(ApexParserIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1858)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1859)
			p.NetworkList()
		}
		{
			p.SetState(1860)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1862)
			p.Match(ApexParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1863)
			p.Match(ApexParserNETWORK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1864)
			p.Match(ApexParserASSIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1865)
			p.Match(ApexParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1866)
			p.Match(ApexParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1867)
			p.Match(ApexParserPRICEBOOKID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1868)
			p.Match(ApexParserASSIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1869)
			p.Match(ApexParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1870)
			p.Match(ApexParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1871)
			p.Match(ApexParserMETADATA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1872)
			p.Match(ApexParserASSIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1873)
			p.Match(ApexParserStringLiteral)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1874)
			p.Match(ApexParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1875)
			p.Match(ApexParserUSER_MODE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1876)
			p.Match(ApexParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1877)
			p.Match(ApexParserSYSTEM_MODE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISearchGroupContext is an interface to support dynamic dispatch.
type ISearchGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FIELDS() antlr.TerminalNode
	ALL() antlr.TerminalNode
	EMAIL() antlr.TerminalNode
	NAME() antlr.TerminalNode
	PHONE() antlr.TerminalNode
	SIDEBAR() antlr.TerminalNode

	// IsSearchGroupContext differentiates from other interfaces.
	IsSearchGroupContext()
}

type SearchGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchGroupContext() *SearchGroupContext {
	var p = new(SearchGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_searchGroup
	return p
}

func InitEmptySearchGroupContext(p *SearchGroupContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_searchGroup
}

func (*SearchGroupContext) IsSearchGroupContext() {}

func NewSearchGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchGroupContext {
	var p = new(SearchGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_searchGroup

	return p
}

func (s *SearchGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchGroupContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(ApexParserFIELDS, 0)
}

func (s *SearchGroupContext) ALL() antlr.TerminalNode {
	return s.GetToken(ApexParserALL, 0)
}

func (s *SearchGroupContext) EMAIL() antlr.TerminalNode {
	return s.GetToken(ApexParserEMAIL, 0)
}

func (s *SearchGroupContext) NAME() antlr.TerminalNode {
	return s.GetToken(ApexParserNAME, 0)
}

func (s *SearchGroupContext) PHONE() antlr.TerminalNode {
	return s.GetToken(ApexParserPHONE, 0)
}

func (s *SearchGroupContext) SIDEBAR() antlr.TerminalNode {
	return s.GetToken(ApexParserSIDEBAR, 0)
}

func (s *SearchGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SearchGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSearchGroup(s)
	}
}

func (s *SearchGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSearchGroup(s)
	}
}




func (p *ApexParser) SearchGroup() (localctx ISearchGroupContext) {
	localctx = NewSearchGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, ApexParserRULE_searchGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1880)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ApexParserALL || ((int64((_la - 179)) & ^0x3f) == 0 && ((int64(1) << (_la - 179)) & 15) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1881)
		p.Match(ApexParserFIELDS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFieldSpecListContext is an interface to support dynamic dispatch.
type IFieldSpecListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldSpec() IFieldSpecContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllFieldSpecList() []IFieldSpecListContext
	FieldSpecList(i int) IFieldSpecListContext

	// IsFieldSpecListContext differentiates from other interfaces.
	IsFieldSpecListContext()
}

type FieldSpecListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldSpecListContext() *FieldSpecListContext {
	var p = new(FieldSpecListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldSpecList
	return p
}

func InitEmptyFieldSpecListContext(p *FieldSpecListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldSpecList
}

func (*FieldSpecListContext) IsFieldSpecListContext() {}

func NewFieldSpecListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldSpecListContext {
	var p = new(FieldSpecListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldSpecList

	return p
}

func (s *FieldSpecListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldSpecListContext) FieldSpec() IFieldSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldSpecContext)
}

func (s *FieldSpecListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *FieldSpecListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *FieldSpecListContext) AllFieldSpecList() []IFieldSpecListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldSpecListContext); ok {
			len++
		}
	}

	tst := make([]IFieldSpecListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldSpecListContext); ok {
			tst[i] = t.(IFieldSpecListContext)
			i++
		}
	}

	return tst
}

func (s *FieldSpecListContext) FieldSpecList(i int) IFieldSpecListContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldSpecListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldSpecListContext)
}

func (s *FieldSpecListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldSpecListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FieldSpecListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterFieldSpecList(s)
	}
}

func (s *FieldSpecListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitFieldSpecList(s)
	}
}




func (p *ApexParser) FieldSpecList() (localctx IFieldSpecListContext) {
	localctx = NewFieldSpecListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, ApexParserRULE_fieldSpecList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1883)
		p.FieldSpec()
	}
	p.SetState(1888)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1884)
				p.Match(ApexParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1885)
				p.FieldSpecList()
			}


		}
		p.SetState(1890)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFieldSpecContext is an interface to support dynamic dispatch.
type IFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSoslId() []ISoslIdContext
	SoslId(i int) ISoslIdContext
	LPAREN() antlr.TerminalNode
	FieldList() IFieldListContext
	RPAREN() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	LogicalExpression() ILogicalExpressionContext
	USING() antlr.TerminalNode
	LISTVIEW() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	FieldOrderList() IFieldOrderListContext
	LimitClause() ILimitClauseContext
	OffsetClause() IOffsetClauseContext

	// IsFieldSpecContext differentiates from other interfaces.
	IsFieldSpecContext()
}

type FieldSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldSpecContext() *FieldSpecContext {
	var p = new(FieldSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldSpec
	return p
}

func InitEmptyFieldSpecContext(p *FieldSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldSpec
}

func (*FieldSpecContext) IsFieldSpecContext() {}

func NewFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldSpecContext {
	var p = new(FieldSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldSpec

	return p
}

func (s *FieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldSpecContext) AllSoslId() []ISoslIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISoslIdContext); ok {
			len++
		}
	}

	tst := make([]ISoslIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISoslIdContext); ok {
			tst[i] = t.(ISoslIdContext)
			i++
		}
	}

	return tst
}

func (s *FieldSpecContext) SoslId(i int) ISoslIdContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoslIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoslIdContext)
}

func (s *FieldSpecContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *FieldSpecContext) FieldList() IFieldListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *FieldSpecContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *FieldSpecContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ApexParserWHERE, 0)
}

func (s *FieldSpecContext) LogicalExpression() ILogicalExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalExpressionContext)
}

func (s *FieldSpecContext) USING() antlr.TerminalNode {
	return s.GetToken(ApexParserUSING, 0)
}

func (s *FieldSpecContext) LISTVIEW() antlr.TerminalNode {
	return s.GetToken(ApexParserLISTVIEW, 0)
}

func (s *FieldSpecContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ApexParserASSIGN, 0)
}

func (s *FieldSpecContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ApexParserORDER, 0)
}

func (s *FieldSpecContext) BY() antlr.TerminalNode {
	return s.GetToken(ApexParserBY, 0)
}

func (s *FieldSpecContext) FieldOrderList() IFieldOrderListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldOrderListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldOrderListContext)
}

func (s *FieldSpecContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *FieldSpecContext) OffsetClause() IOffsetClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOffsetClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOffsetClauseContext)
}

func (s *FieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterFieldSpec(s)
	}
}

func (s *FieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitFieldSpec(s)
	}
}




func (p *ApexParser) FieldSpec() (localctx IFieldSpecContext) {
	localctx = NewFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, ApexParserRULE_fieldSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1891)
		p.SoslId()
	}
	p.SetState(1917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserLPAREN {
		{
			p.SetState(1892)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1893)
			p.FieldList()
		}
		p.SetState(1896)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == ApexParserWHERE {
			{
				p.SetState(1894)
				p.Match(ApexParserWHERE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1895)
				p.LogicalExpression()
			}

		}
		p.SetState(1902)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == ApexParserUSING {
			{
				p.SetState(1898)
				p.Match(ApexParserUSING)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1899)
				p.Match(ApexParserLISTVIEW)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1900)
				p.Match(ApexParserASSIGN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1901)
				p.SoslId()
			}

		}
		p.SetState(1907)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == ApexParserORDER {
			{
				p.SetState(1904)
				p.Match(ApexParserORDER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1905)
				p.Match(ApexParserBY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1906)
				p.FieldOrderList()
			}

		}
		p.SetState(1910)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == ApexParserLIMIT {
			{
				p.SetState(1909)
				p.LimitClause()
			}

		}
		p.SetState(1913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == ApexParserOFFSET {
			{
				p.SetState(1912)
				p.OffsetClause()
			}

		}
		{
			p.SetState(1915)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFieldListContext is an interface to support dynamic dispatch.
type IFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSoslId() []ISoslIdContext
	SoslId(i int) ISoslIdContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllFieldList() []IFieldListContext
	FieldList(i int) IFieldListContext
	TOLABEL() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	CONVERT_CURRENCY() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	SoqlFunction() ISoqlFunctionContext

	// IsFieldListContext differentiates from other interfaces.
	IsFieldListContext()
}

type FieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldListContext() *FieldListContext {
	var p = new(FieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldList
	return p
}

func InitEmptyFieldListContext(p *FieldListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_fieldList
}

func (*FieldListContext) IsFieldListContext() {}

func NewFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldListContext {
	var p = new(FieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_fieldList

	return p
}

func (s *FieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldListContext) AllSoslId() []ISoslIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISoslIdContext); ok {
			len++
		}
	}

	tst := make([]ISoslIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISoslIdContext); ok {
			tst[i] = t.(ISoslIdContext)
			i++
		}
	}

	return tst
}

func (s *FieldListContext) SoslId(i int) ISoslIdContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoslIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoslIdContext)
}

func (s *FieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ApexParserCOMMA)
}

func (s *FieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, i)
}

func (s *FieldListContext) AllFieldList() []IFieldListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldListContext); ok {
			len++
		}
	}

	tst := make([]IFieldListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldListContext); ok {
			tst[i] = t.(IFieldListContext)
			i++
		}
	}

	return tst
}

func (s *FieldListContext) FieldList(i int) IFieldListContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *FieldListContext) TOLABEL() antlr.TerminalNode {
	return s.GetToken(ApexParserTOLABEL, 0)
}

func (s *FieldListContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserLPAREN, 0)
}

func (s *FieldListContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ApexParserRPAREN, 0)
}

func (s *FieldListContext) CONVERT_CURRENCY() antlr.TerminalNode {
	return s.GetToken(ApexParserCONVERT_CURRENCY, 0)
}

func (s *FieldListContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ApexParserFORMAT, 0)
}

func (s *FieldListContext) SoqlFunction() ISoqlFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoqlFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoqlFunctionContext)
}

func (s *FieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterFieldList(s)
	}
}

func (s *FieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitFieldList(s)
	}
}




func (p *ApexParser) FieldList() (localctx IFieldListContext) {
	localctx = NewFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, ApexParserRULE_fieldList)
	var _alt int

	p.SetState(1951)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1919)
			p.SoslId()
		}
		p.SetState(1924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1920)
					p.Match(ApexParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1921)
					p.FieldList()
				}


			}
			p.SetState(1926)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1927)
			p.Match(ApexParserTOLABEL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1928)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1929)
			p.SoslId()
		}
		{
			p.SetState(1930)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1932)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 187, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1931)
				p.SoslId()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1934)
			p.Match(ApexParserCONVERT_CURRENCY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1935)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1936)
			p.SoslId()
		}
		{
			p.SetState(1937)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1939)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1938)
				p.SoslId()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1941)
			p.Match(ApexParserFORMAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1942)
			p.Match(ApexParserLPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1945)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1943)
				p.SoslId()
			}


		case 2:
			{
				p.SetState(1944)
				p.SoqlFunction()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1947)
			p.Match(ApexParserRPAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1949)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1948)
				p.SoslId()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUpdateListContext is an interface to support dynamic dispatch.
type IUpdateListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UpdateType() IUpdateTypeContext
	COMMA() antlr.TerminalNode
	UpdateList() IUpdateListContext

	// IsUpdateListContext differentiates from other interfaces.
	IsUpdateListContext()
}

type UpdateListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateListContext() *UpdateListContext {
	var p = new(UpdateListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_updateList
	return p
}

func InitEmptyUpdateListContext(p *UpdateListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_updateList
}

func (*UpdateListContext) IsUpdateListContext() {}

func NewUpdateListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateListContext {
	var p = new(UpdateListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_updateList

	return p
}

func (s *UpdateListContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateListContext) UpdateType() IUpdateTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateTypeContext)
}

func (s *UpdateListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, 0)
}

func (s *UpdateListContext) UpdateList() IUpdateListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateListContext)
}

func (s *UpdateListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UpdateListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterUpdateList(s)
	}
}

func (s *UpdateListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitUpdateList(s)
	}
}




func (p *ApexParser) UpdateList() (localctx IUpdateListContext) {
	localctx = NewUpdateListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, ApexParserRULE_updateList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1953)
		p.UpdateType()
	}
	p.SetState(1956)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserCOMMA {
		{
			p.SetState(1954)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1955)
			p.UpdateList()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUpdateTypeContext is an interface to support dynamic dispatch.
type IUpdateTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRACKING() antlr.TerminalNode
	VIEWSTAT() antlr.TerminalNode

	// IsUpdateTypeContext differentiates from other interfaces.
	IsUpdateTypeContext()
}

type UpdateTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateTypeContext() *UpdateTypeContext {
	var p = new(UpdateTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_updateType
	return p
}

func InitEmptyUpdateTypeContext(p *UpdateTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_updateType
}

func (*UpdateTypeContext) IsUpdateTypeContext() {}

func NewUpdateTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateTypeContext {
	var p = new(UpdateTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_updateType

	return p
}

func (s *UpdateTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateTypeContext) TRACKING() antlr.TerminalNode {
	return s.GetToken(ApexParserTRACKING, 0)
}

func (s *UpdateTypeContext) VIEWSTAT() antlr.TerminalNode {
	return s.GetToken(ApexParserVIEWSTAT, 0)
}

func (s *UpdateTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UpdateTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterUpdateType(s)
	}
}

func (s *UpdateTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitUpdateType(s)
	}
}




func (p *ApexParser) UpdateType() (localctx IUpdateTypeContext) {
	localctx = NewUpdateTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, ApexParserRULE_updateType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1958)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ApexParserTRACKING || _la == ApexParserVIEWSTAT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INetworkListContext is an interface to support dynamic dispatch.
type INetworkListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	NetworkList() INetworkListContext

	// IsNetworkListContext differentiates from other interfaces.
	IsNetworkListContext()
}

type NetworkListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNetworkListContext() *NetworkListContext {
	var p = new(NetworkListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_networkList
	return p
}

func InitEmptyNetworkListContext(p *NetworkListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_networkList
}

func (*NetworkListContext) IsNetworkListContext() {}

func NewNetworkListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NetworkListContext {
	var p = new(NetworkListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_networkList

	return p
}

func (s *NetworkListContext) GetParser() antlr.Parser { return s.parser }

func (s *NetworkListContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserStringLiteral, 0)
}

func (s *NetworkListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ApexParserCOMMA, 0)
}

func (s *NetworkListContext) NetworkList() INetworkListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INetworkListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INetworkListContext)
}

func (s *NetworkListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NetworkListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NetworkListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterNetworkList(s)
	}
}

func (s *NetworkListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitNetworkList(s)
	}
}




func (p *ApexParser) NetworkList() (localctx INetworkListContext) {
	localctx = NewNetworkListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, ApexParserRULE_networkList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1960)
		p.Match(ApexParserStringLiteral)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1963)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == ApexParserCOMMA {
		{
			p.SetState(1961)
			p.Match(ApexParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1962)
			p.NetworkList()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISoslIdContext is an interface to support dynamic dispatch.
type ISoslIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Id() IIdContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllSoslId() []ISoslIdContext
	SoslId(i int) ISoslIdContext

	// IsSoslIdContext differentiates from other interfaces.
	IsSoslIdContext()
}

type SoslIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoslIdContext() *SoslIdContext {
	var p = new(SoslIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslId
	return p
}

func InitEmptySoslIdContext(p *SoslIdContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_soslId
}

func (*SoslIdContext) IsSoslIdContext() {}

func NewSoslIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoslIdContext {
	var p = new(SoslIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_soslId

	return p
}

func (s *SoslIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SoslIdContext) Id() IIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *SoslIdContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ApexParserDOT)
}

func (s *SoslIdContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ApexParserDOT, i)
}

func (s *SoslIdContext) AllSoslId() []ISoslIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISoslIdContext); ok {
			len++
		}
	}

	tst := make([]ISoslIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISoslIdContext); ok {
			tst[i] = t.(ISoslIdContext)
			i++
		}
	}

	return tst
}

func (s *SoslIdContext) SoslId(i int) ISoslIdContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISoslIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISoslIdContext)
}

func (s *SoslIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoslIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SoslIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterSoslId(s)
	}
}

func (s *SoslIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitSoslId(s)
	}
}




func (p *ApexParser) SoslId() (localctx ISoslIdContext) {
	localctx = NewSoslIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, ApexParserRULE_soslId)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1965)
		p.Id()
	}
	p.SetState(1970)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1966)
				p.Match(ApexParserDOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1967)
				p.SoslId()
			}


		}
		p.SetState(1972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIdContext is an interface to support dynamic dispatch.
type IIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	GET() antlr.TerminalNode
	INHERITED() antlr.TerminalNode
	INSTANCEOF() antlr.TerminalNode
	SET() antlr.TerminalNode
	SHARING() antlr.TerminalNode
	SWITCH() antlr.TerminalNode
	TRANSIENT() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	WHEN() antlr.TerminalNode
	WITH() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	USER() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	IntegralCurrencyLiteral() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	FROM() antlr.TerminalNode
	AS() antlr.TerminalNode
	USING() antlr.TerminalNode
	SCOPE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	SOQLAND() antlr.TerminalNode
	SOQLOR() antlr.TerminalNode
	NOT() antlr.TerminalNode
	AVG() antlr.TerminalNode
	COUNT_DISTINCT() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MAX() antlr.TerminalNode
	SUM() antlr.TerminalNode
	TYPEOF() antlr.TerminalNode
	END() antlr.TerminalNode
	THEN() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	IN() antlr.TerminalNode
	INCLUDES() antlr.TerminalNode
	EXCLUDES() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	HAVING() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	TOLABEL() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	DATA() antlr.TerminalNode
	CATEGORY() antlr.TerminalNode
	AT() antlr.TerminalNode
	ABOVE() antlr.TerminalNode
	BELOW() antlr.TerminalNode
	ABOVE_OR_BELOW() antlr.TerminalNode
	SECURITY_ENFORCED() antlr.TerminalNode
	USER_MODE() antlr.TerminalNode
	SYSTEM_MODE() antlr.TerminalNode
	REFERENCE() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	TRACKING() antlr.TerminalNode
	VIEWSTAT() antlr.TerminalNode
	STANDARD() antlr.TerminalNode
	CUSTOM() antlr.TerminalNode
	DISTANCE() antlr.TerminalNode
	GEOLOCATION() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	CONVERT_CURRENCY() antlr.TerminalNode
	CALENDAR_MONTH() antlr.TerminalNode
	CALENDAR_QUARTER() antlr.TerminalNode
	CALENDAR_YEAR() antlr.TerminalNode
	DAY_IN_MONTH() antlr.TerminalNode
	DAY_IN_WEEK() antlr.TerminalNode
	DAY_IN_YEAR() antlr.TerminalNode
	DAY_ONLY() antlr.TerminalNode
	FISCAL_MONTH() antlr.TerminalNode
	FISCAL_QUARTER() antlr.TerminalNode
	FISCAL_YEAR() antlr.TerminalNode
	HOUR_IN_DAY() antlr.TerminalNode
	WEEK_IN_MONTH() antlr.TerminalNode
	WEEK_IN_YEAR() antlr.TerminalNode
	CONVERT_TIMEZONE() antlr.TerminalNode
	YESTERDAY() antlr.TerminalNode
	TODAY() antlr.TerminalNode
	TOMORROW() antlr.TerminalNode
	LAST_WEEK() antlr.TerminalNode
	THIS_WEEK() antlr.TerminalNode
	NEXT_WEEK() antlr.TerminalNode
	LAST_MONTH() antlr.TerminalNode
	THIS_MONTH() antlr.TerminalNode
	NEXT_MONTH() antlr.TerminalNode
	LAST_90_DAYS() antlr.TerminalNode
	NEXT_90_DAYS() antlr.TerminalNode
	LAST_N_DAYS_N() antlr.TerminalNode
	NEXT_N_DAYS_N() antlr.TerminalNode
	N_DAYS_AGO_N() antlr.TerminalNode
	NEXT_N_WEEKS_N() antlr.TerminalNode
	LAST_N_WEEKS_N() antlr.TerminalNode
	N_WEEKS_AGO_N() antlr.TerminalNode
	NEXT_N_MONTHS_N() antlr.TerminalNode
	LAST_N_MONTHS_N() antlr.TerminalNode
	N_MONTHS_AGO_N() antlr.TerminalNode
	THIS_QUARTER() antlr.TerminalNode
	LAST_QUARTER() antlr.TerminalNode
	NEXT_QUARTER() antlr.TerminalNode
	NEXT_N_QUARTERS_N() antlr.TerminalNode
	LAST_N_QUARTERS_N() antlr.TerminalNode
	N_QUARTERS_AGO_N() antlr.TerminalNode
	THIS_YEAR() antlr.TerminalNode
	LAST_YEAR() antlr.TerminalNode
	NEXT_YEAR() antlr.TerminalNode
	NEXT_N_YEARS_N() antlr.TerminalNode
	LAST_N_YEARS_N() antlr.TerminalNode
	N_YEARS_AGO_N() antlr.TerminalNode
	THIS_FISCAL_QUARTER() antlr.TerminalNode
	LAST_FISCAL_QUARTER() antlr.TerminalNode
	NEXT_FISCAL_QUARTER() antlr.TerminalNode
	NEXT_N_FISCAL_QUARTERS_N() antlr.TerminalNode
	LAST_N_FISCAL_QUARTERS_N() antlr.TerminalNode
	N_FISCAL_QUARTERS_AGO_N() antlr.TerminalNode
	THIS_FISCAL_YEAR() antlr.TerminalNode
	LAST_FISCAL_YEAR() antlr.TerminalNode
	NEXT_FISCAL_YEAR() antlr.TerminalNode
	NEXT_N_FISCAL_YEARS_N() antlr.TerminalNode
	LAST_N_FISCAL_YEARS_N() antlr.TerminalNode
	N_FISCAL_YEARS_AGO_N() antlr.TerminalNode
	FIND() antlr.TerminalNode
	EMAIL() antlr.TerminalNode
	NAME() antlr.TerminalNode
	PHONE() antlr.TerminalNode
	SIDEBAR() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	METADATA() antlr.TerminalNode
	PRICEBOOKID() antlr.TerminalNode
	NETWORK() antlr.TerminalNode
	SNIPPET() antlr.TerminalNode
	TARGET_LENGTH() antlr.TerminalNode
	DIVISION() antlr.TerminalNode
	RETURNING() antlr.TerminalNode
	LISTVIEW() antlr.TerminalNode

	// IsIdContext differentiates from other interfaces.
	IsIdContext()
}

type IdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdContext() *IdContext {
	var p = new(IdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_id
	return p
}

func InitEmptyIdContext(p *IdContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_id
}

func (*IdContext) IsIdContext() {}

func NewIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdContext {
	var p = new(IdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_id

	return p
}

func (s *IdContext) GetParser() antlr.Parser { return s.parser }

func (s *IdContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ApexParserIdentifier, 0)
}

func (s *IdContext) AFTER() antlr.TerminalNode {
	return s.GetToken(ApexParserAFTER, 0)
}

func (s *IdContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(ApexParserBEFORE, 0)
}

func (s *IdContext) GET() antlr.TerminalNode {
	return s.GetToken(ApexParserGET, 0)
}

func (s *IdContext) INHERITED() antlr.TerminalNode {
	return s.GetToken(ApexParserINHERITED, 0)
}

func (s *IdContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(ApexParserINSTANCEOF, 0)
}

func (s *IdContext) SET() antlr.TerminalNode {
	return s.GetToken(ApexParserSET, 0)
}

func (s *IdContext) SHARING() antlr.TerminalNode {
	return s.GetToken(ApexParserSHARING, 0)
}

func (s *IdContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(ApexParserSWITCH, 0)
}

func (s *IdContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(ApexParserTRANSIENT, 0)
}

func (s *IdContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(ApexParserTRIGGER, 0)
}

func (s *IdContext) WHEN() antlr.TerminalNode {
	return s.GetToken(ApexParserWHEN, 0)
}

func (s *IdContext) WITH() antlr.TerminalNode {
	return s.GetToken(ApexParserWITH, 0)
}

func (s *IdContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(ApexParserWITHOUT, 0)
}

func (s *IdContext) USER() antlr.TerminalNode {
	return s.GetToken(ApexParserUSER, 0)
}

func (s *IdContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(ApexParserSYSTEM, 0)
}

func (s *IdContext) IntegralCurrencyLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegralCurrencyLiteral, 0)
}

func (s *IdContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ApexParserSELECT, 0)
}

func (s *IdContext) COUNT() antlr.TerminalNode {
	return s.GetToken(ApexParserCOUNT, 0)
}

func (s *IdContext) FROM() antlr.TerminalNode {
	return s.GetToken(ApexParserFROM, 0)
}

func (s *IdContext) AS() antlr.TerminalNode {
	return s.GetToken(ApexParserAS, 0)
}

func (s *IdContext) USING() antlr.TerminalNode {
	return s.GetToken(ApexParserUSING, 0)
}

func (s *IdContext) SCOPE() antlr.TerminalNode {
	return s.GetToken(ApexParserSCOPE, 0)
}

func (s *IdContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ApexParserWHERE, 0)
}

func (s *IdContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ApexParserORDER, 0)
}

func (s *IdContext) BY() antlr.TerminalNode {
	return s.GetToken(ApexParserBY, 0)
}

func (s *IdContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ApexParserLIMIT, 0)
}

func (s *IdContext) SOQLAND() antlr.TerminalNode {
	return s.GetToken(ApexParserSOQLAND, 0)
}

func (s *IdContext) SOQLOR() antlr.TerminalNode {
	return s.GetToken(ApexParserSOQLOR, 0)
}

func (s *IdContext) NOT() antlr.TerminalNode {
	return s.GetToken(ApexParserNOT, 0)
}

func (s *IdContext) AVG() antlr.TerminalNode {
	return s.GetToken(ApexParserAVG, 0)
}

func (s *IdContext) COUNT_DISTINCT() antlr.TerminalNode {
	return s.GetToken(ApexParserCOUNT_DISTINCT, 0)
}

func (s *IdContext) MIN() antlr.TerminalNode {
	return s.GetToken(ApexParserMIN, 0)
}

func (s *IdContext) MAX() antlr.TerminalNode {
	return s.GetToken(ApexParserMAX, 0)
}

func (s *IdContext) SUM() antlr.TerminalNode {
	return s.GetToken(ApexParserSUM, 0)
}

func (s *IdContext) TYPEOF() antlr.TerminalNode {
	return s.GetToken(ApexParserTYPEOF, 0)
}

func (s *IdContext) END() antlr.TerminalNode {
	return s.GetToken(ApexParserEND, 0)
}

func (s *IdContext) THEN() antlr.TerminalNode {
	return s.GetToken(ApexParserTHEN, 0)
}

func (s *IdContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ApexParserLIKE, 0)
}

func (s *IdContext) IN() antlr.TerminalNode {
	return s.GetToken(ApexParserIN, 0)
}

func (s *IdContext) INCLUDES() antlr.TerminalNode {
	return s.GetToken(ApexParserINCLUDES, 0)
}

func (s *IdContext) EXCLUDES() antlr.TerminalNode {
	return s.GetToken(ApexParserEXCLUDES, 0)
}

func (s *IdContext) ASC() antlr.TerminalNode {
	return s.GetToken(ApexParserASC, 0)
}

func (s *IdContext) DESC() antlr.TerminalNode {
	return s.GetToken(ApexParserDESC, 0)
}

func (s *IdContext) NULLS() antlr.TerminalNode {
	return s.GetToken(ApexParserNULLS, 0)
}

func (s *IdContext) FIRST() antlr.TerminalNode {
	return s.GetToken(ApexParserFIRST, 0)
}

func (s *IdContext) LAST() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST, 0)
}

func (s *IdContext) GROUP() antlr.TerminalNode {
	return s.GetToken(ApexParserGROUP, 0)
}

func (s *IdContext) ALL() antlr.TerminalNode {
	return s.GetToken(ApexParserALL, 0)
}

func (s *IdContext) ROWS() antlr.TerminalNode {
	return s.GetToken(ApexParserROWS, 0)
}

func (s *IdContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ApexParserVIEW, 0)
}

func (s *IdContext) HAVING() antlr.TerminalNode {
	return s.GetToken(ApexParserHAVING, 0)
}

func (s *IdContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(ApexParserROLLUP, 0)
}

func (s *IdContext) TOLABEL() antlr.TerminalNode {
	return s.GetToken(ApexParserTOLABEL, 0)
}

func (s *IdContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(ApexParserOFFSET, 0)
}

func (s *IdContext) DATA() antlr.TerminalNode {
	return s.GetToken(ApexParserDATA, 0)
}

func (s *IdContext) CATEGORY() antlr.TerminalNode {
	return s.GetToken(ApexParserCATEGORY, 0)
}

func (s *IdContext) AT() antlr.TerminalNode {
	return s.GetToken(ApexParserAT, 0)
}

func (s *IdContext) ABOVE() antlr.TerminalNode {
	return s.GetToken(ApexParserABOVE, 0)
}

func (s *IdContext) BELOW() antlr.TerminalNode {
	return s.GetToken(ApexParserBELOW, 0)
}

func (s *IdContext) ABOVE_OR_BELOW() antlr.TerminalNode {
	return s.GetToken(ApexParserABOVE_OR_BELOW, 0)
}

func (s *IdContext) SECURITY_ENFORCED() antlr.TerminalNode {
	return s.GetToken(ApexParserSECURITY_ENFORCED, 0)
}

func (s *IdContext) USER_MODE() antlr.TerminalNode {
	return s.GetToken(ApexParserUSER_MODE, 0)
}

func (s *IdContext) SYSTEM_MODE() antlr.TerminalNode {
	return s.GetToken(ApexParserSYSTEM_MODE, 0)
}

func (s *IdContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(ApexParserREFERENCE, 0)
}

func (s *IdContext) CUBE() antlr.TerminalNode {
	return s.GetToken(ApexParserCUBE, 0)
}

func (s *IdContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ApexParserFORMAT, 0)
}

func (s *IdContext) TRACKING() antlr.TerminalNode {
	return s.GetToken(ApexParserTRACKING, 0)
}

func (s *IdContext) VIEWSTAT() antlr.TerminalNode {
	return s.GetToken(ApexParserVIEWSTAT, 0)
}

func (s *IdContext) STANDARD() antlr.TerminalNode {
	return s.GetToken(ApexParserSTANDARD, 0)
}

func (s *IdContext) CUSTOM() antlr.TerminalNode {
	return s.GetToken(ApexParserCUSTOM, 0)
}

func (s *IdContext) DISTANCE() antlr.TerminalNode {
	return s.GetToken(ApexParserDISTANCE, 0)
}

func (s *IdContext) GEOLOCATION() antlr.TerminalNode {
	return s.GetToken(ApexParserGEOLOCATION, 0)
}

func (s *IdContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(ApexParserGROUPING, 0)
}

func (s *IdContext) CONVERT_CURRENCY() antlr.TerminalNode {
	return s.GetToken(ApexParserCONVERT_CURRENCY, 0)
}

func (s *IdContext) CALENDAR_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_MONTH, 0)
}

func (s *IdContext) CALENDAR_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_QUARTER, 0)
}

func (s *IdContext) CALENDAR_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_YEAR, 0)
}

func (s *IdContext) DAY_IN_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_MONTH, 0)
}

func (s *IdContext) DAY_IN_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_WEEK, 0)
}

func (s *IdContext) DAY_IN_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_YEAR, 0)
}

func (s *IdContext) DAY_ONLY() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_ONLY, 0)
}

func (s *IdContext) FISCAL_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_MONTH, 0)
}

func (s *IdContext) FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_QUARTER, 0)
}

func (s *IdContext) FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_YEAR, 0)
}

func (s *IdContext) HOUR_IN_DAY() antlr.TerminalNode {
	return s.GetToken(ApexParserHOUR_IN_DAY, 0)
}

func (s *IdContext) WEEK_IN_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserWEEK_IN_MONTH, 0)
}

func (s *IdContext) WEEK_IN_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserWEEK_IN_YEAR, 0)
}

func (s *IdContext) CONVERT_TIMEZONE() antlr.TerminalNode {
	return s.GetToken(ApexParserCONVERT_TIMEZONE, 0)
}

func (s *IdContext) YESTERDAY() antlr.TerminalNode {
	return s.GetToken(ApexParserYESTERDAY, 0)
}

func (s *IdContext) TODAY() antlr.TerminalNode {
	return s.GetToken(ApexParserTODAY, 0)
}

func (s *IdContext) TOMORROW() antlr.TerminalNode {
	return s.GetToken(ApexParserTOMORROW, 0)
}

func (s *IdContext) LAST_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_WEEK, 0)
}

func (s *IdContext) THIS_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_WEEK, 0)
}

func (s *IdContext) NEXT_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_WEEK, 0)
}

func (s *IdContext) LAST_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_MONTH, 0)
}

func (s *IdContext) THIS_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_MONTH, 0)
}

func (s *IdContext) NEXT_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_MONTH, 0)
}

func (s *IdContext) LAST_90_DAYS() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_90_DAYS, 0)
}

func (s *IdContext) NEXT_90_DAYS() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_90_DAYS, 0)
}

func (s *IdContext) LAST_N_DAYS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_DAYS_N, 0)
}

func (s *IdContext) NEXT_N_DAYS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_DAYS_N, 0)
}

func (s *IdContext) N_DAYS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_DAYS_AGO_N, 0)
}

func (s *IdContext) NEXT_N_WEEKS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_WEEKS_N, 0)
}

func (s *IdContext) LAST_N_WEEKS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_WEEKS_N, 0)
}

func (s *IdContext) N_WEEKS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_WEEKS_AGO_N, 0)
}

func (s *IdContext) NEXT_N_MONTHS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_MONTHS_N, 0)
}

func (s *IdContext) LAST_N_MONTHS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_MONTHS_N, 0)
}

func (s *IdContext) N_MONTHS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_MONTHS_AGO_N, 0)
}

func (s *IdContext) THIS_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_QUARTER, 0)
}

func (s *IdContext) LAST_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_QUARTER, 0)
}

func (s *IdContext) NEXT_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_QUARTER, 0)
}

func (s *IdContext) NEXT_N_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_QUARTERS_N, 0)
}

func (s *IdContext) LAST_N_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_QUARTERS_N, 0)
}

func (s *IdContext) N_QUARTERS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_QUARTERS_AGO_N, 0)
}

func (s *IdContext) THIS_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_YEAR, 0)
}

func (s *IdContext) LAST_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_YEAR, 0)
}

func (s *IdContext) NEXT_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_YEAR, 0)
}

func (s *IdContext) NEXT_N_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_YEARS_N, 0)
}

func (s *IdContext) LAST_N_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_YEARS_N, 0)
}

func (s *IdContext) N_YEARS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_YEARS_AGO_N, 0)
}

func (s *IdContext) THIS_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_FISCAL_QUARTER, 0)
}

func (s *IdContext) LAST_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_FISCAL_QUARTER, 0)
}

func (s *IdContext) NEXT_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_FISCAL_QUARTER, 0)
}

func (s *IdContext) NEXT_N_FISCAL_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_FISCAL_QUARTERS_N, 0)
}

func (s *IdContext) LAST_N_FISCAL_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_FISCAL_QUARTERS_N, 0)
}

func (s *IdContext) N_FISCAL_QUARTERS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_FISCAL_QUARTERS_AGO_N, 0)
}

func (s *IdContext) THIS_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_FISCAL_YEAR, 0)
}

func (s *IdContext) LAST_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_FISCAL_YEAR, 0)
}

func (s *IdContext) NEXT_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_FISCAL_YEAR, 0)
}

func (s *IdContext) NEXT_N_FISCAL_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_FISCAL_YEARS_N, 0)
}

func (s *IdContext) LAST_N_FISCAL_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_FISCAL_YEARS_N, 0)
}

func (s *IdContext) N_FISCAL_YEARS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_FISCAL_YEARS_AGO_N, 0)
}

func (s *IdContext) FIND() antlr.TerminalNode {
	return s.GetToken(ApexParserFIND, 0)
}

func (s *IdContext) EMAIL() antlr.TerminalNode {
	return s.GetToken(ApexParserEMAIL, 0)
}

func (s *IdContext) NAME() antlr.TerminalNode {
	return s.GetToken(ApexParserNAME, 0)
}

func (s *IdContext) PHONE() antlr.TerminalNode {
	return s.GetToken(ApexParserPHONE, 0)
}

func (s *IdContext) SIDEBAR() antlr.TerminalNode {
	return s.GetToken(ApexParserSIDEBAR, 0)
}

func (s *IdContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(ApexParserFIELDS, 0)
}

func (s *IdContext) METADATA() antlr.TerminalNode {
	return s.GetToken(ApexParserMETADATA, 0)
}

func (s *IdContext) PRICEBOOKID() antlr.TerminalNode {
	return s.GetToken(ApexParserPRICEBOOKID, 0)
}

func (s *IdContext) NETWORK() antlr.TerminalNode {
	return s.GetToken(ApexParserNETWORK, 0)
}

func (s *IdContext) SNIPPET() antlr.TerminalNode {
	return s.GetToken(ApexParserSNIPPET, 0)
}

func (s *IdContext) TARGET_LENGTH() antlr.TerminalNode {
	return s.GetToken(ApexParserTARGET_LENGTH, 0)
}

func (s *IdContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(ApexParserDIVISION, 0)
}

func (s *IdContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(ApexParserRETURNING, 0)
}

func (s *IdContext) LISTVIEW() antlr.TerminalNode {
	return s.GetToken(ApexParserLISTVIEW, 0)
}

func (s *IdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterId(s)
	}
}

func (s *IdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitId(s)
	}
}




func (p *ApexParser) Id() (localctx IIdContext) {
	localctx = NewIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, ApexParserRULE_id)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1973)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -114828269935591412) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || _la == ApexParserIdentifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAnyIdContext is an interface to support dynamic dispatch.
type IAnyIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	BREAK() antlr.TerminalNode
	CATCH() antlr.TerminalNode
	CLASS() antlr.TerminalNode
	CONTINUE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DO() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	EXTENDS() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	FINALLY() antlr.TerminalNode
	FOR() antlr.TerminalNode
	GET() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	IF() antlr.TerminalNode
	IMPLEMENTS() antlr.TerminalNode
	INHERITED() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	INSTANCEOF() antlr.TerminalNode
	INTERFACE() antlr.TerminalNode
	LIST() antlr.TerminalNode
	MAP() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	NEW() antlr.TerminalNode
	NULL() antlr.TerminalNode
	ON() antlr.TerminalNode
	OVERRIDE() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PUBLIC() antlr.TerminalNode
	RETURN() antlr.TerminalNode
	SET() antlr.TerminalNode
	SHARING() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	SWITCH() antlr.TerminalNode
	TESTMETHOD() antlr.TerminalNode
	THIS() antlr.TerminalNode
	THROW() antlr.TerminalNode
	TRANSIENT() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	TRY() antlr.TerminalNode
	UNDELETE() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	UPSERT() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode
	WEBSERVICE() antlr.TerminalNode
	WHEN() antlr.TerminalNode
	WHILE() antlr.TerminalNode
	WITH() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	USER() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	IntegralCurrencyLiteral() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	FROM() antlr.TerminalNode
	AS() antlr.TerminalNode
	USING() antlr.TerminalNode
	SCOPE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	SOQLAND() antlr.TerminalNode
	SOQLOR() antlr.TerminalNode
	NOT() antlr.TerminalNode
	AVG() antlr.TerminalNode
	COUNT_DISTINCT() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MAX() antlr.TerminalNode
	SUM() antlr.TerminalNode
	TYPEOF() antlr.TerminalNode
	END() antlr.TerminalNode
	THEN() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	IN() antlr.TerminalNode
	INCLUDES() antlr.TerminalNode
	EXCLUDES() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	HAVING() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	TOLABEL() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	DATA() antlr.TerminalNode
	CATEGORY() antlr.TerminalNode
	AT() antlr.TerminalNode
	ABOVE() antlr.TerminalNode
	BELOW() antlr.TerminalNode
	ABOVE_OR_BELOW() antlr.TerminalNode
	SECURITY_ENFORCED() antlr.TerminalNode
	SYSTEM_MODE() antlr.TerminalNode
	USER_MODE() antlr.TerminalNode
	REFERENCE() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	TRACKING() antlr.TerminalNode
	VIEWSTAT() antlr.TerminalNode
	STANDARD() antlr.TerminalNode
	CUSTOM() antlr.TerminalNode
	DISTANCE() antlr.TerminalNode
	GEOLOCATION() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	CONVERT_CURRENCY() antlr.TerminalNode
	CALENDAR_MONTH() antlr.TerminalNode
	CALENDAR_QUARTER() antlr.TerminalNode
	CALENDAR_YEAR() antlr.TerminalNode
	DAY_IN_MONTH() antlr.TerminalNode
	DAY_IN_WEEK() antlr.TerminalNode
	DAY_IN_YEAR() antlr.TerminalNode
	DAY_ONLY() antlr.TerminalNode
	FISCAL_MONTH() antlr.TerminalNode
	FISCAL_QUARTER() antlr.TerminalNode
	FISCAL_YEAR() antlr.TerminalNode
	HOUR_IN_DAY() antlr.TerminalNode
	WEEK_IN_MONTH() antlr.TerminalNode
	WEEK_IN_YEAR() antlr.TerminalNode
	CONVERT_TIMEZONE() antlr.TerminalNode
	YESTERDAY() antlr.TerminalNode
	TODAY() antlr.TerminalNode
	TOMORROW() antlr.TerminalNode
	LAST_WEEK() antlr.TerminalNode
	THIS_WEEK() antlr.TerminalNode
	NEXT_WEEK() antlr.TerminalNode
	LAST_MONTH() antlr.TerminalNode
	THIS_MONTH() antlr.TerminalNode
	NEXT_MONTH() antlr.TerminalNode
	LAST_90_DAYS() antlr.TerminalNode
	NEXT_90_DAYS() antlr.TerminalNode
	LAST_N_DAYS_N() antlr.TerminalNode
	NEXT_N_DAYS_N() antlr.TerminalNode
	N_DAYS_AGO_N() antlr.TerminalNode
	NEXT_N_WEEKS_N() antlr.TerminalNode
	LAST_N_WEEKS_N() antlr.TerminalNode
	N_WEEKS_AGO_N() antlr.TerminalNode
	NEXT_N_MONTHS_N() antlr.TerminalNode
	LAST_N_MONTHS_N() antlr.TerminalNode
	N_MONTHS_AGO_N() antlr.TerminalNode
	THIS_QUARTER() antlr.TerminalNode
	LAST_QUARTER() antlr.TerminalNode
	NEXT_QUARTER() antlr.TerminalNode
	NEXT_N_QUARTERS_N() antlr.TerminalNode
	LAST_N_QUARTERS_N() antlr.TerminalNode
	N_QUARTERS_AGO_N() antlr.TerminalNode
	THIS_YEAR() antlr.TerminalNode
	LAST_YEAR() antlr.TerminalNode
	NEXT_YEAR() antlr.TerminalNode
	NEXT_N_YEARS_N() antlr.TerminalNode
	LAST_N_YEARS_N() antlr.TerminalNode
	N_YEARS_AGO_N() antlr.TerminalNode
	THIS_FISCAL_QUARTER() antlr.TerminalNode
	LAST_FISCAL_QUARTER() antlr.TerminalNode
	NEXT_FISCAL_QUARTER() antlr.TerminalNode
	NEXT_N_FISCAL_QUARTERS_N() antlr.TerminalNode
	LAST_N_FISCAL_QUARTERS_N() antlr.TerminalNode
	N_FISCAL_QUARTERS_AGO_N() antlr.TerminalNode
	THIS_FISCAL_YEAR() antlr.TerminalNode
	LAST_FISCAL_YEAR() antlr.TerminalNode
	NEXT_FISCAL_YEAR() antlr.TerminalNode
	NEXT_N_FISCAL_YEARS_N() antlr.TerminalNode
	LAST_N_FISCAL_YEARS_N() antlr.TerminalNode
	N_FISCAL_YEARS_AGO_N() antlr.TerminalNode
	FIND() antlr.TerminalNode
	EMAIL() antlr.TerminalNode
	NAME() antlr.TerminalNode
	PHONE() antlr.TerminalNode
	SIDEBAR() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	METADATA() antlr.TerminalNode
	PRICEBOOKID() antlr.TerminalNode
	NETWORK() antlr.TerminalNode
	SNIPPET() antlr.TerminalNode
	TARGET_LENGTH() antlr.TerminalNode
	DIVISION() antlr.TerminalNode
	RETURNING() antlr.TerminalNode
	LISTVIEW() antlr.TerminalNode

	// IsAnyIdContext differentiates from other interfaces.
	IsAnyIdContext()
}

type AnyIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyIdContext() *AnyIdContext {
	var p = new(AnyIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_anyId
	return p
}

func InitEmptyAnyIdContext(p *AnyIdContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ApexParserRULE_anyId
}

func (*AnyIdContext) IsAnyIdContext() {}

func NewAnyIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyIdContext {
	var p = new(AnyIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ApexParserRULE_anyId

	return p
}

func (s *AnyIdContext) GetParser() antlr.Parser { return s.parser }

func (s *AnyIdContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ApexParserIdentifier, 0)
}

func (s *AnyIdContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(ApexParserABSTRACT, 0)
}

func (s *AnyIdContext) AFTER() antlr.TerminalNode {
	return s.GetToken(ApexParserAFTER, 0)
}

func (s *AnyIdContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(ApexParserBEFORE, 0)
}

func (s *AnyIdContext) BREAK() antlr.TerminalNode {
	return s.GetToken(ApexParserBREAK, 0)
}

func (s *AnyIdContext) CATCH() antlr.TerminalNode {
	return s.GetToken(ApexParserCATCH, 0)
}

func (s *AnyIdContext) CLASS() antlr.TerminalNode {
	return s.GetToken(ApexParserCLASS, 0)
}

func (s *AnyIdContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(ApexParserCONTINUE, 0)
}

func (s *AnyIdContext) DELETE() antlr.TerminalNode {
	return s.GetToken(ApexParserDELETE, 0)
}

func (s *AnyIdContext) DO() antlr.TerminalNode {
	return s.GetToken(ApexParserDO, 0)
}

func (s *AnyIdContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ApexParserELSE, 0)
}

func (s *AnyIdContext) ENUM() antlr.TerminalNode {
	return s.GetToken(ApexParserENUM, 0)
}

func (s *AnyIdContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ApexParserEXTENDS, 0)
}

func (s *AnyIdContext) FINAL() antlr.TerminalNode {
	return s.GetToken(ApexParserFINAL, 0)
}

func (s *AnyIdContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(ApexParserFINALLY, 0)
}

func (s *AnyIdContext) FOR() antlr.TerminalNode {
	return s.GetToken(ApexParserFOR, 0)
}

func (s *AnyIdContext) GET() antlr.TerminalNode {
	return s.GetToken(ApexParserGET, 0)
}

func (s *AnyIdContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(ApexParserGLOBAL, 0)
}

func (s *AnyIdContext) IF() antlr.TerminalNode {
	return s.GetToken(ApexParserIF, 0)
}

func (s *AnyIdContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(ApexParserIMPLEMENTS, 0)
}

func (s *AnyIdContext) INHERITED() antlr.TerminalNode {
	return s.GetToken(ApexParserINHERITED, 0)
}

func (s *AnyIdContext) INSERT() antlr.TerminalNode {
	return s.GetToken(ApexParserINSERT, 0)
}

func (s *AnyIdContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(ApexParserINSTANCEOF, 0)
}

func (s *AnyIdContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(ApexParserINTERFACE, 0)
}

func (s *AnyIdContext) LIST() antlr.TerminalNode {
	return s.GetToken(ApexParserLIST, 0)
}

func (s *AnyIdContext) MAP() antlr.TerminalNode {
	return s.GetToken(ApexParserMAP, 0)
}

func (s *AnyIdContext) MERGE() antlr.TerminalNode {
	return s.GetToken(ApexParserMERGE, 0)
}

func (s *AnyIdContext) NEW() antlr.TerminalNode {
	return s.GetToken(ApexParserNEW, 0)
}

func (s *AnyIdContext) NULL() antlr.TerminalNode {
	return s.GetToken(ApexParserNULL, 0)
}

func (s *AnyIdContext) ON() antlr.TerminalNode {
	return s.GetToken(ApexParserON, 0)
}

func (s *AnyIdContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(ApexParserOVERRIDE, 0)
}

func (s *AnyIdContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(ApexParserPRIVATE, 0)
}

func (s *AnyIdContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(ApexParserPROTECTED, 0)
}

func (s *AnyIdContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(ApexParserPUBLIC, 0)
}

func (s *AnyIdContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ApexParserRETURN, 0)
}

func (s *AnyIdContext) SET() antlr.TerminalNode {
	return s.GetToken(ApexParserSET, 0)
}

func (s *AnyIdContext) SHARING() antlr.TerminalNode {
	return s.GetToken(ApexParserSHARING, 0)
}

func (s *AnyIdContext) STATIC() antlr.TerminalNode {
	return s.GetToken(ApexParserSTATIC, 0)
}

func (s *AnyIdContext) SUPER() antlr.TerminalNode {
	return s.GetToken(ApexParserSUPER, 0)
}

func (s *AnyIdContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(ApexParserSWITCH, 0)
}

func (s *AnyIdContext) TESTMETHOD() antlr.TerminalNode {
	return s.GetToken(ApexParserTESTMETHOD, 0)
}

func (s *AnyIdContext) THIS() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS, 0)
}

func (s *AnyIdContext) THROW() antlr.TerminalNode {
	return s.GetToken(ApexParserTHROW, 0)
}

func (s *AnyIdContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(ApexParserTRANSIENT, 0)
}

func (s *AnyIdContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(ApexParserTRIGGER, 0)
}

func (s *AnyIdContext) TRY() antlr.TerminalNode {
	return s.GetToken(ApexParserTRY, 0)
}

func (s *AnyIdContext) UNDELETE() antlr.TerminalNode {
	return s.GetToken(ApexParserUNDELETE, 0)
}

func (s *AnyIdContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ApexParserUPDATE, 0)
}

func (s *AnyIdContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(ApexParserUPSERT, 0)
}

func (s *AnyIdContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(ApexParserVIRTUAL, 0)
}

func (s *AnyIdContext) WEBSERVICE() antlr.TerminalNode {
	return s.GetToken(ApexParserWEBSERVICE, 0)
}

func (s *AnyIdContext) WHEN() antlr.TerminalNode {
	return s.GetToken(ApexParserWHEN, 0)
}

func (s *AnyIdContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ApexParserWHILE, 0)
}

func (s *AnyIdContext) WITH() antlr.TerminalNode {
	return s.GetToken(ApexParserWITH, 0)
}

func (s *AnyIdContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(ApexParserWITHOUT, 0)
}

func (s *AnyIdContext) USER() antlr.TerminalNode {
	return s.GetToken(ApexParserUSER, 0)
}

func (s *AnyIdContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(ApexParserSYSTEM, 0)
}

func (s *AnyIdContext) IntegralCurrencyLiteral() antlr.TerminalNode {
	return s.GetToken(ApexParserIntegralCurrencyLiteral, 0)
}

func (s *AnyIdContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ApexParserSELECT, 0)
}

func (s *AnyIdContext) COUNT() antlr.TerminalNode {
	return s.GetToken(ApexParserCOUNT, 0)
}

func (s *AnyIdContext) FROM() antlr.TerminalNode {
	return s.GetToken(ApexParserFROM, 0)
}

func (s *AnyIdContext) AS() antlr.TerminalNode {
	return s.GetToken(ApexParserAS, 0)
}

func (s *AnyIdContext) USING() antlr.TerminalNode {
	return s.GetToken(ApexParserUSING, 0)
}

func (s *AnyIdContext) SCOPE() antlr.TerminalNode {
	return s.GetToken(ApexParserSCOPE, 0)
}

func (s *AnyIdContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ApexParserWHERE, 0)
}

func (s *AnyIdContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ApexParserORDER, 0)
}

func (s *AnyIdContext) BY() antlr.TerminalNode {
	return s.GetToken(ApexParserBY, 0)
}

func (s *AnyIdContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ApexParserLIMIT, 0)
}

func (s *AnyIdContext) SOQLAND() antlr.TerminalNode {
	return s.GetToken(ApexParserSOQLAND, 0)
}

func (s *AnyIdContext) SOQLOR() antlr.TerminalNode {
	return s.GetToken(ApexParserSOQLOR, 0)
}

func (s *AnyIdContext) NOT() antlr.TerminalNode {
	return s.GetToken(ApexParserNOT, 0)
}

func (s *AnyIdContext) AVG() antlr.TerminalNode {
	return s.GetToken(ApexParserAVG, 0)
}

func (s *AnyIdContext) COUNT_DISTINCT() antlr.TerminalNode {
	return s.GetToken(ApexParserCOUNT_DISTINCT, 0)
}

func (s *AnyIdContext) MIN() antlr.TerminalNode {
	return s.GetToken(ApexParserMIN, 0)
}

func (s *AnyIdContext) MAX() antlr.TerminalNode {
	return s.GetToken(ApexParserMAX, 0)
}

func (s *AnyIdContext) SUM() antlr.TerminalNode {
	return s.GetToken(ApexParserSUM, 0)
}

func (s *AnyIdContext) TYPEOF() antlr.TerminalNode {
	return s.GetToken(ApexParserTYPEOF, 0)
}

func (s *AnyIdContext) END() antlr.TerminalNode {
	return s.GetToken(ApexParserEND, 0)
}

func (s *AnyIdContext) THEN() antlr.TerminalNode {
	return s.GetToken(ApexParserTHEN, 0)
}

func (s *AnyIdContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ApexParserLIKE, 0)
}

func (s *AnyIdContext) IN() antlr.TerminalNode {
	return s.GetToken(ApexParserIN, 0)
}

func (s *AnyIdContext) INCLUDES() antlr.TerminalNode {
	return s.GetToken(ApexParserINCLUDES, 0)
}

func (s *AnyIdContext) EXCLUDES() antlr.TerminalNode {
	return s.GetToken(ApexParserEXCLUDES, 0)
}

func (s *AnyIdContext) ASC() antlr.TerminalNode {
	return s.GetToken(ApexParserASC, 0)
}

func (s *AnyIdContext) DESC() antlr.TerminalNode {
	return s.GetToken(ApexParserDESC, 0)
}

func (s *AnyIdContext) NULLS() antlr.TerminalNode {
	return s.GetToken(ApexParserNULLS, 0)
}

func (s *AnyIdContext) FIRST() antlr.TerminalNode {
	return s.GetToken(ApexParserFIRST, 0)
}

func (s *AnyIdContext) LAST() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST, 0)
}

func (s *AnyIdContext) GROUP() antlr.TerminalNode {
	return s.GetToken(ApexParserGROUP, 0)
}

func (s *AnyIdContext) ALL() antlr.TerminalNode {
	return s.GetToken(ApexParserALL, 0)
}

func (s *AnyIdContext) ROWS() antlr.TerminalNode {
	return s.GetToken(ApexParserROWS, 0)
}

func (s *AnyIdContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ApexParserVIEW, 0)
}

func (s *AnyIdContext) HAVING() antlr.TerminalNode {
	return s.GetToken(ApexParserHAVING, 0)
}

func (s *AnyIdContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(ApexParserROLLUP, 0)
}

func (s *AnyIdContext) TOLABEL() antlr.TerminalNode {
	return s.GetToken(ApexParserTOLABEL, 0)
}

func (s *AnyIdContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(ApexParserOFFSET, 0)
}

func (s *AnyIdContext) DATA() antlr.TerminalNode {
	return s.GetToken(ApexParserDATA, 0)
}

func (s *AnyIdContext) CATEGORY() antlr.TerminalNode {
	return s.GetToken(ApexParserCATEGORY, 0)
}

func (s *AnyIdContext) AT() antlr.TerminalNode {
	return s.GetToken(ApexParserAT, 0)
}

func (s *AnyIdContext) ABOVE() antlr.TerminalNode {
	return s.GetToken(ApexParserABOVE, 0)
}

func (s *AnyIdContext) BELOW() antlr.TerminalNode {
	return s.GetToken(ApexParserBELOW, 0)
}

func (s *AnyIdContext) ABOVE_OR_BELOW() antlr.TerminalNode {
	return s.GetToken(ApexParserABOVE_OR_BELOW, 0)
}

func (s *AnyIdContext) SECURITY_ENFORCED() antlr.TerminalNode {
	return s.GetToken(ApexParserSECURITY_ENFORCED, 0)
}

func (s *AnyIdContext) SYSTEM_MODE() antlr.TerminalNode {
	return s.GetToken(ApexParserSYSTEM_MODE, 0)
}

func (s *AnyIdContext) USER_MODE() antlr.TerminalNode {
	return s.GetToken(ApexParserUSER_MODE, 0)
}

func (s *AnyIdContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(ApexParserREFERENCE, 0)
}

func (s *AnyIdContext) CUBE() antlr.TerminalNode {
	return s.GetToken(ApexParserCUBE, 0)
}

func (s *AnyIdContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ApexParserFORMAT, 0)
}

func (s *AnyIdContext) TRACKING() antlr.TerminalNode {
	return s.GetToken(ApexParserTRACKING, 0)
}

func (s *AnyIdContext) VIEWSTAT() antlr.TerminalNode {
	return s.GetToken(ApexParserVIEWSTAT, 0)
}

func (s *AnyIdContext) STANDARD() antlr.TerminalNode {
	return s.GetToken(ApexParserSTANDARD, 0)
}

func (s *AnyIdContext) CUSTOM() antlr.TerminalNode {
	return s.GetToken(ApexParserCUSTOM, 0)
}

func (s *AnyIdContext) DISTANCE() antlr.TerminalNode {
	return s.GetToken(ApexParserDISTANCE, 0)
}

func (s *AnyIdContext) GEOLOCATION() antlr.TerminalNode {
	return s.GetToken(ApexParserGEOLOCATION, 0)
}

func (s *AnyIdContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(ApexParserGROUPING, 0)
}

func (s *AnyIdContext) CONVERT_CURRENCY() antlr.TerminalNode {
	return s.GetToken(ApexParserCONVERT_CURRENCY, 0)
}

func (s *AnyIdContext) CALENDAR_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_MONTH, 0)
}

func (s *AnyIdContext) CALENDAR_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_QUARTER, 0)
}

func (s *AnyIdContext) CALENDAR_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserCALENDAR_YEAR, 0)
}

func (s *AnyIdContext) DAY_IN_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_MONTH, 0)
}

func (s *AnyIdContext) DAY_IN_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_WEEK, 0)
}

func (s *AnyIdContext) DAY_IN_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_IN_YEAR, 0)
}

func (s *AnyIdContext) DAY_ONLY() antlr.TerminalNode {
	return s.GetToken(ApexParserDAY_ONLY, 0)
}

func (s *AnyIdContext) FISCAL_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_MONTH, 0)
}

func (s *AnyIdContext) FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_QUARTER, 0)
}

func (s *AnyIdContext) FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserFISCAL_YEAR, 0)
}

func (s *AnyIdContext) HOUR_IN_DAY() antlr.TerminalNode {
	return s.GetToken(ApexParserHOUR_IN_DAY, 0)
}

func (s *AnyIdContext) WEEK_IN_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserWEEK_IN_MONTH, 0)
}

func (s *AnyIdContext) WEEK_IN_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserWEEK_IN_YEAR, 0)
}

func (s *AnyIdContext) CONVERT_TIMEZONE() antlr.TerminalNode {
	return s.GetToken(ApexParserCONVERT_TIMEZONE, 0)
}

func (s *AnyIdContext) YESTERDAY() antlr.TerminalNode {
	return s.GetToken(ApexParserYESTERDAY, 0)
}

func (s *AnyIdContext) TODAY() antlr.TerminalNode {
	return s.GetToken(ApexParserTODAY, 0)
}

func (s *AnyIdContext) TOMORROW() antlr.TerminalNode {
	return s.GetToken(ApexParserTOMORROW, 0)
}

func (s *AnyIdContext) LAST_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_WEEK, 0)
}

func (s *AnyIdContext) THIS_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_WEEK, 0)
}

func (s *AnyIdContext) NEXT_WEEK() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_WEEK, 0)
}

func (s *AnyIdContext) LAST_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_MONTH, 0)
}

func (s *AnyIdContext) THIS_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_MONTH, 0)
}

func (s *AnyIdContext) NEXT_MONTH() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_MONTH, 0)
}

func (s *AnyIdContext) LAST_90_DAYS() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_90_DAYS, 0)
}

func (s *AnyIdContext) NEXT_90_DAYS() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_90_DAYS, 0)
}

func (s *AnyIdContext) LAST_N_DAYS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_DAYS_N, 0)
}

func (s *AnyIdContext) NEXT_N_DAYS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_DAYS_N, 0)
}

func (s *AnyIdContext) N_DAYS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_DAYS_AGO_N, 0)
}

func (s *AnyIdContext) NEXT_N_WEEKS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_WEEKS_N, 0)
}

func (s *AnyIdContext) LAST_N_WEEKS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_WEEKS_N, 0)
}

func (s *AnyIdContext) N_WEEKS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_WEEKS_AGO_N, 0)
}

func (s *AnyIdContext) NEXT_N_MONTHS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_MONTHS_N, 0)
}

func (s *AnyIdContext) LAST_N_MONTHS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_MONTHS_N, 0)
}

func (s *AnyIdContext) N_MONTHS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_MONTHS_AGO_N, 0)
}

func (s *AnyIdContext) THIS_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_QUARTER, 0)
}

func (s *AnyIdContext) LAST_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_QUARTER, 0)
}

func (s *AnyIdContext) NEXT_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_QUARTER, 0)
}

func (s *AnyIdContext) NEXT_N_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_QUARTERS_N, 0)
}

func (s *AnyIdContext) LAST_N_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_QUARTERS_N, 0)
}

func (s *AnyIdContext) N_QUARTERS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_QUARTERS_AGO_N, 0)
}

func (s *AnyIdContext) THIS_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_YEAR, 0)
}

func (s *AnyIdContext) LAST_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_YEAR, 0)
}

func (s *AnyIdContext) NEXT_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_YEAR, 0)
}

func (s *AnyIdContext) NEXT_N_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_YEARS_N, 0)
}

func (s *AnyIdContext) LAST_N_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_YEARS_N, 0)
}

func (s *AnyIdContext) N_YEARS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_YEARS_AGO_N, 0)
}

func (s *AnyIdContext) THIS_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_FISCAL_QUARTER, 0)
}

func (s *AnyIdContext) LAST_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_FISCAL_QUARTER, 0)
}

func (s *AnyIdContext) NEXT_FISCAL_QUARTER() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_FISCAL_QUARTER, 0)
}

func (s *AnyIdContext) NEXT_N_FISCAL_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_FISCAL_QUARTERS_N, 0)
}

func (s *AnyIdContext) LAST_N_FISCAL_QUARTERS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_FISCAL_QUARTERS_N, 0)
}

func (s *AnyIdContext) N_FISCAL_QUARTERS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_FISCAL_QUARTERS_AGO_N, 0)
}

func (s *AnyIdContext) THIS_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserTHIS_FISCAL_YEAR, 0)
}

func (s *AnyIdContext) LAST_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_FISCAL_YEAR, 0)
}

func (s *AnyIdContext) NEXT_FISCAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_FISCAL_YEAR, 0)
}

func (s *AnyIdContext) NEXT_N_FISCAL_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserNEXT_N_FISCAL_YEARS_N, 0)
}

func (s *AnyIdContext) LAST_N_FISCAL_YEARS_N() antlr.TerminalNode {
	return s.GetToken(ApexParserLAST_N_FISCAL_YEARS_N, 0)
}

func (s *AnyIdContext) N_FISCAL_YEARS_AGO_N() antlr.TerminalNode {
	return s.GetToken(ApexParserN_FISCAL_YEARS_AGO_N, 0)
}

func (s *AnyIdContext) FIND() antlr.TerminalNode {
	return s.GetToken(ApexParserFIND, 0)
}

func (s *AnyIdContext) EMAIL() antlr.TerminalNode {
	return s.GetToken(ApexParserEMAIL, 0)
}

func (s *AnyIdContext) NAME() antlr.TerminalNode {
	return s.GetToken(ApexParserNAME, 0)
}

func (s *AnyIdContext) PHONE() antlr.TerminalNode {
	return s.GetToken(ApexParserPHONE, 0)
}

func (s *AnyIdContext) SIDEBAR() antlr.TerminalNode {
	return s.GetToken(ApexParserSIDEBAR, 0)
}

func (s *AnyIdContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(ApexParserFIELDS, 0)
}

func (s *AnyIdContext) METADATA() antlr.TerminalNode {
	return s.GetToken(ApexParserMETADATA, 0)
}

func (s *AnyIdContext) PRICEBOOKID() antlr.TerminalNode {
	return s.GetToken(ApexParserPRICEBOOKID, 0)
}

func (s *AnyIdContext) NETWORK() antlr.TerminalNode {
	return s.GetToken(ApexParserNETWORK, 0)
}

func (s *AnyIdContext) SNIPPET() antlr.TerminalNode {
	return s.GetToken(ApexParserSNIPPET, 0)
}

func (s *AnyIdContext) TARGET_LENGTH() antlr.TerminalNode {
	return s.GetToken(ApexParserTARGET_LENGTH, 0)
}

func (s *AnyIdContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(ApexParserDIVISION, 0)
}

func (s *AnyIdContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(ApexParserRETURNING, 0)
}

func (s *AnyIdContext) LISTVIEW() antlr.TerminalNode {
	return s.GetToken(ApexParserLISTVIEW, 0)
}

func (s *AnyIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AnyIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.EnterAnyId(s)
	}
}

func (s *AnyIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ApexParserListener); ok {
		listenerT.ExitAnyId(s)
	}
}




func (p *ApexParser) AnyId() (localctx IAnyIdContext) {
	localctx = NewAnyIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, ApexParserRULE_anyId)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1975)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -562958543355906) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -422212465065985) != 0) || _la == ApexParserIdentifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


func (p *ApexParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 76:
			var t *ExpressionContext = nil
			if localctx != nil { t = localctx.(*ExpressionContext) }
			return p.Expression_Sempred(t, predIndex)


	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *ApexParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
			return p.Precpred(p.GetParserRuleContext(), 14)

	case 1:
			return p.Precpred(p.GetParserRuleContext(), 13)

	case 2:
			return p.Precpred(p.GetParserRuleContext(), 12)

	case 3:
			return p.Precpred(p.GetParserRuleContext(), 11)

	case 4:
			return p.Precpred(p.GetParserRuleContext(), 9)

	case 5:
			return p.Precpred(p.GetParserRuleContext(), 8)

	case 6:
			return p.Precpred(p.GetParserRuleContext(), 7)

	case 7:
			return p.Precpred(p.GetParserRuleContext(), 6)

	case 8:
			return p.Precpred(p.GetParserRuleContext(), 5)

	case 9:
			return p.Precpred(p.GetParserRuleContext(), 4)

	case 10:
			return p.Precpred(p.GetParserRuleContext(), 3)

	case 11:
			return p.Precpred(p.GetParserRuleContext(), 2)

	case 12:
			return p.Precpred(p.GetParserRuleContext(), 1)

	case 13:
			return p.Precpred(p.GetParserRuleContext(), 23)

	case 14:
			return p.Precpred(p.GetParserRuleContext(), 22)

	case 15:
			return p.Precpred(p.GetParserRuleContext(), 17)

	case 16:
			return p.Precpred(p.GetParserRuleContext(), 10)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

